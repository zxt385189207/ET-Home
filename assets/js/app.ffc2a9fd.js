(window.webpackJsonp=window.webpackJsonp||[]).push([[0],[]]);!function(n){function e(e){for(var o,r,s=e[0],c=e[1],l=e[2],p=0,u=[];p<s.length;p++)r=s[p],Object.prototype.hasOwnProperty.call(a,r)&&a[r]&&u.push(a[r][0]),a[r]=0;for(o in c)Object.prototype.hasOwnProperty.call(c,o)&&(n[o]=c[o]);for(d&&d(e);u.length;)u.shift()();return i.push.apply(i,l||[]),t()}function t(){for(var n,e=0;e<i.length;e++){for(var t=i[e],o=!0,s=1;s<t.length;s++){var c=t[s];0!==a[c]&&(o=!1)}o&&(i.splice(e--,1),n=r(r.s=t[0]))}return n}var o={},a={1:0},i=[];function r(e){if(o[e])return o[e].exports;var t=o[e]={i:e,l:!1,exports:{}};return n[e].call(t.exports,t,t.exports,r),t.l=!0,t.exports}r.e=function(n){var e=[],t=a[n];if(0!==t)if(t)e.push(t[2]);else{var o=new Promise((function(e,o){t=a[n]=[e,o]}));e.push(t[2]=o);var i,s=document.createElement("script");s.charset="utf-8",s.timeout=120,r.nc&&s.setAttribute("nonce",r.nc),s.src=function(n){return r.p+"assets/js/"+({}[n]||n)+"."+{2:"fbbdf61d",3:"8494f848",4:"cd0c8f84",5:"2d050595",6:"42e16043",7:"8e7e3e5a",8:"58eb5208",9:"79c3d2c0",10:"e97fa32e",11:"54d332e4",12:"f44a82d3",13:"6a997ef1",14:"91eebba8",15:"f0fe1a2f",16:"f6a93be8",17:"e69838fc",18:"b4d244df",19:"77ce86be",20:"522c38c6",21:"5ddc1ccf",22:"99e8ee68",23:"82c4363e",24:"be760363",25:"9cf1c272",26:"63cf55ed",27:"1b095ee3",28:"2eb24b37",29:"ed14162b",30:"5dcfd290",31:"3dc6860b",32:"5b6b946d",33:"b6c2eaeb",34:"60de0211",35:"12f403f4",36:"a30ab135",37:"83ffe510",38:"1465e967",39:"0e48601a",40:"6349f9cb"}[n]+".js"}(n);var c=new Error;i=function(e){s.onerror=s.onload=null,clearTimeout(l);var t=a[n];if(0!==t){if(t){var o=e&&("load"===e.type?"missing":e.type),i=e&&e.target&&e.target.src;c.message="Loading chunk "+n+" failed.\n("+o+": "+i+")",c.name="ChunkLoadError",c.type=o,c.request=i,t[1](c)}a[n]=void 0}};var l=setTimeout((function(){i({type:"timeout",target:s})}),12e4);s.onerror=s.onload=i,document.head.appendChild(s)}return Promise.all(e)},r.m=n,r.c=o,r.d=function(n,e,t){r.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:t})},r.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},r.t=function(n,e){if(1&e&&(n=r(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var t=Object.create(null);if(r.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var o in n)r.d(t,o,function(e){return n[e]}.bind(null,o));return t},r.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return r.d(e,"a",e),e},r.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},r.p="/",r.oe=function(n){throw console.error(n),n};var s=window.webpackJsonp=window.webpackJsonp||[],c=s.push.bind(s);s.push=e,s=s.slice();for(var l=0;l<s.length;l++)e(s[l]);var d=c;i.push([95,0]),t()}([function(n,e){n.exports=function(n){return"function"==typeof n}},function(n,e){var t=function(n){return n&&n.Math==Math&&n};n.exports=t("object"==typeof globalThis&&globalThis)||t("object"==typeof window&&window)||t("object"==typeof self&&self)||t("object"==typeof global&&global)||function(){return this}()||Function("return this")()},function(n,e,t){var o=t(25),a=Function.prototype,i=a.bind,r=a.call,s=o&&i.bind(r,r);n.exports=o?function(n){return n&&s(n)}:function(n){return n&&function(){return r.apply(n,arguments)}}},function(n,e){n.exports=function(n){try{return!!n()}catch(n){return!0}}},function(n,e){var t=Array.isArray;n.exports=t},function(n,e,t){var o=t(67),a="object"==typeof self&&self&&self.Object===Object&&self,i=o||a||Function("return this")();n.exports=i},function(n,e,t){"use strict";function o(n,e,t,o,a,i,r,s){var c,l="function"==typeof n?n.options:n;if(e&&(l.render=e,l.staticRenderFns=t,l._compiled=!0),o&&(l.functional=!0),i&&(l._scopeId="data-v-"+i),r?(c=function(n){(n=n||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(n=__VUE_SSR_CONTEXT__),a&&a.call(this,n),n&&n._registeredComponents&&n._registeredComponents.add(r)},l._ssrRegister=c):a&&(c=s?function(){a.call(this,(l.functional?this.parent:this).$root.$options.shadowRoot)}:a),c)if(l.functional){l._injectStyles=c;var d=l.render;l.render=function(n,e){return c.call(e),d(n,e)}}else{var p=l.beforeCreate;l.beforeCreate=p?[].concat(p,c):[c]}return{exports:n,options:l}}t.d(e,"a",(function(){return o}))},function(n,e,t){var o=t(3);n.exports=!o((function(){return 7!=Object.defineProperty({},1,{get:function(){return 7}})[1]}))},function(n,e,t){var o=t(2),a=t(57),i=o({}.hasOwnProperty);n.exports=Object.hasOwn||function(n,e){return i(a(n),e)}},function(n,e,t){var o=t(0);n.exports=function(n){return"object"==typeof n?null!==n:o(n)}},function(n,e,t){var o=t(155),a=t(158);n.exports=function(n,e){var t=a(n,e);return o(t)?t:void 0}},function(n,e,t){"use strict";t.d(e,"e",(function(){return o})),t.d(e,"b",(function(){return i})),t.d(e,"j",(function(){return r})),t.d(e,"g",(function(){return c})),t.d(e,"h",(function(){return l})),t.d(e,"i",(function(){return d})),t.d(e,"c",(function(){return p})),t.d(e,"f",(function(){return u})),t.d(e,"l",(function(){return h})),t.d(e,"m",(function(){return m})),t.d(e,"d",(function(){return g})),t.d(e,"k",(function(){return y})),t.d(e,"n",(function(){return v})),t.d(e,"a",(function(){return w}));const o=/#.*$/,a=/\.(md|html)$/,i=/\/$/,r=/^[a-z]+:/i;function s(n){return decodeURI(n).replace(o,"").replace(a,"")}function c(n){return r.test(n)}function l(n){return/^mailto:/.test(n)}function d(n){return/^tel:/.test(n)}function p(n){if(c(n))return n;if(!n)return"404";const e=n.match(o),t=e?e[0]:"",a=s(n);return i.test(a)?n:a+".html"+t}function u(n,e){const t=n.hash,a=function(n){const e=n&&n.match(o);if(e)return e[0]}(e);if(a&&t!==a)return!1;return s(n.path)===s(e)}function h(n,e,t){if(c(e))return{type:"external",path:e};t&&(e=function(n,e,t){const o=n.charAt(0);if("/"===o)return n;if("?"===o||"#"===o)return e+n;const a=e.split("/");t&&a[a.length-1]||a.pop();const i=n.replace(/^\//,"").split("/");for(let n=0;n<i.length;n++){const e=i[n];".."===e?a.pop():"."!==e&&a.push(e)}""!==a[0]&&a.unshift("");return a.join("/")}(e,t));const o=s(e);for(let e=0;e<n.length;e++)if(s(n[e].regularPath)===o)return Object.assign({},n[e],{type:"page",path:p(n[e].path)});return console.error(`[vuepress] No matching page found for sidebar item "${e}"`),{}}function m(n,e,t,o){const{pages:a,themeConfig:i}=t,r=o&&i.locales&&i.locales[o]||i;if("auto"===(n.frontmatter.sidebar||r.sidebar||i.sidebar))return f(n);const s=r.sidebar||i.sidebar;if(s){const{base:t,config:o}=function(n,e){if(Array.isArray(e))return{base:"/",config:e};for(const o in e)if(0===(t=n,/(\.html|\/)$/.test(t)?t:t+"/").indexOf(encodeURI(o)))return{base:o,config:e[o]};var t;return{}}(e,s);return"auto"===o?f(n):o?o.map(n=>function n(e,t,o,a=1){if("string"==typeof e)return h(t,e,o);if(Array.isArray(e))return Object.assign(h(t,e[0],o),{title:e[1]});{a>3&&console.error("[vuepress] detected a too deep nested sidebar group.");const i=e.children||[];return 0===i.length&&e.path?Object.assign(h(t,e.path,o),{title:e.title}):{type:"group",path:e.path,title:e.title,sidebarDepth:e.sidebarDepth,initialOpenGroupIndex:e.initialOpenGroupIndex,children:i.map(e=>n(e,t,o,a+1)),collapsable:!1!==e.collapsable}}}(n,a,t)):[]}return[]}function f(n){const e=g(n.headers||[]);return[{type:"group",collapsable:!1,title:n.title,path:null,children:e.map(e=>({type:"auto",title:e.title,basePath:n.path,path:n.path+"#"+e.slug,children:e.children||[]}))}]}function g(n){let e;return(n=n.map(n=>Object.assign({},n))).forEach(n=>{2===n.level?e=n:e&&(e.children||(e.children=[])).push(n)}),n.filter(n=>2===n.level)}function y(n){return Object.assign(n,{type:n.items&&n.items.length?"links":"link"})}function v(n){return Object.prototype.toString.call(n).match(/\[object (.*?)\]/)[1].toLowerCase()}function b(n){let e=n.frontmatter.date||n.lastUpdated||new Date,t=new Date(e);return"Invalid Date"==t&&e&&(t=new Date(e.replace(/-/g,"/"))),t.getTime()}function w(n,e){return b(e)-b(n)}},function(n,e){n.exports=function(n){return null!=n&&"object"==typeof n}},function(n,e,t){var o=t(14),a=t(140),i=t(141),r=o?o.toStringTag:void 0;n.exports=function(n){return null==n?void 0===n?"[object Undefined]":"[object Null]":r&&r in Object(n)?a(n):i(n)}},function(n,e,t){var o=t(5).Symbol;n.exports=o},function(n,e,t){var o=t(1),a=t(0),i=function(n){return a(n)?n:void 0};n.exports=function(n,e){return arguments.length<2?i(o[n]):o[n]&&o[n][e]}},function(n,e,t){var o=t(7),a=t(17),i=t(26);n.exports=o?function(n,e,t){return a.f(n,e,i(1,t))}:function(n,e,t){return n[e]=t,n}},function(n,e,t){var o=t(7),a=t(59),i=t(104),r=t(32),s=t(48),c=TypeError,l=Object.defineProperty,d=Object.getOwnPropertyDescriptor;e.f=o?i?function(n,e,t){if(r(n),e=s(e),r(t),"function"==typeof n&&"prototype"===e&&"value"in t&&"writable"in t&&!t.writable){var o=d(n,e);o&&o.writable&&(n[e]=t.value,t={configurable:"configurable"in t?t.configurable:o.configurable,enumerable:"enumerable"in t?t.enumerable:o.enumerable,writable:!1})}return l(n,e,t)}:l:function(n,e,t){if(r(n),e=s(e),r(t),a)try{return l(n,e,t)}catch(n){}if("get"in t||"set"in t)throw c("Accessors not supported");return"value"in t&&(n[e]=t.value),n}},function(n,e,t){var o=t(145),a=t(146),i=t(147),r=t(148),s=t(149);function c(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var o=n[e];this.set(o[0],o[1])}}c.prototype.clear=o,c.prototype.delete=a,c.prototype.get=i,c.prototype.has=r,c.prototype.set=s,n.exports=c},function(n,e,t){var o=t(69);n.exports=function(n,e){for(var t=n.length;t--;)if(o(n[t][0],e))return t;return-1}},function(n,e,t){var o=t(10)(Object,"create");n.exports=o},function(n,e,t){var o=t(167);n.exports=function(n,e){var t=n.__data__;return o(e)?t["string"==typeof e?"string":"hash"]:t.map}},function(n,e,t){var o=t(40);n.exports=function(n){if("string"==typeof n||o(n))return n;var e=n+"";return"0"==e&&1/n==-1/0?"-0":e}},function(n,e,t){var o,a;
/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
 * @license MIT */void 0===(a="function"==typeof(o=function(){var n,e,t={version:"0.2.0"},o=t.settings={minimum:.08,easing:"ease",positionUsing:"",speed:200,trickle:!0,trickleRate:.02,trickleSpeed:800,showSpinner:!0,barSelector:'[role="bar"]',spinnerSelector:'[role="spinner"]',parent:"body",template:'<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'};function a(n,e,t){return n<e?e:n>t?t:n}function i(n){return 100*(-1+n)}t.configure=function(n){var e,t;for(e in n)void 0!==(t=n[e])&&n.hasOwnProperty(e)&&(o[e]=t);return this},t.status=null,t.set=function(n){var e=t.isStarted();n=a(n,o.minimum,1),t.status=1===n?null:n;var c=t.render(!e),l=c.querySelector(o.barSelector),d=o.speed,p=o.easing;return c.offsetWidth,r((function(e){""===o.positionUsing&&(o.positionUsing=t.getPositioningCSS()),s(l,function(n,e,t){var a;return(a="translate3d"===o.positionUsing?{transform:"translate3d("+i(n)+"%,0,0)"}:"translate"===o.positionUsing?{transform:"translate("+i(n)+"%,0)"}:{"margin-left":i(n)+"%"}).transition="all "+e+"ms "+t,a}(n,d,p)),1===n?(s(c,{transition:"none",opacity:1}),c.offsetWidth,setTimeout((function(){s(c,{transition:"all "+d+"ms linear",opacity:0}),setTimeout((function(){t.remove(),e()}),d)}),d)):setTimeout(e,d)})),this},t.isStarted=function(){return"number"==typeof t.status},t.start=function(){t.status||t.set(0);var n=function(){setTimeout((function(){t.status&&(t.trickle(),n())}),o.trickleSpeed)};return o.trickle&&n(),this},t.done=function(n){return n||t.status?t.inc(.3+.5*Math.random()).set(1):this},t.inc=function(n){var e=t.status;return e?("number"!=typeof n&&(n=(1-e)*a(Math.random()*e,.1,.95)),e=a(e+n,0,.994),t.set(e)):t.start()},t.trickle=function(){return t.inc(Math.random()*o.trickleRate)},n=0,e=0,t.promise=function(o){return o&&"resolved"!==o.state()?(0===e&&t.start(),n++,e++,o.always((function(){0==--e?(n=0,t.done()):t.set((n-e)/n)})),this):this},t.render=function(n){if(t.isRendered())return document.getElementById("nprogress");l(document.documentElement,"nprogress-busy");var e=document.createElement("div");e.id="nprogress",e.innerHTML=o.template;var a,r=e.querySelector(o.barSelector),c=n?"-100":i(t.status||0),d=document.querySelector(o.parent);return s(r,{transition:"all 0 linear",transform:"translate3d("+c+"%,0,0)"}),o.showSpinner||(a=e.querySelector(o.spinnerSelector))&&u(a),d!=document.body&&l(d,"nprogress-custom-parent"),d.appendChild(e),e},t.remove=function(){d(document.documentElement,"nprogress-busy"),d(document.querySelector(o.parent),"nprogress-custom-parent");var n=document.getElementById("nprogress");n&&u(n)},t.isRendered=function(){return!!document.getElementById("nprogress")},t.getPositioningCSS=function(){var n=document.body.style,e="WebkitTransform"in n?"Webkit":"MozTransform"in n?"Moz":"msTransform"in n?"ms":"OTransform"in n?"O":"";return e+"Perspective"in n?"translate3d":e+"Transform"in n?"translate":"margin"};var r=function(){var n=[];function e(){var t=n.shift();t&&t(e)}return function(t){n.push(t),1==n.length&&e()}}(),s=function(){var n=["Webkit","O","Moz","ms"],e={};function t(t){return t=t.replace(/^-ms-/,"ms-").replace(/-([\da-z])/gi,(function(n,e){return e.toUpperCase()})),e[t]||(e[t]=function(e){var t=document.body.style;if(e in t)return e;for(var o,a=n.length,i=e.charAt(0).toUpperCase()+e.slice(1);a--;)if((o=n[a]+i)in t)return o;return e}(t))}function o(n,e,o){e=t(e),n.style[e]=o}return function(n,e){var t,a,i=arguments;if(2==i.length)for(t in e)void 0!==(a=e[t])&&e.hasOwnProperty(t)&&o(n,t,a);else o(n,i[1],i[2])}}();function c(n,e){return("string"==typeof n?n:p(n)).indexOf(" "+e+" ")>=0}function l(n,e){var t=p(n),o=t+e;c(t,e)||(n.className=o.substring(1))}function d(n,e){var t,o=p(n);c(n,e)&&(t=o.replace(" "+e+" "," "),n.className=t.substring(1,t.length-1))}function p(n){return(" "+(n.className||"")+" ").replace(/\s+/gi," ")}function u(n){n&&n.parentNode&&n.parentNode.removeChild(n)}return t})?o.call(e,t,e,n):o)||(n.exports=a)},function(n,e,t){var o=t(25),a=Function.prototype.call;n.exports=o?a.bind(a):function(){return a.apply(a,arguments)}},function(n,e,t){var o=t(3);n.exports=!o((function(){var n=function(){}.bind();return"function"!=typeof n||n.hasOwnProperty("prototype")}))},function(n,e){n.exports=function(n,e){return{enumerable:!(1&n),configurable:!(2&n),writable:!(4&n),value:e}}},function(n,e,t){var o=t(46),a=t(47);n.exports=function(n){return o(a(n))}},function(n,e,t){var o=t(2),a=o({}.toString),i=o("".slice);n.exports=function(n){return i(a(n),8,-1)}},function(n,e,t){var o=t(1),a=t(55),i=t(8),r=t(58),s=t(52),c=t(51),l=a("wks"),d=o.Symbol,p=d&&d.for,u=c?d:d&&d.withoutSetter||r;n.exports=function(n){if(!i(l,n)||!s&&"string"!=typeof l[n]){var e="Symbol."+n;s&&i(d,n)?l[n]=d[n]:l[n]=c&&p?p(e):u(e)}return l[n]}},function(n,e,t){var o=t(1),a=t(31),i=o["__core-js_shared__"]||a("__core-js_shared__",{});n.exports=i},function(n,e,t){var o=t(1),a=Object.defineProperty;n.exports=function(n,e){try{a(o,n,{value:e,configurable:!0,writable:!0})}catch(t){o[n]=e}return e}},function(n,e,t){var o=t(9),a=String,i=TypeError;n.exports=function(n){if(o(n))return n;throw i(a(n)+" is not an object")}},function(n,e,t){var o=t(139),a=t(12),i=Object.prototype,r=i.hasOwnProperty,s=i.propertyIsEnumerable,c=o(function(){return arguments}())?o:function(n){return a(n)&&r.call(n,"callee")&&!s.call(n,"callee")};n.exports=c},function(n,e,t){var o=t(10)(t(5),"Map");n.exports=o},function(n,e){n.exports=function(n){var e=typeof n;return null!=n&&("object"==e||"function"==e)}},function(n,e,t){var o=t(159),a=t(166),i=t(168),r=t(169),s=t(170);function c(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var o=n[e];this.set(o[0],o[1])}}c.prototype.clear=o,c.prototype.delete=a,c.prototype.get=i,c.prototype.has=r,c.prototype.set=s,n.exports=c},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n){t[++e]=n})),t}},function(n,e){n.exports=function(n){return"number"==typeof n&&n>-1&&n%1==0&&n<=9007199254740991}},function(n,e,t){var o=t(4),a=t(40),i=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,r=/^\w*$/;n.exports=function(n,e){if(o(n))return!1;var t=typeof n;return!("number"!=t&&"symbol"!=t&&"boolean"!=t&&null!=n&&!a(n))||(r.test(n)||!i.test(n)||null!=e&&n in Object(e))}},function(n,e,t){var o=t(13),a=t(12);n.exports=function(n){return"symbol"==typeof n||a(n)&&"[object Symbol]"==o(n)}},function(n,e){n.exports=function(n){return n}},function(n,e){n.exports=function(n){return n.webpackPolyfill||(n.deprecate=function(){},n.paths=[],n.children||(n.children=[]),Object.defineProperty(n,"loaded",{enumerable:!0,get:function(){return n.l}}),Object.defineProperty(n,"id",{enumerable:!0,get:function(){return n.i}}),n.webpackPolyfill=1),n}},function(n,e){var t=/^\s+|\s+$/g,o=/^[-+]0x[0-9a-f]+$/i,a=/^0b[01]+$/i,i=/^0o[0-7]+$/i,r=parseInt,s="object"==typeof global&&global&&global.Object===Object&&global,c="object"==typeof self&&self&&self.Object===Object&&self,l=s||c||Function("return this")(),d=Object.prototype.toString,p=Math.max,u=Math.min,h=function(){return l.Date.now()};function m(n){var e=typeof n;return!!n&&("object"==e||"function"==e)}function f(n){if("number"==typeof n)return n;if(function(n){return"symbol"==typeof n||function(n){return!!n&&"object"==typeof n}(n)&&"[object Symbol]"==d.call(n)}(n))return NaN;if(m(n)){var e="function"==typeof n.valueOf?n.valueOf():n;n=m(e)?e+"":e}if("string"!=typeof n)return 0===n?n:+n;n=n.replace(t,"");var s=a.test(n);return s||i.test(n)?r(n.slice(2),s?2:8):o.test(n)?NaN:+n}n.exports=function(n,e,t){var o,a,i,r,s,c,l=0,d=!1,g=!1,y=!0;if("function"!=typeof n)throw new TypeError("Expected a function");function v(e){var t=o,i=a;return o=a=void 0,l=e,r=n.apply(i,t)}function b(n){return l=n,s=setTimeout(k,e),d?v(n):r}function w(n){var t=n-c;return void 0===c||t>=e||t<0||g&&n-l>=i}function k(){var n=h();if(w(n))return x(n);s=setTimeout(k,function(n){var t=e-(n-c);return g?u(t,i-(n-l)):t}(n))}function x(n){return s=void 0,y&&o?v(n):(o=a=void 0,r)}function T(){var n=h(),t=w(n);if(o=arguments,a=this,c=n,t){if(void 0===s)return b(c);if(g)return s=setTimeout(k,e),v(c)}return void 0===s&&(s=setTimeout(k,e)),r}return e=f(e)||0,m(t)&&(d=!!t.leading,i=(g="maxWait"in t)?p(f(t.maxWait)||0,e):i,y="trailing"in t?!!t.trailing:y),T.cancel=function(){void 0!==s&&clearTimeout(s),l=0,o=c=a=s=void 0},T.flush=function(){return void 0===s?r:x(h())},T}},function(n,e,t){var o=t(1),a=t(45).f,i=t(16),r=t(105),s=t(31),c=t(62),l=t(120);n.exports=function(n,e){var t,d,p,u,h,m=n.target,f=n.global,g=n.stat;if(t=f?o:g?o[m]||s(m,{}):(o[m]||{}).prototype)for(d in e){if(u=e[d],p=n.dontCallGetSet?(h=a(t,d))&&h.value:t[d],!l(f?d:m+(g?".":"#")+d,n.forced)&&void 0!==p){if(typeof u==typeof p)continue;c(u,p)}(n.sham||p&&p.sham)&&i(u,"sham",!0),r(t,d,u,n)}}},function(n,e,t){var o=t(7),a=t(24),i=t(97),r=t(26),s=t(27),c=t(48),l=t(8),d=t(59),p=Object.getOwnPropertyDescriptor;e.f=o?p:function(n,e){if(n=s(n),e=c(e),d)try{return p(n,e)}catch(n){}if(l(n,e))return r(!a(i.f,n,e),n[e])}},function(n,e,t){var o=t(2),a=t(3),i=t(28),r=Object,s=o("".split);n.exports=a((function(){return!r("z").propertyIsEnumerable(0)}))?function(n){return"String"==i(n)?s(n,""):r(n)}:r},function(n,e){var t=TypeError;n.exports=function(n){if(null==n)throw t("Can't call method on "+n);return n}},function(n,e,t){var o=t(98),a=t(49);n.exports=function(n){var e=o(n,"string");return a(e)?e:e+""}},function(n,e,t){var o=t(15),a=t(0),i=t(50),r=t(51),s=Object;n.exports=r?function(n){return"symbol"==typeof n}:function(n){var e=o("Symbol");return a(e)&&i(e.prototype,s(n))}},function(n,e,t){var o=t(2);n.exports=o({}.isPrototypeOf)},function(n,e,t){var o=t(52);n.exports=o&&!Symbol.sham&&"symbol"==typeof Symbol.iterator},function(n,e,t){var o=t(53),a=t(3);n.exports=!!Object.getOwnPropertySymbols&&!a((function(){var n=Symbol();return!String(n)||!(Object(n)instanceof Symbol)||!Symbol.sham&&o&&o<41}))},function(n,e,t){var o,a,i=t(1),r=t(99),s=i.process,c=i.Deno,l=s&&s.versions||c&&c.version,d=l&&l.v8;d&&(a=(o=d.split("."))[0]>0&&o[0]<4?1:+(o[0]+o[1])),!a&&r&&(!(o=r.match(/Edge\/(\d+)/))||o[1]>=74)&&(o=r.match(/Chrome\/(\d+)/))&&(a=+o[1]),n.exports=a},function(n,e,t){var o=t(0),a=t(101),i=TypeError;n.exports=function(n){if(o(n))return n;throw i(a(n)+" is not a function")}},function(n,e,t){var o=t(56),a=t(30);(n.exports=function(n,e){return a[n]||(a[n]=void 0!==e?e:{})})("versions",[]).push({version:"3.24.0",mode:o?"pure":"global",copyright:"© 2014-2022 Denis Pushkarev (zloirock.ru)",license:"https://github.com/zloirock/core-js/blob/v3.24.0/LICENSE",source:"https://github.com/zloirock/core-js"})},function(n,e){n.exports=!1},function(n,e,t){var o=t(47),a=Object;n.exports=function(n){return a(o(n))}},function(n,e,t){var o=t(2),a=0,i=Math.random(),r=o(1..toString);n.exports=function(n){return"Symbol("+(void 0===n?"":n)+")_"+r(++a+i,36)}},function(n,e,t){var o=t(7),a=t(3),i=t(103);n.exports=!o&&!a((function(){return 7!=Object.defineProperty(i("div"),"a",{get:function(){return 7}}).a}))},function(n,e,t){var o=t(2),a=t(0),i=t(30),r=o(Function.toString);a(i.inspectSource)||(i.inspectSource=function(n){return r(n)}),n.exports=i.inspectSource},function(n,e){n.exports={}},function(n,e,t){var o=t(8),a=t(111),i=t(45),r=t(17);n.exports=function(n,e,t){for(var s=a(e),c=r.f,l=i.f,d=0;d<s.length;d++){var p=s[d];o(n,p)||t&&o(t,p)||c(n,p,l(e,p))}}},function(n,e,t){var o=t(116);n.exports=function(n){var e=+n;return e!=e||0===e?0:o(e)}},function(n,e,t){var o=t(117);n.exports=function(n){return o(n.length)}},function(n,e,t){var o=t(2),a=t(32),i=t(127);n.exports=Object.setPrototypeOf||("__proto__"in{}?function(){var n,e=!1,t={};try{(n=o(Object.getOwnPropertyDescriptor(Object.prototype,"__proto__").set))(t,[]),e=t instanceof Array}catch(n){}return function(t,o){return a(t),i(o),e?n(t,o):t.__proto__=o,t}}():void 0)},function(n,e){n.exports=function(n,e){for(var t=-1,o=e.length,a=n.length;++t<o;)n[a+t]=e[t];return n}},function(n,e){var t="object"==typeof global&&global&&global.Object===Object&&global;n.exports=t},function(n,e,t){var o=t(18),a=t(150),i=t(151),r=t(152),s=t(153),c=t(154);function l(n){var e=this.__data__=new o(n);this.size=e.size}l.prototype.clear=a,l.prototype.delete=i,l.prototype.get=r,l.prototype.has=s,l.prototype.set=c,n.exports=l},function(n,e){n.exports=function(n,e){return n===e||n!=n&&e!=e}},function(n,e,t){var o=t(13),a=t(35);n.exports=function(n){if(!a(n))return!1;var e=o(n);return"[object Function]"==e||"[object GeneratorFunction]"==e||"[object AsyncFunction]"==e||"[object Proxy]"==e}},function(n,e){var t=Function.prototype.toString;n.exports=function(n){if(null!=n){try{return t.call(n)}catch(n){}try{return n+""}catch(n){}}return""}},function(n,e,t){var o=t(171),a=t(12);n.exports=function n(e,t,i,r,s){return e===t||(null==e||null==t||!a(e)&&!a(t)?e!=e&&t!=t:o(e,t,i,r,n,s))}},function(n,e,t){var o=t(74),a=t(174),i=t(75);n.exports=function(n,e,t,r,s,c){var l=1&t,d=n.length,p=e.length;if(d!=p&&!(l&&p>d))return!1;var u=c.get(n),h=c.get(e);if(u&&h)return u==e&&h==n;var m=-1,f=!0,g=2&t?new o:void 0;for(c.set(n,e),c.set(e,n);++m<d;){var y=n[m],v=e[m];if(r)var b=l?r(v,y,m,e,n,c):r(y,v,m,n,e,c);if(void 0!==b){if(b)continue;f=!1;break}if(g){if(!a(e,(function(n,e){if(!i(g,e)&&(y===n||s(y,n,t,r,c)))return g.push(e)}))){f=!1;break}}else if(y!==v&&!s(y,v,t,r,c)){f=!1;break}}return c.delete(n),c.delete(e),f}},function(n,e,t){var o=t(36),a=t(172),i=t(173);function r(n){var e=-1,t=null==n?0:n.length;for(this.__data__=new o;++e<t;)this.add(n[e])}r.prototype.add=r.prototype.push=a,r.prototype.has=i,n.exports=r},function(n,e){n.exports=function(n,e){return n.has(e)}},function(n,e,t){var o=t(184),a=t(190),i=t(80);n.exports=function(n){return i(n)?o(n):a(n)}},function(n,e,t){(function(n){var o=t(5),a=t(186),i=e&&!e.nodeType&&e,r=i&&"object"==typeof n&&n&&!n.nodeType&&n,s=r&&r.exports===i?o.Buffer:void 0,c=(s?s.isBuffer:void 0)||a;n.exports=c}).call(this,t(42)(n))},function(n,e){var t=/^(?:0|[1-9]\d*)$/;n.exports=function(n,e){var o=typeof n;return!!(e=null==e?9007199254740991:e)&&("number"==o||"symbol"!=o&&t.test(n))&&n>-1&&n%1==0&&n<e}},function(n,e,t){var o=t(187),a=t(188),i=t(189),r=i&&i.isTypedArray,s=r?a(r):o;n.exports=s},function(n,e,t){var o=t(70),a=t(38);n.exports=function(n){return null!=n&&a(n.length)&&!o(n)}},function(n,e,t){var o=t(10)(t(5),"Set");n.exports=o},function(n,e,t){var o=t(35);n.exports=function(n){return n==n&&!o(n)}},function(n,e){n.exports=function(n,e){return function(t){return null!=t&&(t[n]===e&&(void 0!==e||n in Object(t)))}}},function(n,e,t){var o=t(85),a=t(22);n.exports=function(n,e){for(var t=0,i=(e=o(e,n)).length;null!=n&&t<i;)n=n[a(e[t++])];return t&&t==i?n:void 0}},function(n,e,t){var o=t(4),a=t(39),i=t(201),r=t(204);n.exports=function(n,e){return o(n)?n:a(n,e)?[n]:i(r(n))}},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){var o=t(137),a=t(142),i=t(213),r=t(221),s=t(230),c=t(94),l=i((function(n){var e=c(n);return s(e)&&(e=void 0),r(o(n,1,s,!0),a(e,2))}));n.exports=l},function(n,e,t){"use strict";
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */var o=/["'&<>]/;n.exports=function(n){var e,t=""+n,a=o.exec(t);if(!a)return t;var i="",r=0,s=0;for(r=a.index;r<t.length;r++){switch(t.charCodeAt(r)){case 34:e="&quot;";break;case 38:e="&amp;";break;case 39:e="&#39;";break;case 60:e="&lt;";break;case 62:e="&gt;";break;default:continue}s!==r&&(i+=t.substring(s,r)),s=r+1,i+=e}return s!==r?i+t.substring(s,r):i}},function(n,e,t){"use strict";t.r(e);var o={name:"CodeBlock",props:{title:{type:String,required:!0},active:{type:Boolean,default:!1}}},a=(t(233),t(6)),i=Object(a.a)(o,(function(){return(0,this._self._c)("div",{staticClass:"theme-code-block",class:{"theme-code-block__active":this.active}},[this._t("default")],2)}),[],!1,null,"4f1e9d0c",null);e.default=i.exports},function(n,e,t){"use strict";t.r(e);var o={name:"CodeGroup",data:()=>({codeTabs:[],activeCodeTabIndex:-1}),watch:{activeCodeTabIndex(n){this.codeTabs.forEach(n=>{n.elm.classList.remove("theme-code-block__active")}),this.codeTabs[n].elm.classList.add("theme-code-block__active")}},mounted(){this.codeTabs=(this.$slots.default||[]).filter(n=>Boolean(n.componentOptions)).map((n,e)=>(""===n.componentOptions.propsData.active&&(this.activeCodeTabIndex=e),{title:n.componentOptions.propsData.title,elm:n.elm})),-1===this.activeCodeTabIndex&&this.codeTabs.length>0&&(this.activeCodeTabIndex=0)},methods:{changeCodeTab(n){this.activeCodeTabIndex=n}}},a=(t(234),t(6)),i=Object(a.a)(o,(function(){var n=this,e=n._self._c;return e("div",{staticClass:"theme-code-group"},[e("div",{staticClass:"theme-code-group__nav"},[e("ul",{staticClass:"theme-code-group__ul"},n._l(n.codeTabs,(function(t,o){return e("li",{key:t.title,staticClass:"theme-code-group__li"},[e("button",{staticClass:"theme-code-group__nav-tab",class:{"theme-code-group__nav-tab-active":o===n.activeCodeTabIndex},on:{click:function(e){return n.changeCodeTab(o)}}},[n._v("\n            "+n._s(t.title)+"\n          ")])])})),0)]),n._v(" "),n._t("default"),n._v(" "),n.codeTabs.length<1?e("pre",{staticClass:"pre-blank"},[n._v("// Make sure to add code blocks to your code group")]):n._e()],2)}),[],!1,null,"2f5f1757",null);e.default=i.exports},function(n,e){n.exports=function(n){var e=null==n?0:n.length;return e?n[e-1]:void 0}},function(n,e,t){n.exports=t(239)},function(n,e,t){"use strict";var o=t(44),a=t(121).left,i=t(122),r=t(53),s=t(123);o({target:"Array",proto:!0,forced:!i("reduce")||!s&&r>79&&r<83},{reduce:function(n){var e=arguments.length;return a(this,n,e,e>1?arguments[1]:void 0)}})},function(n,e,t){"use strict";var o={}.propertyIsEnumerable,a=Object.getOwnPropertyDescriptor,i=a&&!o.call({1:2},1);e.f=i?function(n){var e=a(this,n);return!!e&&e.enumerable}:o},function(n,e,t){var o=t(24),a=t(9),i=t(49),r=t(100),s=t(102),c=t(29),l=TypeError,d=c("toPrimitive");n.exports=function(n,e){if(!a(n)||i(n))return n;var t,c=r(n,d);if(c){if(void 0===e&&(e="default"),t=o(c,n,e),!a(t)||i(t))return t;throw l("Can't convert object to primitive value")}return void 0===e&&(e="number"),s(n,e)}},function(n,e,t){var o=t(15);n.exports=o("navigator","userAgent")||""},function(n,e,t){var o=t(54);n.exports=function(n,e){var t=n[e];return null==t?void 0:o(t)}},function(n,e){var t=String;n.exports=function(n){try{return t(n)}catch(n){return"Object"}}},function(n,e,t){var o=t(24),a=t(0),i=t(9),r=TypeError;n.exports=function(n,e){var t,s;if("string"===e&&a(t=n.toString)&&!i(s=o(t,n)))return s;if(a(t=n.valueOf)&&!i(s=o(t,n)))return s;if("string"!==e&&a(t=n.toString)&&!i(s=o(t,n)))return s;throw r("Can't convert object to primitive value")}},function(n,e,t){var o=t(1),a=t(9),i=o.document,r=a(i)&&a(i.createElement);n.exports=function(n){return r?i.createElement(n):{}}},function(n,e,t){var o=t(7),a=t(3);n.exports=o&&a((function(){return 42!=Object.defineProperty((function(){}),"prototype",{value:42,writable:!1}).prototype}))},function(n,e,t){var o=t(0),a=t(17),i=t(106),r=t(31);n.exports=function(n,e,t,s){s||(s={});var c=s.enumerable,l=void 0!==s.name?s.name:e;if(o(t)&&i(t,l,s),s.global)c?n[e]=t:r(e,t);else{try{s.unsafe?n[e]&&(c=!0):delete n[e]}catch(n){}c?n[e]=t:a.f(n,e,{value:t,enumerable:!1,configurable:!s.nonConfigurable,writable:!s.nonWritable})}return n}},function(n,e,t){var o=t(3),a=t(0),i=t(8),r=t(7),s=t(107).CONFIGURABLE,c=t(60),l=t(108),d=l.enforce,p=l.get,u=Object.defineProperty,h=r&&!o((function(){return 8!==u((function(){}),"length",{value:8}).length})),m=String(String).split("String"),f=n.exports=function(n,e,t){"Symbol("===String(e).slice(0,7)&&(e="["+String(e).replace(/^Symbol\(([^)]*)\)/,"$1")+"]"),t&&t.getter&&(e="get "+e),t&&t.setter&&(e="set "+e),(!i(n,"name")||s&&n.name!==e)&&(r?u(n,"name",{value:e,configurable:!0}):n.name=e),h&&t&&i(t,"arity")&&n.length!==t.arity&&u(n,"length",{value:t.arity});try{t&&i(t,"constructor")&&t.constructor?r&&u(n,"prototype",{writable:!1}):n.prototype&&(n.prototype=void 0)}catch(n){}var o=d(n);return i(o,"source")||(o.source=m.join("string"==typeof e?e:"")),n};Function.prototype.toString=f((function(){return a(this)&&p(this).source||c(this)}),"toString")},function(n,e,t){var o=t(7),a=t(8),i=Function.prototype,r=o&&Object.getOwnPropertyDescriptor,s=a(i,"name"),c=s&&"something"===function(){}.name,l=s&&(!o||o&&r(i,"name").configurable);n.exports={EXISTS:s,PROPER:c,CONFIGURABLE:l}},function(n,e,t){var o,a,i,r=t(109),s=t(1),c=t(2),l=t(9),d=t(16),p=t(8),u=t(30),h=t(110),m=t(61),f=s.TypeError,g=s.WeakMap;if(r||u.state){var y=u.state||(u.state=new g),v=c(y.get),b=c(y.has),w=c(y.set);o=function(n,e){if(b(y,n))throw new f("Object already initialized");return e.facade=n,w(y,n,e),e},a=function(n){return v(y,n)||{}},i=function(n){return b(y,n)}}else{var k=h("state");m[k]=!0,o=function(n,e){if(p(n,k))throw new f("Object already initialized");return e.facade=n,d(n,k,e),e},a=function(n){return p(n,k)?n[k]:{}},i=function(n){return p(n,k)}}n.exports={set:o,get:a,has:i,enforce:function(n){return i(n)?a(n):o(n,{})},getterFor:function(n){return function(e){var t;if(!l(e)||(t=a(e)).type!==n)throw f("Incompatible receiver, "+n+" required");return t}}}},function(n,e,t){var o=t(1),a=t(0),i=t(60),r=o.WeakMap;n.exports=a(r)&&/native code/.test(i(r))},function(n,e,t){var o=t(55),a=t(58),i=o("keys");n.exports=function(n){return i[n]||(i[n]=a(n))}},function(n,e,t){var o=t(15),a=t(2),i=t(112),r=t(119),s=t(32),c=a([].concat);n.exports=o("Reflect","ownKeys")||function(n){var e=i.f(s(n)),t=r.f;return t?c(e,t(n)):e}},function(n,e,t){var o=t(113),a=t(118).concat("length","prototype");e.f=Object.getOwnPropertyNames||function(n){return o(n,a)}},function(n,e,t){var o=t(2),a=t(8),i=t(27),r=t(114).indexOf,s=t(61),c=o([].push);n.exports=function(n,e){var t,o=i(n),l=0,d=[];for(t in o)!a(s,t)&&a(o,t)&&c(d,t);for(;e.length>l;)a(o,t=e[l++])&&(~r(d,t)||c(d,t));return d}},function(n,e,t){var o=t(27),a=t(115),i=t(64),r=function(n){return function(e,t,r){var s,c=o(e),l=i(c),d=a(r,l);if(n&&t!=t){for(;l>d;)if((s=c[d++])!=s)return!0}else for(;l>d;d++)if((n||d in c)&&c[d]===t)return n||d||0;return!n&&-1}};n.exports={includes:r(!0),indexOf:r(!1)}},function(n,e,t){var o=t(63),a=Math.max,i=Math.min;n.exports=function(n,e){var t=o(n);return t<0?a(t+e,0):i(t,e)}},function(n,e){var t=Math.ceil,o=Math.floor;n.exports=Math.trunc||function(n){var e=+n;return(e>0?o:t)(e)}},function(n,e,t){var o=t(63),a=Math.min;n.exports=function(n){return n>0?a(o(n),9007199254740991):0}},function(n,e){n.exports=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"]},function(n,e){e.f=Object.getOwnPropertySymbols},function(n,e,t){var o=t(3),a=t(0),i=/#|\.prototype\./,r=function(n,e){var t=c[s(n)];return t==d||t!=l&&(a(e)?o(e):!!e)},s=r.normalize=function(n){return String(n).replace(i,".").toLowerCase()},c=r.data={},l=r.NATIVE="N",d=r.POLYFILL="P";n.exports=r},function(n,e,t){var o=t(54),a=t(57),i=t(46),r=t(64),s=TypeError,c=function(n){return function(e,t,c,l){o(t);var d=a(e),p=i(d),u=r(d),h=n?u-1:0,m=n?-1:1;if(c<2)for(;;){if(h in p){l=p[h],h+=m;break}if(h+=m,n?h<0:u<=h)throw s("Reduce of empty array with no initial value")}for(;n?h>=0:u>h;h+=m)h in p&&(l=t(l,p[h],h,d));return l}};n.exports={left:c(!1),right:c(!0)}},function(n,e,t){"use strict";var o=t(3);n.exports=function(n,e){var t=[][n];return!!t&&o((function(){t.call(null,e||function(){return 1},1)}))}},function(n,e,t){var o=t(28),a=t(1);n.exports="process"==o(a.process)},function(n,e,t){var o=t(44),a=t(1),i=t(125),r=t(126),s=a.WebAssembly,c=7!==Error("e",{cause:7}).cause,l=function(n,e){var t={};t[n]=r(n,e,c),o({global:!0,constructor:!0,arity:1,forced:c},t)},d=function(n,e){if(s&&s[n]){var t={};t[n]=r("WebAssembly."+n,e,c),o({target:"WebAssembly",stat:!0,constructor:!0,arity:1,forced:c},t)}};l("Error",(function(n){return function(e){return i(n,this,arguments)}})),l("EvalError",(function(n){return function(e){return i(n,this,arguments)}})),l("RangeError",(function(n){return function(e){return i(n,this,arguments)}})),l("ReferenceError",(function(n){return function(e){return i(n,this,arguments)}})),l("SyntaxError",(function(n){return function(e){return i(n,this,arguments)}})),l("TypeError",(function(n){return function(e){return i(n,this,arguments)}})),l("URIError",(function(n){return function(e){return i(n,this,arguments)}})),d("CompileError",(function(n){return function(e){return i(n,this,arguments)}})),d("LinkError",(function(n){return function(e){return i(n,this,arguments)}})),d("RuntimeError",(function(n){return function(e){return i(n,this,arguments)}}))},function(n,e,t){var o=t(25),a=Function.prototype,i=a.apply,r=a.call;n.exports="object"==typeof Reflect&&Reflect.apply||(o?r.bind(i):function(){return r.apply(i,arguments)})},function(n,e,t){"use strict";var o=t(15),a=t(8),i=t(16),r=t(50),s=t(65),c=t(62),l=t(128),d=t(129),p=t(130),u=t(134),h=t(135),m=t(136),f=t(7),g=t(56);n.exports=function(n,e,t,y){var v=y?2:1,b=n.split("."),w=b[b.length-1],k=o.apply(null,b);if(k){var x=k.prototype;if(!g&&a(x,"cause")&&delete x.cause,!t)return k;var T=o("Error"),_=e((function(n,e){var t=p(y?e:n,void 0),o=y?new k(n):new k;return void 0!==t&&i(o,"message",t),m&&i(o,"stack",h(o.stack,2)),this&&r(x,this)&&d(o,this,_),arguments.length>v&&u(o,arguments[v]),o}));if(_.prototype=x,"Error"!==w?s?s(_,T):c(_,T,{name:!0}):f&&"stackTraceLimit"in k&&(l(_,k,"stackTraceLimit"),l(_,k,"prepareStackTrace")),c(_,k),!g)try{x.name!==w&&i(x,"name",w),x.constructor=_}catch(n){}return _}}},function(n,e,t){var o=t(0),a=String,i=TypeError;n.exports=function(n){if("object"==typeof n||o(n))return n;throw i("Can't set "+a(n)+" as a prototype")}},function(n,e,t){var o=t(17).f;n.exports=function(n,e,t){t in n||o(n,t,{configurable:!0,get:function(){return e[t]},set:function(n){e[t]=n}})}},function(n,e,t){var o=t(0),a=t(9),i=t(65);n.exports=function(n,e,t){var r,s;return i&&o(r=e.constructor)&&r!==t&&a(s=r.prototype)&&s!==t.prototype&&i(n,s),n}},function(n,e,t){var o=t(131);n.exports=function(n,e){return void 0===n?arguments.length<2?"":e:o(n)}},function(n,e,t){var o=t(132),a=String;n.exports=function(n){if("Symbol"===o(n))throw TypeError("Cannot convert a Symbol value to a string");return a(n)}},function(n,e,t){var o=t(133),a=t(0),i=t(28),r=t(29)("toStringTag"),s=Object,c="Arguments"==i(function(){return arguments}());n.exports=o?i:function(n){var e,t,o;return void 0===n?"Undefined":null===n?"Null":"string"==typeof(t=function(n,e){try{return n[e]}catch(n){}}(e=s(n),r))?t:c?i(e):"Object"==(o=i(e))&&a(e.callee)?"Arguments":o}},function(n,e,t){var o={};o[t(29)("toStringTag")]="z",n.exports="[object z]"===String(o)},function(n,e,t){var o=t(9),a=t(16);n.exports=function(n,e){o(e)&&"cause"in e&&a(n,"cause",e.cause)}},function(n,e,t){var o=t(2),a=Error,i=o("".replace),r=String(a("zxcasd").stack),s=/\n\s*at [^:]*:[^\n]*/,c=s.test(r);n.exports=function(n,e){if(c&&"string"==typeof n&&!a.prepareStackTrace)for(;e--;)n=i(n,s,"");return n}},function(n,e,t){var o=t(3),a=t(26);n.exports=!o((function(){var n=Error("a");return!("stack"in n)||(Object.defineProperty(n,"stack",a(1,7)),7!==n.stack)}))},function(n,e,t){var o=t(66),a=t(138);n.exports=function n(e,t,i,r,s){var c=-1,l=e.length;for(i||(i=a),s||(s=[]);++c<l;){var d=e[c];t>0&&i(d)?t>1?n(d,t-1,i,r,s):o(s,d):r||(s[s.length]=d)}return s}},function(n,e,t){var o=t(14),a=t(33),i=t(4),r=o?o.isConcatSpreadable:void 0;n.exports=function(n){return i(n)||a(n)||!!(r&&n&&n[r])}},function(n,e,t){var o=t(13),a=t(12);n.exports=function(n){return a(n)&&"[object Arguments]"==o(n)}},function(n,e,t){var o=t(14),a=Object.prototype,i=a.hasOwnProperty,r=a.toString,s=o?o.toStringTag:void 0;n.exports=function(n){var e=i.call(n,s),t=n[s];try{n[s]=void 0;var o=!0}catch(n){}var a=r.call(n);return o&&(e?n[s]=t:delete n[s]),a}},function(n,e){var t=Object.prototype.toString;n.exports=function(n){return t.call(n)}},function(n,e,t){var o=t(143),a=t(199),i=t(41),r=t(4),s=t(210);n.exports=function(n){return"function"==typeof n?n:null==n?i:"object"==typeof n?r(n)?a(n[0],n[1]):o(n):s(n)}},function(n,e,t){var o=t(144),a=t(198),i=t(83);n.exports=function(n){var e=a(n);return 1==e.length&&e[0][2]?i(e[0][0],e[0][1]):function(t){return t===n||o(t,n,e)}}},function(n,e,t){var o=t(68),a=t(72);n.exports=function(n,e,t,i){var r=t.length,s=r,c=!i;if(null==n)return!s;for(n=Object(n);r--;){var l=t[r];if(c&&l[2]?l[1]!==n[l[0]]:!(l[0]in n))return!1}for(;++r<s;){var d=(l=t[r])[0],p=n[d],u=l[1];if(c&&l[2]){if(void 0===p&&!(d in n))return!1}else{var h=new o;if(i)var m=i(p,u,d,n,e,h);if(!(void 0===m?a(u,p,3,i,h):m))return!1}}return!0}},function(n,e){n.exports=function(){this.__data__=[],this.size=0}},function(n,e,t){var o=t(19),a=Array.prototype.splice;n.exports=function(n){var e=this.__data__,t=o(e,n);return!(t<0)&&(t==e.length-1?e.pop():a.call(e,t,1),--this.size,!0)}},function(n,e,t){var o=t(19);n.exports=function(n){var e=this.__data__,t=o(e,n);return t<0?void 0:e[t][1]}},function(n,e,t){var o=t(19);n.exports=function(n){return o(this.__data__,n)>-1}},function(n,e,t){var o=t(19);n.exports=function(n,e){var t=this.__data__,a=o(t,n);return a<0?(++this.size,t.push([n,e])):t[a][1]=e,this}},function(n,e,t){var o=t(18);n.exports=function(){this.__data__=new o,this.size=0}},function(n,e){n.exports=function(n){var e=this.__data__,t=e.delete(n);return this.size=e.size,t}},function(n,e){n.exports=function(n){return this.__data__.get(n)}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e,t){var o=t(18),a=t(34),i=t(36);n.exports=function(n,e){var t=this.__data__;if(t instanceof o){var r=t.__data__;if(!a||r.length<199)return r.push([n,e]),this.size=++t.size,this;t=this.__data__=new i(r)}return t.set(n,e),this.size=t.size,this}},function(n,e,t){var o=t(70),a=t(156),i=t(35),r=t(71),s=/^\[object .+?Constructor\]$/,c=Function.prototype,l=Object.prototype,d=c.toString,p=l.hasOwnProperty,u=RegExp("^"+d.call(p).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");n.exports=function(n){return!(!i(n)||a(n))&&(o(n)?u:s).test(r(n))}},function(n,e,t){var o,a=t(157),i=(o=/[^.]+$/.exec(a&&a.keys&&a.keys.IE_PROTO||""))?"Symbol(src)_1."+o:"";n.exports=function(n){return!!i&&i in n}},function(n,e,t){var o=t(5)["__core-js_shared__"];n.exports=o},function(n,e){n.exports=function(n,e){return null==n?void 0:n[e]}},function(n,e,t){var o=t(160),a=t(18),i=t(34);n.exports=function(){this.size=0,this.__data__={hash:new o,map:new(i||a),string:new o}}},function(n,e,t){var o=t(161),a=t(162),i=t(163),r=t(164),s=t(165);function c(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var o=n[e];this.set(o[0],o[1])}}c.prototype.clear=o,c.prototype.delete=a,c.prototype.get=i,c.prototype.has=r,c.prototype.set=s,n.exports=c},function(n,e,t){var o=t(20);n.exports=function(){this.__data__=o?o(null):{},this.size=0}},function(n,e){n.exports=function(n){var e=this.has(n)&&delete this.__data__[n];return this.size-=e?1:0,e}},function(n,e,t){var o=t(20),a=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;if(o){var t=e[n];return"__lodash_hash_undefined__"===t?void 0:t}return a.call(e,n)?e[n]:void 0}},function(n,e,t){var o=t(20),a=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;return o?void 0!==e[n]:a.call(e,n)}},function(n,e,t){var o=t(20);n.exports=function(n,e){var t=this.__data__;return this.size+=this.has(n)?0:1,t[n]=o&&void 0===e?"__lodash_hash_undefined__":e,this}},function(n,e,t){var o=t(21);n.exports=function(n){var e=o(this,n).delete(n);return this.size-=e?1:0,e}},function(n,e){n.exports=function(n){var e=typeof n;return"string"==e||"number"==e||"symbol"==e||"boolean"==e?"__proto__"!==n:null===n}},function(n,e,t){var o=t(21);n.exports=function(n){return o(this,n).get(n)}},function(n,e,t){var o=t(21);n.exports=function(n){return o(this,n).has(n)}},function(n,e,t){var o=t(21);n.exports=function(n,e){var t=o(this,n),a=t.size;return t.set(n,e),this.size+=t.size==a?0:1,this}},function(n,e,t){var o=t(68),a=t(73),i=t(175),r=t(178),s=t(194),c=t(4),l=t(77),d=t(79),p="[object Object]",u=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,h,m,f){var g=c(n),y=c(e),v=g?"[object Array]":s(n),b=y?"[object Array]":s(e),w=(v="[object Arguments]"==v?p:v)==p,k=(b="[object Arguments]"==b?p:b)==p,x=v==b;if(x&&l(n)){if(!l(e))return!1;g=!0,w=!1}if(x&&!w)return f||(f=new o),g||d(n)?a(n,e,t,h,m,f):i(n,e,v,t,h,m,f);if(!(1&t)){var T=w&&u.call(n,"__wrapped__"),_=k&&u.call(e,"__wrapped__");if(T||_){var C=T?n.value():n,E=_?e.value():e;return f||(f=new o),m(C,E,t,h,f)}}return!!x&&(f||(f=new o),r(n,e,t,h,m,f))}},function(n,e){n.exports=function(n){return this.__data__.set(n,"__lodash_hash_undefined__"),this}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e){n.exports=function(n,e){for(var t=-1,o=null==n?0:n.length;++t<o;)if(e(n[t],t,n))return!0;return!1}},function(n,e,t){var o=t(14),a=t(176),i=t(69),r=t(73),s=t(177),c=t(37),l=o?o.prototype:void 0,d=l?l.valueOf:void 0;n.exports=function(n,e,t,o,l,p,u){switch(t){case"[object DataView]":if(n.byteLength!=e.byteLength||n.byteOffset!=e.byteOffset)return!1;n=n.buffer,e=e.buffer;case"[object ArrayBuffer]":return!(n.byteLength!=e.byteLength||!p(new a(n),new a(e)));case"[object Boolean]":case"[object Date]":case"[object Number]":return i(+n,+e);case"[object Error]":return n.name==e.name&&n.message==e.message;case"[object RegExp]":case"[object String]":return n==e+"";case"[object Map]":var h=s;case"[object Set]":var m=1&o;if(h||(h=c),n.size!=e.size&&!m)return!1;var f=u.get(n);if(f)return f==e;o|=2,u.set(n,e);var g=r(h(n),h(e),o,l,p,u);return u.delete(n),g;case"[object Symbol]":if(d)return d.call(n)==d.call(e)}return!1}},function(n,e,t){var o=t(5).Uint8Array;n.exports=o},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n,o){t[++e]=[o,n]})),t}},function(n,e,t){var o=t(179),a=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,i,r,s){var c=1&t,l=o(n),d=l.length;if(d!=o(e).length&&!c)return!1;for(var p=d;p--;){var u=l[p];if(!(c?u in e:a.call(e,u)))return!1}var h=s.get(n),m=s.get(e);if(h&&m)return h==e&&m==n;var f=!0;s.set(n,e),s.set(e,n);for(var g=c;++p<d;){var y=n[u=l[p]],v=e[u];if(i)var b=c?i(v,y,u,e,n,s):i(y,v,u,n,e,s);if(!(void 0===b?y===v||r(y,v,t,i,s):b)){f=!1;break}g||(g="constructor"==u)}if(f&&!g){var w=n.constructor,k=e.constructor;w==k||!("constructor"in n)||!("constructor"in e)||"function"==typeof w&&w instanceof w&&"function"==typeof k&&k instanceof k||(f=!1)}return s.delete(n),s.delete(e),f}},function(n,e,t){var o=t(180),a=t(181),i=t(76);n.exports=function(n){return o(n,i,a)}},function(n,e,t){var o=t(66),a=t(4);n.exports=function(n,e,t){var i=e(n);return a(n)?i:o(i,t(n))}},function(n,e,t){var o=t(182),a=t(183),i=Object.prototype.propertyIsEnumerable,r=Object.getOwnPropertySymbols,s=r?function(n){return null==n?[]:(n=Object(n),o(r(n),(function(e){return i.call(n,e)})))}:a;n.exports=s},function(n,e){n.exports=function(n,e){for(var t=-1,o=null==n?0:n.length,a=0,i=[];++t<o;){var r=n[t];e(r,t,n)&&(i[a++]=r)}return i}},function(n,e){n.exports=function(){return[]}},function(n,e,t){var o=t(185),a=t(33),i=t(4),r=t(77),s=t(78),c=t(79),l=Object.prototype.hasOwnProperty;n.exports=function(n,e){var t=i(n),d=!t&&a(n),p=!t&&!d&&r(n),u=!t&&!d&&!p&&c(n),h=t||d||p||u,m=h?o(n.length,String):[],f=m.length;for(var g in n)!e&&!l.call(n,g)||h&&("length"==g||p&&("offset"==g||"parent"==g)||u&&("buffer"==g||"byteLength"==g||"byteOffset"==g)||s(g,f))||m.push(g);return m}},function(n,e){n.exports=function(n,e){for(var t=-1,o=Array(n);++t<n;)o[t]=e(t);return o}},function(n,e){n.exports=function(){return!1}},function(n,e,t){var o=t(13),a=t(38),i=t(12),r={};r["[object Float32Array]"]=r["[object Float64Array]"]=r["[object Int8Array]"]=r["[object Int16Array]"]=r["[object Int32Array]"]=r["[object Uint8Array]"]=r["[object Uint8ClampedArray]"]=r["[object Uint16Array]"]=r["[object Uint32Array]"]=!0,r["[object Arguments]"]=r["[object Array]"]=r["[object ArrayBuffer]"]=r["[object Boolean]"]=r["[object DataView]"]=r["[object Date]"]=r["[object Error]"]=r["[object Function]"]=r["[object Map]"]=r["[object Number]"]=r["[object Object]"]=r["[object RegExp]"]=r["[object Set]"]=r["[object String]"]=r["[object WeakMap]"]=!1,n.exports=function(n){return i(n)&&a(n.length)&&!!r[o(n)]}},function(n,e){n.exports=function(n){return function(e){return n(e)}}},function(n,e,t){(function(n){var o=t(67),a=e&&!e.nodeType&&e,i=a&&"object"==typeof n&&n&&!n.nodeType&&n,r=i&&i.exports===a&&o.process,s=function(){try{var n=i&&i.require&&i.require("util").types;return n||r&&r.binding&&r.binding("util")}catch(n){}}();n.exports=s}).call(this,t(42)(n))},function(n,e,t){var o=t(191),a=t(192),i=Object.prototype.hasOwnProperty;n.exports=function(n){if(!o(n))return a(n);var e=[];for(var t in Object(n))i.call(n,t)&&"constructor"!=t&&e.push(t);return e}},function(n,e){var t=Object.prototype;n.exports=function(n){var e=n&&n.constructor;return n===("function"==typeof e&&e.prototype||t)}},function(n,e,t){var o=t(193)(Object.keys,Object);n.exports=o},function(n,e){n.exports=function(n,e){return function(t){return n(e(t))}}},function(n,e,t){var o=t(195),a=t(34),i=t(196),r=t(81),s=t(197),c=t(13),l=t(71),d=l(o),p=l(a),u=l(i),h=l(r),m=l(s),f=c;(o&&"[object DataView]"!=f(new o(new ArrayBuffer(1)))||a&&"[object Map]"!=f(new a)||i&&"[object Promise]"!=f(i.resolve())||r&&"[object Set]"!=f(new r)||s&&"[object WeakMap]"!=f(new s))&&(f=function(n){var e=c(n),t="[object Object]"==e?n.constructor:void 0,o=t?l(t):"";if(o)switch(o){case d:return"[object DataView]";case p:return"[object Map]";case u:return"[object Promise]";case h:return"[object Set]";case m:return"[object WeakMap]"}return e}),n.exports=f},function(n,e,t){var o=t(10)(t(5),"DataView");n.exports=o},function(n,e,t){var o=t(10)(t(5),"Promise");n.exports=o},function(n,e,t){var o=t(10)(t(5),"WeakMap");n.exports=o},function(n,e,t){var o=t(82),a=t(76);n.exports=function(n){for(var e=a(n),t=e.length;t--;){var i=e[t],r=n[i];e[t]=[i,r,o(r)]}return e}},function(n,e,t){var o=t(72),a=t(200),i=t(207),r=t(39),s=t(82),c=t(83),l=t(22);n.exports=function(n,e){return r(n)&&s(e)?c(l(n),e):function(t){var r=a(t,n);return void 0===r&&r===e?i(t,n):o(e,r,3)}}},function(n,e,t){var o=t(84);n.exports=function(n,e,t){var a=null==n?void 0:o(n,e);return void 0===a?t:a}},function(n,e,t){var o=t(202),a=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,i=/\\(\\)?/g,r=o((function(n){var e=[];return 46===n.charCodeAt(0)&&e.push(""),n.replace(a,(function(n,t,o,a){e.push(o?a.replace(i,"$1"):t||n)})),e}));n.exports=r},function(n,e,t){var o=t(203);n.exports=function(n){var e=o(n,(function(n){return 500===t.size&&t.clear(),n})),t=e.cache;return e}},function(n,e,t){var o=t(36);function a(n,e){if("function"!=typeof n||null!=e&&"function"!=typeof e)throw new TypeError("Expected a function");var t=function(){var o=arguments,a=e?e.apply(this,o):o[0],i=t.cache;if(i.has(a))return i.get(a);var r=n.apply(this,o);return t.cache=i.set(a,r)||i,r};return t.cache=new(a.Cache||o),t}a.Cache=o,n.exports=a},function(n,e,t){var o=t(205);n.exports=function(n){return null==n?"":o(n)}},function(n,e,t){var o=t(14),a=t(206),i=t(4),r=t(40),s=o?o.prototype:void 0,c=s?s.toString:void 0;n.exports=function n(e){if("string"==typeof e)return e;if(i(e))return a(e,n)+"";if(r(e))return c?c.call(e):"";var t=e+"";return"0"==t&&1/e==-1/0?"-0":t}},function(n,e){n.exports=function(n,e){for(var t=-1,o=null==n?0:n.length,a=Array(o);++t<o;)a[t]=e(n[t],t,n);return a}},function(n,e,t){var o=t(208),a=t(209);n.exports=function(n,e){return null!=n&&a(n,e,o)}},function(n,e){n.exports=function(n,e){return null!=n&&e in Object(n)}},function(n,e,t){var o=t(85),a=t(33),i=t(4),r=t(78),s=t(38),c=t(22);n.exports=function(n,e,t){for(var l=-1,d=(e=o(e,n)).length,p=!1;++l<d;){var u=c(e[l]);if(!(p=null!=n&&t(n,u)))break;n=n[u]}return p||++l!=d?p:!!(d=null==n?0:n.length)&&s(d)&&r(u,d)&&(i(n)||a(n))}},function(n,e,t){var o=t(211),a=t(212),i=t(39),r=t(22);n.exports=function(n){return i(n)?o(r(n)):a(n)}},function(n,e){n.exports=function(n){return function(e){return null==e?void 0:e[n]}}},function(n,e,t){var o=t(84);n.exports=function(n){return function(e){return o(e,n)}}},function(n,e,t){var o=t(41),a=t(214),i=t(216);n.exports=function(n,e){return i(a(n,e,o),n+"")}},function(n,e,t){var o=t(215),a=Math.max;n.exports=function(n,e,t){return e=a(void 0===e?n.length-1:e,0),function(){for(var i=arguments,r=-1,s=a(i.length-e,0),c=Array(s);++r<s;)c[r]=i[e+r];r=-1;for(var l=Array(e+1);++r<e;)l[r]=i[r];return l[e]=t(c),o(n,this,l)}}},function(n,e){n.exports=function(n,e,t){switch(t.length){case 0:return n.call(e);case 1:return n.call(e,t[0]);case 2:return n.call(e,t[0],t[1]);case 3:return n.call(e,t[0],t[1],t[2])}return n.apply(e,t)}},function(n,e,t){var o=t(217),a=t(220)(o);n.exports=a},function(n,e,t){var o=t(218),a=t(219),i=t(41),r=a?function(n,e){return a(n,"toString",{configurable:!0,enumerable:!1,value:o(e),writable:!0})}:i;n.exports=r},function(n,e){n.exports=function(n){return function(){return n}}},function(n,e,t){var o=t(10),a=function(){try{var n=o(Object,"defineProperty");return n({},"",{}),n}catch(n){}}();n.exports=a},function(n,e){var t=Date.now;n.exports=function(n){var e=0,o=0;return function(){var a=t(),i=16-(a-o);if(o=a,i>0){if(++e>=800)return arguments[0]}else e=0;return n.apply(void 0,arguments)}}},function(n,e,t){var o=t(74),a=t(222),i=t(227),r=t(75),s=t(228),c=t(37);n.exports=function(n,e,t){var l=-1,d=a,p=n.length,u=!0,h=[],m=h;if(t)u=!1,d=i;else if(p>=200){var f=e?null:s(n);if(f)return c(f);u=!1,d=r,m=new o}else m=e?[]:h;n:for(;++l<p;){var g=n[l],y=e?e(g):g;if(g=t||0!==g?g:0,u&&y==y){for(var v=m.length;v--;)if(m[v]===y)continue n;e&&m.push(y),h.push(g)}else d(m,y,t)||(m!==h&&m.push(y),h.push(g))}return h}},function(n,e,t){var o=t(223);n.exports=function(n,e){return!!(null==n?0:n.length)&&o(n,e,0)>-1}},function(n,e,t){var o=t(224),a=t(225),i=t(226);n.exports=function(n,e,t){return e==e?i(n,e,t):o(n,a,t)}},function(n,e){n.exports=function(n,e,t,o){for(var a=n.length,i=t+(o?1:-1);o?i--:++i<a;)if(e(n[i],i,n))return i;return-1}},function(n,e){n.exports=function(n){return n!=n}},function(n,e){n.exports=function(n,e,t){for(var o=t-1,a=n.length;++o<a;)if(n[o]===e)return o;return-1}},function(n,e){n.exports=function(n,e,t){for(var o=-1,a=null==n?0:n.length;++o<a;)if(t(e,n[o]))return!0;return!1}},function(n,e,t){var o=t(81),a=t(229),i=t(37),r=o&&1/i(new o([,-0]))[1]==1/0?function(n){return new o(n)}:a;n.exports=r},function(n,e){n.exports=function(){}},function(n,e,t){var o=t(80),a=t(12);n.exports=function(n){return a(n)&&o(n)}},function(n,e,t){},function(n,e,t){},function(n,e,t){"use strict";t(86)},function(n,e,t){"use strict";t(87)},function(n,e,t){},function(n,e,t){},function(n,e,t){"use strict";t(88)},function(n,e,t){"use strict";t(89)},function(n,e,t){"use strict";t.r(e);
/*!
 * Vue.js v2.7.8
 * (c) 2014-2022 Evan You
 * Released under the MIT License.
 */
var o=Object.freeze({}),a=Array.isArray;function i(n){return null==n}function r(n){return null!=n}function s(n){return!0===n}function c(n){return"string"==typeof n||"number"==typeof n||"symbol"==typeof n||"boolean"==typeof n}function l(n){return"function"==typeof n}function d(n){return null!==n&&"object"==typeof n}var p=Object.prototype.toString;function u(n){return"[object Object]"===p.call(n)}function h(n){return"[object RegExp]"===p.call(n)}function m(n){var e=parseFloat(String(n));return e>=0&&Math.floor(e)===e&&isFinite(n)}function f(n){return r(n)&&"function"==typeof n.then&&"function"==typeof n.catch}function g(n){return null==n?"":Array.isArray(n)||u(n)&&n.toString===p?JSON.stringify(n,null,2):String(n)}function y(n){var e=parseFloat(n);return isNaN(e)?n:e}function v(n,e){for(var t=Object.create(null),o=n.split(","),a=0;a<o.length;a++)t[o[a]]=!0;return e?function(n){return t[n.toLowerCase()]}:function(n){return t[n]}}v("slot,component",!0);var b=v("key,ref,slot,slot-scope,is");function w(n,e){if(n.length){var t=n.indexOf(e);if(t>-1)return n.splice(t,1)}}var k=Object.prototype.hasOwnProperty;function x(n,e){return k.call(n,e)}function T(n){var e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}var _=/-(\w)/g,C=T((function(n){return n.replace(_,(function(n,e){return e?e.toUpperCase():""}))})),E=T((function(n){return n.charAt(0).toUpperCase()+n.slice(1)})),S=/\B([A-Z])/g,A=T((function(n){return n.replace(S,"-$1").toLowerCase()}));var I=Function.prototype.bind?function(n,e){return n.bind(e)}:function(n,e){function t(t){var o=arguments.length;return o?o>1?n.apply(e,arguments):n.call(e,t):n.call(e)}return t._length=n.length,t};function j(n,e){e=e||0;for(var t=n.length-e,o=new Array(t);t--;)o[t]=n[t+e];return o}function P(n,e){for(var t in e)n[t]=e[t];return n}function z(n){for(var e={},t=0;t<n.length;t++)n[t]&&P(e,n[t]);return e}function M(n,e,t){}var O=function(n,e,t){return!1},$=function(n){return n};function B(n,e){if(n===e)return!0;var t=d(n),o=d(e);if(!t||!o)return!t&&!o&&String(n)===String(e);try{var a=Array.isArray(n),i=Array.isArray(e);if(a&&i)return n.length===e.length&&n.every((function(n,t){return B(n,e[t])}));if(n instanceof Date&&e instanceof Date)return n.getTime()===e.getTime();if(a||i)return!1;var r=Object.keys(n),s=Object.keys(e);return r.length===s.length&&r.every((function(t){return B(n[t],e[t])}))}catch(n){return!1}}function L(n,e){for(var t=0;t<n.length;t++)if(B(n[t],e))return t;return-1}function U(n){var e=!1;return function(){e||(e=!0,n.apply(this,arguments))}}function D(n,e){return n===e?0===n&&1/n!=1/e:n==n||e==e}var W=["component","directive","filter"],R=["beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","destroyed","activated","deactivated","errorCaptured","serverPrefetch","renderTracked","renderTriggered"],N={optionMergeStrategies:Object.create(null),silent:!1,productionTip:!1,devtools:!1,performance:!1,errorHandler:null,warnHandler:null,ignoredElements:[],keyCodes:Object.create(null),isReservedTag:O,isReservedAttr:O,isUnknownElement:O,getTagNamespace:M,parsePlatformTagName:$,mustUseProp:O,async:!0,_lifecycleHooks:R},G=/a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;function H(n){var e=(n+"").charCodeAt(0);return 36===e||95===e}function F(n,e,t,o){Object.defineProperty(n,e,{value:t,enumerable:!!o,writable:!0,configurable:!0})}var q=new RegExp("[^".concat(G.source,".$_\\d]"));var V="__proto__"in{},X="undefined"!=typeof window,K=X&&window.navigator.userAgent.toLowerCase(),Z=K&&/msie|trident/.test(K),J=K&&K.indexOf("msie 9.0")>0,Y=K&&K.indexOf("edge/")>0;K&&K.indexOf("android");var Q=K&&/iphone|ipad|ipod|ios/.test(K);K&&/chrome\/\d+/.test(K),K&&/phantomjs/.test(K);var nn,en=K&&K.match(/firefox\/(\d+)/),tn={}.watch,on=!1;if(X)try{var an={};Object.defineProperty(an,"passive",{get:function(){on=!0}}),window.addEventListener("test-passive",null,an)}catch(n){}var rn=function(){return void 0===nn&&(nn=!X&&"undefined"!=typeof global&&(global.process&&"server"===global.process.env.VUE_ENV)),nn},sn=X&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__;function cn(n){return"function"==typeof n&&/native code/.test(n.toString())}var ln,dn="undefined"!=typeof Symbol&&cn(Symbol)&&"undefined"!=typeof Reflect&&cn(Reflect.ownKeys);ln="undefined"!=typeof Set&&cn(Set)?Set:function(){function n(){this.set=Object.create(null)}return n.prototype.has=function(n){return!0===this.set[n]},n.prototype.add=function(n){this.set[n]=!0},n.prototype.clear=function(){this.set=Object.create(null)},n}();var pn=null;function un(n){void 0===n&&(n=null),n||pn&&pn._scope.off(),pn=n,n&&n._scope.on()}var hn=function(){function n(n,e,t,o,a,i,r,s){this.tag=n,this.data=e,this.children=t,this.text=o,this.elm=a,this.ns=void 0,this.context=i,this.fnContext=void 0,this.fnOptions=void 0,this.fnScopeId=void 0,this.key=e&&e.key,this.componentOptions=r,this.componentInstance=void 0,this.parent=void 0,this.raw=!1,this.isStatic=!1,this.isRootInsert=!0,this.isComment=!1,this.isCloned=!1,this.isOnce=!1,this.asyncFactory=s,this.asyncMeta=void 0,this.isAsyncPlaceholder=!1}return Object.defineProperty(n.prototype,"child",{get:function(){return this.componentInstance},enumerable:!1,configurable:!0}),n}(),mn=function(n){void 0===n&&(n="");var e=new hn;return e.text=n,e.isComment=!0,e};function fn(n){return new hn(void 0,void 0,void 0,String(n))}function gn(n){var e=new hn(n.tag,n.data,n.children&&n.children.slice(),n.text,n.elm,n.context,n.componentOptions,n.asyncFactory);return e.ns=n.ns,e.isStatic=n.isStatic,e.key=n.key,e.isComment=n.isComment,e.fnContext=n.fnContext,e.fnOptions=n.fnOptions,e.fnScopeId=n.fnScopeId,e.asyncMeta=n.asyncMeta,e.isCloned=!0,e}var yn=0,vn=function(){function n(){this.id=yn++,this.subs=[]}return n.prototype.addSub=function(n){this.subs.push(n)},n.prototype.removeSub=function(n){w(this.subs,n)},n.prototype.depend=function(e){n.target&&n.target.addDep(this)},n.prototype.notify=function(n){var e=this.subs.slice();for(var t=0,o=e.length;t<o;t++){e[t].update()}},n}();vn.target=null;var bn=[];function wn(n){bn.push(n),vn.target=n}function kn(){bn.pop(),vn.target=bn[bn.length-1]}var xn=Array.prototype,Tn=Object.create(xn);["push","pop","shift","unshift","splice","sort","reverse"].forEach((function(n){var e=xn[n];F(Tn,n,(function(){for(var t=[],o=0;o<arguments.length;o++)t[o]=arguments[o];var a,i=e.apply(this,t),r=this.__ob__;switch(n){case"push":case"unshift":a=t;break;case"splice":a=t.slice(2)}return a&&r.observeArray(a),r.dep.notify(),i}))}));var _n=Object.getOwnPropertyNames(Tn),Cn={},En=!0;function Sn(n){En=n}var An={notify:M,depend:M,addSub:M,removeSub:M},In=function(){function n(n,e,t){if(void 0===e&&(e=!1),void 0===t&&(t=!1),this.value=n,this.shallow=e,this.mock=t,this.dep=t?An:new vn,this.vmCount=0,F(n,"__ob__",this),a(n)){if(!t)if(V)n.__proto__=Tn;else for(var o=0,i=_n.length;o<i;o++){F(n,s=_n[o],Tn[s])}e||this.observeArray(n)}else{var r=Object.keys(n);for(o=0;o<r.length;o++){var s;Pn(n,s=r[o],Cn,void 0,e,t)}}}return n.prototype.observeArray=function(n){for(var e=0,t=n.length;e<t;e++)jn(n[e],!1,this.mock)},n}();function jn(n,e,t){var o;if(!(!d(n)||Un(n)||n instanceof hn))return x(n,"__ob__")&&n.__ob__ instanceof In?o=n.__ob__:!En||!t&&rn()||!a(n)&&!u(n)||!Object.isExtensible(n)||n.__v_skip||(o=new In(n,e,t)),o}function Pn(n,e,t,o,i,r){var s=new vn,c=Object.getOwnPropertyDescriptor(n,e);if(!c||!1!==c.configurable){var l=c&&c.get,d=c&&c.set;l&&!d||t!==Cn&&2!==arguments.length||(t=n[e]);var p=!i&&jn(t,!1,r);return Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){var e=l?l.call(n):t;return vn.target&&(s.depend(),p&&(p.dep.depend(),a(e)&&On(e))),Un(e)&&!i?e.value:e},set:function(e){var o=l?l.call(n):t;if(D(o,e)){if(d)d.call(n,e);else{if(l)return;if(!i&&Un(o)&&!Un(e))return void(o.value=e);t=e}p=!i&&jn(e,!1,r),s.notify()}}}),s}}function zn(n,e,t){if(!Ln(n)){var o=n.__ob__;return a(n)&&m(e)?(n.length=Math.max(n.length,e),n.splice(e,1,t),o&&!o.shallow&&o.mock&&jn(t,!1,!0),t):e in n&&!(e in Object.prototype)?(n[e]=t,t):n._isVue||o&&o.vmCount?t:o?(Pn(o.value,e,t,void 0,o.shallow,o.mock),o.dep.notify(),t):(n[e]=t,t)}}function Mn(n,e){if(a(n)&&m(e))n.splice(e,1);else{var t=n.__ob__;n._isVue||t&&t.vmCount||Ln(n)||x(n,e)&&(delete n[e],t&&t.dep.notify())}}function On(n){for(var e=void 0,t=0,o=n.length;t<o;t++)(e=n[t])&&e.__ob__&&e.__ob__.dep.depend(),a(e)&&On(e)}function $n(n){return Bn(n,!0),F(n,"__v_isShallow",!0),n}function Bn(n,e){if(!Ln(n)){jn(n,e,rn());0}}function Ln(n){return!(!n||!n.__v_isReadonly)}function Un(n){return!(!n||!0!==n.__v_isRef)}function Dn(n,e,t){Object.defineProperty(n,t,{enumerable:!0,configurable:!0,get:function(){var n=e[t];if(Un(n))return n.value;var o=n&&n.__ob__;return o&&o.dep.depend(),n},set:function(n){var o=e[t];Un(o)&&!Un(n)?o.value=n:e[t]=n}})}"".concat("watcher"," callback"),"".concat("watcher"," getter"),"".concat("watcher"," cleanup");var Wn;var Rn=function(){function n(n){void 0===n&&(n=!1),this.active=!0,this.effects=[],this.cleanups=[],!n&&Wn&&(this.parent=Wn,this.index=(Wn.scopes||(Wn.scopes=[])).push(this)-1)}return n.prototype.run=function(n){if(this.active){var e=Wn;try{return Wn=this,n()}finally{Wn=e}}else 0},n.prototype.on=function(){Wn=this},n.prototype.off=function(){Wn=this.parent},n.prototype.stop=function(n){if(this.active){var e=void 0,t=void 0;for(e=0,t=this.effects.length;e<t;e++)this.effects[e].teardown();for(e=0,t=this.cleanups.length;e<t;e++)this.cleanups[e]();if(this.scopes)for(e=0,t=this.scopes.length;e<t;e++)this.scopes[e].stop(!0);if(this.parent&&!n){var o=this.parent.scopes.pop();o&&o!==this&&(this.parent.scopes[this.index]=o,o.index=this.index)}this.active=!1}},n}();function Nn(n){var e=n._provided,t=n.$parent&&n.$parent._provided;return t===e?n._provided=Object.create(t):e}var Gn=T((function(n){var e="&"===n.charAt(0),t="~"===(n=e?n.slice(1):n).charAt(0),o="!"===(n=t?n.slice(1):n).charAt(0);return{name:n=o?n.slice(1):n,once:t,capture:o,passive:e}}));function Hn(n,e){function t(){var n=t.fns;if(!a(n))return Ee(n,null,arguments,e,"v-on handler");for(var o=n.slice(),i=0;i<o.length;i++)Ee(o[i],null,arguments,e,"v-on handler")}return t.fns=n,t}function Fn(n,e,t,o,a,r){var c,l,d,p;for(c in n)l=n[c],d=e[c],p=Gn(c),i(l)||(i(d)?(i(l.fns)&&(l=n[c]=Hn(l,r)),s(p.once)&&(l=n[c]=a(p.name,l,p.capture)),t(p.name,l,p.capture,p.passive,p.params)):l!==d&&(d.fns=l,n[c]=d));for(c in e)i(n[c])&&o((p=Gn(c)).name,e[c],p.capture)}function qn(n,e,t){var o;n instanceof hn&&(n=n.data.hook||(n.data.hook={}));var a=n[e];function c(){t.apply(this,arguments),w(o.fns,c)}i(a)?o=Hn([c]):r(a.fns)&&s(a.merged)?(o=a).fns.push(c):o=Hn([a,c]),o.merged=!0,n[e]=o}function Vn(n,e,t,o,a){if(r(e)){if(x(e,t))return n[t]=e[t],a||delete e[t],!0;if(x(e,o))return n[t]=e[o],a||delete e[o],!0}return!1}function Xn(n){return c(n)?[fn(n)]:a(n)?function n(e,t){var o,l,d,p,u=[];for(o=0;o<e.length;o++)i(l=e[o])||"boolean"==typeof l||(d=u.length-1,p=u[d],a(l)?l.length>0&&(Kn((l=n(l,"".concat(t||"","_").concat(o)))[0])&&Kn(p)&&(u[d]=fn(p.text+l[0].text),l.shift()),u.push.apply(u,l)):c(l)?Kn(p)?u[d]=fn(p.text+l):""!==l&&u.push(fn(l)):Kn(l)&&Kn(p)?u[d]=fn(p.text+l.text):(s(e._isVList)&&r(l.tag)&&i(l.key)&&r(t)&&(l.key="__vlist".concat(t,"_").concat(o,"__")),u.push(l)));return u}(n):void 0}function Kn(n){return r(n)&&r(n.text)&&!1===n.isComment}function Zn(n,e){var t,o,i,s,c=null;if(a(n)||"string"==typeof n)for(c=new Array(n.length),t=0,o=n.length;t<o;t++)c[t]=e(n[t],t);else if("number"==typeof n)for(c=new Array(n),t=0;t<n;t++)c[t]=e(t+1,t);else if(d(n))if(dn&&n[Symbol.iterator]){c=[];for(var l=n[Symbol.iterator](),p=l.next();!p.done;)c.push(e(p.value,c.length)),p=l.next()}else for(i=Object.keys(n),c=new Array(i.length),t=0,o=i.length;t<o;t++)s=i[t],c[t]=e(n[s],s,t);return r(c)||(c=[]),c._isVList=!0,c}function Jn(n,e,t,o){var a,i=this.$scopedSlots[n];i?(t=t||{},o&&(t=P(P({},o),t)),a=i(t)||(l(e)?e():e)):a=this.$slots[n]||(l(e)?e():e);var r=t&&t.slot;return r?this.$createElement("template",{slot:r},a):a}function Yn(n){return It(this.$options,"filters",n,!0)||$}function Qn(n,e){return a(n)?-1===n.indexOf(e):n!==e}function ne(n,e,t,o,a){var i=N.keyCodes[e]||t;return a&&o&&!N.keyCodes[e]?Qn(a,o):i?Qn(i,n):o?A(o)!==e:void 0===n}function ee(n,e,t,o,i){if(t)if(d(t)){a(t)&&(t=z(t));var r=void 0,s=function(a){if("class"===a||"style"===a||b(a))r=n;else{var s=n.attrs&&n.attrs.type;r=o||N.mustUseProp(e,s,a)?n.domProps||(n.domProps={}):n.attrs||(n.attrs={})}var c=C(a),l=A(a);c in r||l in r||(r[a]=t[a],i&&((n.on||(n.on={}))["update:".concat(a)]=function(n){t[a]=n}))};for(var c in t)s(c)}else;return n}function te(n,e){var t=this._staticTrees||(this._staticTrees=[]),o=t[n];return o&&!e||ae(o=t[n]=this.$options.staticRenderFns[n].call(this._renderProxy,this._c,this),"__static__".concat(n),!1),o}function oe(n,e,t){return ae(n,"__once__".concat(e).concat(t?"_".concat(t):""),!0),n}function ae(n,e,t){if(a(n))for(var o=0;o<n.length;o++)n[o]&&"string"!=typeof n[o]&&ie(n[o],"".concat(e,"_").concat(o),t);else ie(n,e,t)}function ie(n,e,t){n.isStatic=!0,n.key=e,n.isOnce=t}function re(n,e){if(e)if(u(e)){var t=n.on=n.on?P({},n.on):{};for(var o in e){var a=t[o],i=e[o];t[o]=a?[].concat(a,i):i}}else;return n}function se(n,e,t,o){e=e||{$stable:!t};for(var i=0;i<n.length;i++){var r=n[i];a(r)?se(r,e,t):r&&(r.proxy&&(r.fn.proxy=!0),e[r.key]=r.fn)}return o&&(e.$key=o),e}function ce(n,e){for(var t=0;t<e.length;t+=2){var o=e[t];"string"==typeof o&&o&&(n[e[t]]=e[t+1])}return n}function le(n,e){return"string"==typeof n?e+n:n}function de(n){n._o=oe,n._n=y,n._s=g,n._l=Zn,n._t=Jn,n._q=B,n._i=L,n._m=te,n._f=Yn,n._k=ne,n._b=ee,n._v=fn,n._e=mn,n._u=se,n._g=re,n._d=ce,n._p=le}function pe(n,e){if(!n||!n.length)return{};for(var t={},o=0,a=n.length;o<a;o++){var i=n[o],r=i.data;if(r&&r.attrs&&r.attrs.slot&&delete r.attrs.slot,i.context!==e&&i.fnContext!==e||!r||null==r.slot)(t.default||(t.default=[])).push(i);else{var s=r.slot,c=t[s]||(t[s]=[]);"template"===i.tag?c.push.apply(c,i.children||[]):c.push(i)}}for(var l in t)t[l].every(ue)&&delete t[l];return t}function ue(n){return n.isComment&&!n.asyncFactory||" "===n.text}function he(n){return n.isComment&&n.asyncFactory}function me(n,e,t,a){var i,r=Object.keys(t).length>0,s=e?!!e.$stable:!r,c=e&&e.$key;if(e){if(e._normalized)return e._normalized;if(s&&a&&a!==o&&c===a.$key&&!r&&!a.$hasNormal)return a;for(var l in i={},e)e[l]&&"$"!==l[0]&&(i[l]=fe(n,t,l,e[l]))}else i={};for(var d in t)d in i||(i[d]=ge(t,d));return e&&Object.isExtensible(e)&&(e._normalized=i),F(i,"$stable",s),F(i,"$key",c),F(i,"$hasNormal",r),i}function fe(n,e,t,o){var i=function(){var e=pn;un(n);var t=arguments.length?o.apply(null,arguments):o({}),i=(t=t&&"object"==typeof t&&!a(t)?[t]:Xn(t))&&t[0];return un(e),t&&(!i||1===t.length&&i.isComment&&!he(i))?void 0:t};return o.proxy&&Object.defineProperty(e,t,{get:i,enumerable:!0,configurable:!0}),i}function ge(n,e){return function(){return n[e]}}function ye(n){return{get attrs(){if(!n._attrsProxy){var e=n._attrsProxy={};F(e,"_v_attr_proxy",!0),ve(e,n.$attrs,o,n,"$attrs")}return n._attrsProxy},get listeners(){n._listenersProxy||ve(n._listenersProxy={},n.$listeners,o,n,"$listeners");return n._listenersProxy},get slots(){return function(n){n._slotsProxy||we(n._slotsProxy={},n.$scopedSlots);return n._slotsProxy}(n)},emit:I(n.$emit,n),expose:function(e){e&&Object.keys(e).forEach((function(t){return Dn(n,e,t)}))}}}function ve(n,e,t,o,a){var i=!1;for(var r in e)r in n?e[r]!==t[r]&&(i=!0):(i=!0,be(n,r,o,a));for(var r in n)r in e||(i=!0,delete n[r]);return i}function be(n,e,t,o){Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){return t[o][e]}})}function we(n,e){for(var t in e)n[t]=e[t];for(var t in n)t in e||delete n[t]}var ke=null;function xe(n,e){return(n.__esModule||dn&&"Module"===n[Symbol.toStringTag])&&(n=n.default),d(n)?e.extend(n):n}function Te(n){if(a(n))for(var e=0;e<n.length;e++){var t=n[e];if(r(t)&&(r(t.componentOptions)||he(t)))return t}}function _e(n,e,t,o,p,u){return(a(t)||c(t))&&(p=o,o=t,t=void 0),s(u)&&(p=2),function(n,e,t,o,c){if(r(t)&&r(t.__ob__))return mn();r(t)&&r(t.is)&&(e=t.is);if(!e)return mn();0;a(o)&&l(o[0])&&((t=t||{}).scopedSlots={default:o[0]},o.length=0);2===c?o=Xn(o):1===c&&(o=function(n){for(var e=0;e<n.length;e++)if(a(n[e]))return Array.prototype.concat.apply([],n);return n}(o));var p,u;if("string"==typeof e){var h=void 0;u=n.$vnode&&n.$vnode.ns||N.getTagNamespace(e),p=N.isReservedTag(e)?new hn(N.parsePlatformTagName(e),t,o,void 0,void 0,n):t&&t.pre||!r(h=It(n.$options,"components",e))?new hn(e,t,o,void 0,void 0,n):bt(h,t,n,o,e)}else p=bt(e,t,n,o);return a(p)?p:r(p)?(r(u)&&function n(e,t,o){e.ns=t,"foreignObject"===e.tag&&(t=void 0,o=!0);if(r(e.children))for(var a=0,c=e.children.length;a<c;a++){var l=e.children[a];r(l.tag)&&(i(l.ns)||s(o)&&"svg"!==l.tag)&&n(l,t,o)}}(p,u),r(t)&&function(n){d(n.style)&&Re(n.style);d(n.class)&&Re(n.class)}(t),p):mn()}(n,e,t,o,p)}function Ce(n,e,t){wn();try{if(e)for(var o=e;o=o.$parent;){var a=o.$options.errorCaptured;if(a)for(var i=0;i<a.length;i++)try{if(!1===a[i].call(o,n,e,t))return}catch(n){Se(n,o,"errorCaptured hook")}}Se(n,e,t)}finally{kn()}}function Ee(n,e,t,o,a){var i;try{(i=t?n.apply(e,t):n.call(e))&&!i._isVue&&f(i)&&!i._handled&&(i.catch((function(n){return Ce(n,o,a+" (Promise/async)")})),i._handled=!0)}catch(n){Ce(n,o,a)}return i}function Se(n,e,t){if(N.errorHandler)try{return N.errorHandler.call(null,n,e,t)}catch(e){e!==n&&Ae(e,null,"config.errorHandler")}Ae(n,e,t)}function Ae(n,e,t){if(!X||"undefined"==typeof console)throw n;console.error(n)}var Ie,je=!1,Pe=[],ze=!1;function Me(){ze=!1;var n=Pe.slice(0);Pe.length=0;for(var e=0;e<n.length;e++)n[e]()}if("undefined"!=typeof Promise&&cn(Promise)){var Oe=Promise.resolve();Ie=function(){Oe.then(Me),Q&&setTimeout(M)},je=!0}else if(Z||"undefined"==typeof MutationObserver||!cn(MutationObserver)&&"[object MutationObserverConstructor]"!==MutationObserver.toString())Ie="undefined"!=typeof setImmediate&&cn(setImmediate)?function(){setImmediate(Me)}:function(){setTimeout(Me,0)};else{var $e=1,Be=new MutationObserver(Me),Le=document.createTextNode(String($e));Be.observe(Le,{characterData:!0}),Ie=function(){$e=($e+1)%2,Le.data=String($e)},je=!0}function Ue(n,e){var t;if(Pe.push((function(){if(n)try{n.call(e)}catch(n){Ce(n,e,"nextTick")}else t&&t(e)})),ze||(ze=!0,Ie()),!n&&"undefined"!=typeof Promise)return new Promise((function(n){t=n}))}function De(n){return function(e,t){if(void 0===t&&(t=pn),t)return function(n,e,t){var o=n.$options;o[e]=Ct(o[e],t)}(t,n,e)}}De("beforeMount"),De("mounted"),De("beforeUpdate"),De("updated"),De("beforeDestroy"),De("destroyed"),De("errorCaptured"),De("activated"),De("deactivated"),De("serverPrefetch"),De("renderTracked"),De("renderTriggered");var We=new ln;function Re(n){return function n(e,t){var o,i,r=a(e);if(!r&&!d(e)||Object.isFrozen(e)||e instanceof hn)return;if(e.__ob__){var s=e.__ob__.dep.id;if(t.has(s))return;t.add(s)}if(r)for(o=e.length;o--;)n(e[o],t);else if(Un(e))n(e.value,t);else for(i=Object.keys(e),o=i.length;o--;)n(e[i[o]],t)}(n,We),We.clear(),n}var Ne,Ge=0,He=function(){function n(n,e,t,o,a){var i,r;i=this,void 0===(r=Wn||(n?n._scope:void 0))&&(r=Wn),r&&r.active&&r.effects.push(i),(this.vm=n)&&a&&(n._watcher=this),o?(this.deep=!!o.deep,this.user=!!o.user,this.lazy=!!o.lazy,this.sync=!!o.sync,this.before=o.before):this.deep=this.user=this.lazy=this.sync=!1,this.cb=t,this.id=++Ge,this.active=!0,this.post=!1,this.dirty=this.lazy,this.deps=[],this.newDeps=[],this.depIds=new ln,this.newDepIds=new ln,this.expression="",l(e)?this.getter=e:(this.getter=function(n){if(!q.test(n)){var e=n.split(".");return function(n){for(var t=0;t<e.length;t++){if(!n)return;n=n[e[t]]}return n}}}(e),this.getter||(this.getter=M)),this.value=this.lazy?void 0:this.get()}return n.prototype.get=function(){var n;wn(this);var e=this.vm;try{n=this.getter.call(e,e)}catch(n){if(!this.user)throw n;Ce(n,e,'getter for watcher "'.concat(this.expression,'"'))}finally{this.deep&&Re(n),kn(),this.cleanupDeps()}return n},n.prototype.addDep=function(n){var e=n.id;this.newDepIds.has(e)||(this.newDepIds.add(e),this.newDeps.push(n),this.depIds.has(e)||n.addSub(this))},n.prototype.cleanupDeps=function(){for(var n=this.deps.length;n--;){var e=this.deps[n];this.newDepIds.has(e.id)||e.removeSub(this)}var t=this.depIds;this.depIds=this.newDepIds,this.newDepIds=t,this.newDepIds.clear(),t=this.deps,this.deps=this.newDeps,this.newDeps=t,this.newDeps.length=0},n.prototype.update=function(){this.lazy?this.dirty=!0:this.sync?this.run():pt(this)},n.prototype.run=function(){if(this.active){var n=this.get();if(n!==this.value||d(n)||this.deep){var e=this.value;if(this.value=n,this.user){var t='callback for watcher "'.concat(this.expression,'"');Ee(this.cb,this.vm,[n,e],this.vm,t)}else this.cb.call(this.vm,n,e)}}},n.prototype.evaluate=function(){this.value=this.get(),this.dirty=!1},n.prototype.depend=function(){for(var n=this.deps.length;n--;)this.deps[n].depend()},n.prototype.teardown=function(){if(this.vm&&!this.vm._isBeingDestroyed&&w(this.vm._scope.effects,this),this.active){for(var n=this.deps.length;n--;)this.deps[n].removeSub(this);this.active=!1,this.onStop&&this.onStop()}},n}();function Fe(n,e){Ne.$on(n,e)}function qe(n,e){Ne.$off(n,e)}function Ve(n,e){var t=Ne;return function o(){var a=e.apply(null,arguments);null!==a&&t.$off(n,o)}}function Xe(n,e,t){Ne=n,Fn(e,t||{},Fe,qe,Ve,n),Ne=void 0}var Ke=null;function Ze(n){var e=Ke;return Ke=n,function(){Ke=e}}function Je(n){for(;n&&(n=n.$parent);)if(n._inactive)return!0;return!1}function Ye(n,e){if(e){if(n._directInactive=!1,Je(n))return}else if(n._directInactive)return;if(n._inactive||null===n._inactive){n._inactive=!1;for(var t=0;t<n.$children.length;t++)Ye(n.$children[t]);Qe(n,"activated")}}function Qe(n,e,t,o){void 0===o&&(o=!0),wn();var a=pn;o&&un(n);var i=n.$options[e],r="".concat(e," hook");if(i)for(var s=0,c=i.length;s<c;s++)Ee(i[s],n,t||null,n,r);n._hasHookEvent&&n.$emit("hook:"+e),o&&un(a),kn()}var nt=[],et=[],tt={},ot=!1,at=!1,it=0;var rt=0,st=Date.now;if(X&&!Z){var ct=window.performance;ct&&"function"==typeof ct.now&&st()>document.createEvent("Event").timeStamp&&(st=function(){return ct.now()})}var lt=function(n,e){if(n.post){if(!e.post)return 1}else if(e.post)return-1;return n.id-e.id};function dt(){var n,e;for(rt=st(),at=!0,nt.sort(lt),it=0;it<nt.length;it++)(n=nt[it]).before&&n.before(),e=n.id,tt[e]=null,n.run();var t=et.slice(),o=nt.slice();it=nt.length=et.length=0,tt={},ot=at=!1,function(n){for(var e=0;e<n.length;e++)n[e]._inactive=!0,Ye(n[e],!0)}(t),function(n){var e=n.length;for(;e--;){var t=n[e],o=t.vm;o&&o._watcher===t&&o._isMounted&&!o._isDestroyed&&Qe(o,"updated")}}(o),sn&&N.devtools&&sn.emit("flush")}function pt(n){var e=n.id;if(null==tt[e]&&(n!==vn.target||!n.noRecurse)){if(tt[e]=!0,at){for(var t=nt.length-1;t>it&&nt[t].id>n.id;)t--;nt.splice(t+1,0,n)}else nt.push(n);ot||(ot=!0,Ue(dt))}}function ut(n,e){if(n){for(var t=Object.create(null),o=dn?Reflect.ownKeys(n):Object.keys(n),a=0;a<o.length;a++){var i=o[a];if("__ob__"!==i){var r=n[i].from;if(r in e._provided)t[i]=e._provided[r];else if("default"in n[i]){var s=n[i].default;t[i]=l(s)?s.call(e):s}else 0}}return t}}function ht(n,e,t,i,r){var c,l=this,d=r.options;x(i,"_uid")?(c=Object.create(i))._original=i:(c=i,i=i._original);var p=s(d._compiled),u=!p;this.data=n,this.props=e,this.children=t,this.parent=i,this.listeners=n.on||o,this.injections=ut(d.inject,i),this.slots=function(){return l.$slots||me(i,n.scopedSlots,l.$slots=pe(t,i)),l.$slots},Object.defineProperty(this,"scopedSlots",{enumerable:!0,get:function(){return me(i,n.scopedSlots,this.slots())}}),p&&(this.$options=d,this.$slots=this.slots(),this.$scopedSlots=me(i,n.scopedSlots,this.$slots)),d._scopeId?this._c=function(n,e,t,o){var r=_e(c,n,e,t,o,u);return r&&!a(r)&&(r.fnScopeId=d._scopeId,r.fnContext=i),r}:this._c=function(n,e,t,o){return _e(c,n,e,t,o,u)}}function mt(n,e,t,o,a){var i=gn(n);return i.fnContext=t,i.fnOptions=o,e.slot&&((i.data||(i.data={})).slot=e.slot),i}function ft(n,e){for(var t in e)n[C(t)]=e[t]}function gt(n){return n.name||n.__name||n._componentTag}de(ht.prototype);var yt={init:function(n,e){if(n.componentInstance&&!n.componentInstance._isDestroyed&&n.data.keepAlive){var t=n;yt.prepatch(t,t)}else{(n.componentInstance=function(n,e){var t={_isComponent:!0,_parentVnode:n,parent:e},o=n.data.inlineTemplate;r(o)&&(t.render=o.render,t.staticRenderFns=o.staticRenderFns);return new n.componentOptions.Ctor(t)}(n,Ke)).$mount(e?n.elm:void 0,e)}},prepatch:function(n,e){var t=e.componentOptions;!function(n,e,t,a,i){var r=a.data.scopedSlots,s=n.$scopedSlots,c=!!(r&&!r.$stable||s!==o&&!s.$stable||r&&n.$scopedSlots.$key!==r.$key||!r&&n.$scopedSlots.$key),l=!!(i||n.$options._renderChildren||c),d=n.$vnode;n.$options._parentVnode=a,n.$vnode=a,n._vnode&&(n._vnode.parent=a),n.$options._renderChildren=i;var p=a.data.attrs||o;n._attrsProxy&&ve(n._attrsProxy,p,d.data&&d.data.attrs||o,n,"$attrs")&&(l=!0),n.$attrs=p,t=t||o;var u=n.$options._parentListeners;if(n._listenersProxy&&ve(n._listenersProxy,t,u||o,n,"$listeners"),n.$listeners=n.$options._parentListeners=t,Xe(n,t,u),e&&n.$options.props){Sn(!1);for(var h=n._props,m=n.$options._propKeys||[],f=0;f<m.length;f++){var g=m[f],y=n.$options.props;h[g]=jt(g,y,e,n)}Sn(!0),n.$options.propsData=e}l&&(n.$slots=pe(i,a.context),n.$forceUpdate())}(e.componentInstance=n.componentInstance,t.propsData,t.listeners,e,t.children)},insert:function(n){var e,t=n.context,o=n.componentInstance;o._isMounted||(o._isMounted=!0,Qe(o,"mounted")),n.data.keepAlive&&(t._isMounted?((e=o)._inactive=!1,et.push(e)):Ye(o,!0))},destroy:function(n){var e=n.componentInstance;e._isDestroyed||(n.data.keepAlive?function n(e,t){if(!(t&&(e._directInactive=!0,Je(e))||e._inactive)){e._inactive=!0;for(var o=0;o<e.$children.length;o++)n(e.$children[o]);Qe(e,"deactivated")}}(e,!0):e.$destroy())}},vt=Object.keys(yt);function bt(n,e,t,c,l){if(!i(n)){var p=t.$options._base;if(d(n)&&(n=p.extend(n)),"function"==typeof n){var u;if(i(n.cid)&&void 0===(n=function(n,e){if(s(n.error)&&r(n.errorComp))return n.errorComp;if(r(n.resolved))return n.resolved;var t=ke;if(t&&r(n.owners)&&-1===n.owners.indexOf(t)&&n.owners.push(t),s(n.loading)&&r(n.loadingComp))return n.loadingComp;if(t&&!r(n.owners)){var o=n.owners=[t],a=!0,c=null,l=null;t.$on("hook:destroyed",(function(){return w(o,t)}));var p=function(n){for(var e=0,t=o.length;e<t;e++)o[e].$forceUpdate();n&&(o.length=0,null!==c&&(clearTimeout(c),c=null),null!==l&&(clearTimeout(l),l=null))},u=U((function(t){n.resolved=xe(t,e),a?o.length=0:p(!0)})),h=U((function(e){r(n.errorComp)&&(n.error=!0,p(!0))})),m=n(u,h);return d(m)&&(f(m)?i(n.resolved)&&m.then(u,h):f(m.component)&&(m.component.then(u,h),r(m.error)&&(n.errorComp=xe(m.error,e)),r(m.loading)&&(n.loadingComp=xe(m.loading,e),0===m.delay?n.loading=!0:c=setTimeout((function(){c=null,i(n.resolved)&&i(n.error)&&(n.loading=!0,p(!1))}),m.delay||200)),r(m.timeout)&&(l=setTimeout((function(){l=null,i(n.resolved)&&h(null)}),m.timeout)))),a=!1,n.loading?n.loadingComp:n.resolved}}(u=n,p)))return function(n,e,t,o,a){var i=mn();return i.asyncFactory=n,i.asyncMeta={data:e,context:t,children:o,tag:a},i}(u,e,t,c,l);e=e||{},Ht(n),r(e.model)&&function(n,e){var t=n.model&&n.model.prop||"value",o=n.model&&n.model.event||"input";(e.attrs||(e.attrs={}))[t]=e.model.value;var i=e.on||(e.on={}),s=i[o],c=e.model.callback;r(s)?(a(s)?-1===s.indexOf(c):s!==c)&&(i[o]=[c].concat(s)):i[o]=c}(n.options,e);var h=function(n,e,t){var o=e.options.props;if(!i(o)){var a={},s=n.attrs,c=n.props;if(r(s)||r(c))for(var l in o){var d=A(l);Vn(a,c,l,d,!0)||Vn(a,s,l,d,!1)}return a}}(e,n);if(s(n.options.functional))return function(n,e,t,i,s){var c=n.options,l={},d=c.props;if(r(d))for(var p in d)l[p]=jt(p,d,e||o);else r(t.attrs)&&ft(l,t.attrs),r(t.props)&&ft(l,t.props);var u=new ht(t,l,s,i,n),h=c.render.call(null,u._c,u);if(h instanceof hn)return mt(h,t,u.parent,c,u);if(a(h)){for(var m=Xn(h)||[],f=new Array(m.length),g=0;g<m.length;g++)f[g]=mt(m[g],t,u.parent,c,u);return f}}(n,h,e,t,c);var m=e.on;if(e.on=e.nativeOn,s(n.options.abstract)){var g=e.slot;e={},g&&(e.slot=g)}!function(n){for(var e=n.hook||(n.hook={}),t=0;t<vt.length;t++){var o=vt[t],a=e[o],i=yt[o];a===i||a&&a._merged||(e[o]=a?wt(i,a):i)}}(e);var y=gt(n.options)||l;return new hn("vue-component-".concat(n.cid).concat(y?"-".concat(y):""),e,void 0,void 0,void 0,t,{Ctor:n,propsData:h,listeners:m,tag:l,children:c},u)}}}function wt(n,e){var t=function(t,o){n(t,o),e(t,o)};return t._merged=!0,t}var kt=M,xt=N.optionMergeStrategies;function Tt(n,e){if(!e)return n;for(var t,o,a,i=dn?Reflect.ownKeys(e):Object.keys(e),r=0;r<i.length;r++)"__ob__"!==(t=i[r])&&(o=n[t],a=e[t],x(n,t)?o!==a&&u(o)&&u(a)&&Tt(o,a):zn(n,t,a));return n}function _t(n,e,t){return t?function(){var o=l(e)?e.call(t,t):e,a=l(n)?n.call(t,t):n;return o?Tt(o,a):a}:e?n?function(){return Tt(l(e)?e.call(this,this):e,l(n)?n.call(this,this):n)}:e:n}function Ct(n,e){var t=e?n?n.concat(e):a(e)?e:[e]:n;return t?function(n){for(var e=[],t=0;t<n.length;t++)-1===e.indexOf(n[t])&&e.push(n[t]);return e}(t):t}function Et(n,e,t,o){var a=Object.create(n||null);return e?P(a,e):a}xt.data=function(n,e,t){return t?_t(n,e,t):e&&"function"!=typeof e?n:_t(n,e)},R.forEach((function(n){xt[n]=Ct})),W.forEach((function(n){xt[n+"s"]=Et})),xt.watch=function(n,e,t,o){if(n===tn&&(n=void 0),e===tn&&(e=void 0),!e)return Object.create(n||null);if(!n)return e;var i={};for(var r in P(i,n),e){var s=i[r],c=e[r];s&&!a(s)&&(s=[s]),i[r]=s?s.concat(c):a(c)?c:[c]}return i},xt.props=xt.methods=xt.inject=xt.computed=function(n,e,t,o){if(!n)return e;var a=Object.create(null);return P(a,n),e&&P(a,e),a},xt.provide=_t;var St=function(n,e){return void 0===e?n:e};function At(n,e,t){if(l(e)&&(e=e.options),function(n,e){var t=n.props;if(t){var o,i,r={};if(a(t))for(o=t.length;o--;)"string"==typeof(i=t[o])&&(r[C(i)]={type:null});else if(u(t))for(var s in t)i=t[s],r[C(s)]=u(i)?i:{type:i};else 0;n.props=r}}(e),function(n,e){var t=n.inject;if(t){var o=n.inject={};if(a(t))for(var i=0;i<t.length;i++)o[t[i]]={from:t[i]};else if(u(t))for(var r in t){var s=t[r];o[r]=u(s)?P({from:r},s):{from:s}}else 0}}(e),function(n){var e=n.directives;if(e)for(var t in e){var o=e[t];l(o)&&(e[t]={bind:o,update:o})}}(e),!e._base&&(e.extends&&(n=At(n,e.extends,t)),e.mixins))for(var o=0,i=e.mixins.length;o<i;o++)n=At(n,e.mixins[o],t);var r,s={};for(r in n)c(r);for(r in e)x(n,r)||c(r);function c(o){var a=xt[o]||St;s[o]=a(n[o],e[o],t,o)}return s}function It(n,e,t,o){if("string"==typeof t){var a=n[e];if(x(a,t))return a[t];var i=C(t);if(x(a,i))return a[i];var r=E(i);return x(a,r)?a[r]:a[t]||a[i]||a[r]}}function jt(n,e,t,o){var a=e[n],i=!x(t,n),r=t[n],s=Ot(Boolean,a.type);if(s>-1)if(i&&!x(a,"default"))r=!1;else if(""===r||r===A(n)){var c=Ot(String,a.type);(c<0||s<c)&&(r=!0)}if(void 0===r){r=function(n,e,t){if(!x(e,"default"))return;var o=e.default;0;if(n&&n.$options.propsData&&void 0===n.$options.propsData[t]&&void 0!==n._props[t])return n._props[t];return l(o)&&"Function"!==zt(e.type)?o.call(n):o}(o,a,n);var d=En;Sn(!0),jn(r),Sn(d)}return r}var Pt=/^\s*function (\w+)/;function zt(n){var e=n&&n.toString().match(Pt);return e?e[1]:""}function Mt(n,e){return zt(n)===zt(e)}function Ot(n,e){if(!a(e))return Mt(e,n)?0:-1;for(var t=0,o=e.length;t<o;t++)if(Mt(e[t],n))return t;return-1}var $t={enumerable:!0,configurable:!0,get:M,set:M};function Bt(n,e,t){$t.get=function(){return this[e][t]},$t.set=function(n){this[e][t]=n},Object.defineProperty(n,t,$t)}function Lt(n){var e=n.$options;if(e.props&&function(n,e){var t=n.$options.propsData||{},o=n._props=$n({}),a=n.$options._propKeys=[];n.$parent&&Sn(!1);var i=function(i){a.push(i);var r=jt(i,e,t,n);Pn(o,i,r),i in n||Bt(n,"_props",i)};for(var r in e)i(r);Sn(!0)}(n,e.props),function(n){var e=n.$options,t=e.setup;if(t){var o=n._setupContext=ye(n);un(n),wn();var a=Ee(t,null,[n._props||$n({}),o],n,"setup");if(kn(),un(),l(a))e.render=a;else if(d(a))if(n._setupState=a,a.__sfc){var i=n._setupProxy={};for(var r in a)"__sfc"!==r&&Dn(i,a,r)}else for(var r in a)H(r)||Dn(n,a,r);else 0}}(n),e.methods&&function(n,e){n.$options.props;for(var t in e)n[t]="function"!=typeof e[t]?M:I(e[t],n)}(n,e.methods),e.data)!function(n){var e=n.$options.data;u(e=n._data=l(e)?function(n,e){wn();try{return n.call(e,e)}catch(n){return Ce(n,e,"data()"),{}}finally{kn()}}(e,n):e||{})||(e={});var t=Object.keys(e),o=n.$options.props,a=(n.$options.methods,t.length);for(;a--;){var i=t[a];0,o&&x(o,i)||H(i)||Bt(n,"_data",i)}var r=jn(e);r&&r.vmCount++}(n);else{var t=jn(n._data={});t&&t.vmCount++}e.computed&&function(n,e){var t=n._computedWatchers=Object.create(null),o=rn();for(var a in e){var i=e[a],r=l(i)?i:i.get;0,o||(t[a]=new He(n,r||M,M,Ut)),a in n||Dt(n,a,i)}}(n,e.computed),e.watch&&e.watch!==tn&&function(n,e){for(var t in e){var o=e[t];if(a(o))for(var i=0;i<o.length;i++)Nt(n,t,o[i]);else Nt(n,t,o)}}(n,e.watch)}var Ut={lazy:!0};function Dt(n,e,t){var o=!rn();l(t)?($t.get=o?Wt(e):Rt(t),$t.set=M):($t.get=t.get?o&&!1!==t.cache?Wt(e):Rt(t.get):M,$t.set=t.set||M),Object.defineProperty(n,e,$t)}function Wt(n){return function(){var e=this._computedWatchers&&this._computedWatchers[n];if(e)return e.dirty&&e.evaluate(),vn.target&&e.depend(),e.value}}function Rt(n){return function(){return n.call(this,this)}}function Nt(n,e,t,o){return u(t)&&(o=t,t=t.handler),"string"==typeof t&&(t=n[t]),n.$watch(e,t,o)}var Gt=0;function Ht(n){var e=n.options;if(n.super){var t=Ht(n.super);if(t!==n.superOptions){n.superOptions=t;var o=function(n){var e,t=n.options,o=n.sealedOptions;for(var a in t)t[a]!==o[a]&&(e||(e={}),e[a]=t[a]);return e}(n);o&&P(n.extendOptions,o),(e=n.options=At(t,n.extendOptions)).name&&(e.components[e.name]=n)}}return e}function Ft(n){this._init(n)}function qt(n){n.cid=0;var e=1;n.extend=function(n){n=n||{};var t=this,o=t.cid,a=n._Ctor||(n._Ctor={});if(a[o])return a[o];var i=gt(n)||gt(t.options);var r=function(n){this._init(n)};return(r.prototype=Object.create(t.prototype)).constructor=r,r.cid=e++,r.options=At(t.options,n),r.super=t,r.options.props&&function(n){var e=n.options.props;for(var t in e)Bt(n.prototype,"_props",t)}(r),r.options.computed&&function(n){var e=n.options.computed;for(var t in e)Dt(n.prototype,t,e[t])}(r),r.extend=t.extend,r.mixin=t.mixin,r.use=t.use,W.forEach((function(n){r[n]=t[n]})),i&&(r.options.components[i]=r),r.superOptions=t.options,r.extendOptions=n,r.sealedOptions=P({},r.options),a[o]=r,r}}function Vt(n){return n&&(gt(n.Ctor.options)||n.tag)}function Xt(n,e){return a(n)?n.indexOf(e)>-1:"string"==typeof n?n.split(",").indexOf(e)>-1:!!h(n)&&n.test(e)}function Kt(n,e){var t=n.cache,o=n.keys,a=n._vnode;for(var i in t){var r=t[i];if(r){var s=r.name;s&&!e(s)&&Zt(t,i,o,a)}}}function Zt(n,e,t,o){var a=n[e];!a||o&&a.tag===o.tag||a.componentInstance.$destroy(),n[e]=null,w(t,e)}!function(n){n.prototype._init=function(n){var e=this;e._uid=Gt++,e._isVue=!0,e.__v_skip=!0,e._scope=new Rn(!0),n&&n._isComponent?function(n,e){var t=n.$options=Object.create(n.constructor.options),o=e._parentVnode;t.parent=e.parent,t._parentVnode=o;var a=o.componentOptions;t.propsData=a.propsData,t._parentListeners=a.listeners,t._renderChildren=a.children,t._componentTag=a.tag,e.render&&(t.render=e.render,t.staticRenderFns=e.staticRenderFns)}(e,n):e.$options=At(Ht(e.constructor),n||{},e),e._renderProxy=e,e._self=e,function(n){var e=n.$options,t=e.parent;if(t&&!e.abstract){for(;t.$options.abstract&&t.$parent;)t=t.$parent;t.$children.push(n)}n.$parent=t,n.$root=t?t.$root:n,n.$children=[],n.$refs={},n._provided=t?t._provided:Object.create(null),n._watcher=null,n._inactive=null,n._directInactive=!1,n._isMounted=!1,n._isDestroyed=!1,n._isBeingDestroyed=!1}(e),function(n){n._events=Object.create(null),n._hasHookEvent=!1;var e=n.$options._parentListeners;e&&Xe(n,e)}(e),function(n){n._vnode=null,n._staticTrees=null;var e=n.$options,t=n.$vnode=e._parentVnode,a=t&&t.context;n.$slots=pe(e._renderChildren,a),n.$scopedSlots=t?me(n.$parent,t.data.scopedSlots,n.$slots):o,n._c=function(e,t,o,a){return _e(n,e,t,o,a,!1)},n.$createElement=function(e,t,o,a){return _e(n,e,t,o,a,!0)};var i=t&&t.data;Pn(n,"$attrs",i&&i.attrs||o,null,!0),Pn(n,"$listeners",e._parentListeners||o,null,!0)}(e),Qe(e,"beforeCreate",void 0,!1),function(n){var e=ut(n.$options.inject,n);e&&(Sn(!1),Object.keys(e).forEach((function(t){Pn(n,t,e[t])})),Sn(!0))}(e),Lt(e),function(n){var e=n.$options.provide;if(e){var t=l(e)?e.call(n):e;if(!d(t))return;for(var o=Nn(n),a=dn?Reflect.ownKeys(t):Object.keys(t),i=0;i<a.length;i++){var r=a[i];Object.defineProperty(o,r,Object.getOwnPropertyDescriptor(t,r))}}}(e),Qe(e,"created"),e.$options.el&&e.$mount(e.$options.el)}}(Ft),function(n){var e={get:function(){return this._data}},t={get:function(){return this._props}};Object.defineProperty(n.prototype,"$data",e),Object.defineProperty(n.prototype,"$props",t),n.prototype.$set=zn,n.prototype.$delete=Mn,n.prototype.$watch=function(n,e,t){if(u(e))return Nt(this,n,e,t);(t=t||{}).user=!0;var o=new He(this,n,e,t);if(t.immediate){var a='callback for immediate watcher "'.concat(o.expression,'"');wn(),Ee(e,this,[o.value],this,a),kn()}return function(){o.teardown()}}}(Ft),function(n){var e=/^hook:/;n.prototype.$on=function(n,t){var o=this;if(a(n))for(var i=0,r=n.length;i<r;i++)o.$on(n[i],t);else(o._events[n]||(o._events[n]=[])).push(t),e.test(n)&&(o._hasHookEvent=!0);return o},n.prototype.$once=function(n,e){var t=this;function o(){t.$off(n,o),e.apply(t,arguments)}return o.fn=e,t.$on(n,o),t},n.prototype.$off=function(n,e){var t=this;if(!arguments.length)return t._events=Object.create(null),t;if(a(n)){for(var o=0,i=n.length;o<i;o++)t.$off(n[o],e);return t}var r,s=t._events[n];if(!s)return t;if(!e)return t._events[n]=null,t;for(var c=s.length;c--;)if((r=s[c])===e||r.fn===e){s.splice(c,1);break}return t},n.prototype.$emit=function(n){var e=this,t=e._events[n];if(t){t=t.length>1?j(t):t;for(var o=j(arguments,1),a='event handler for "'.concat(n,'"'),i=0,r=t.length;i<r;i++)Ee(t[i],e,o,e,a)}return e}}(Ft),function(n){n.prototype._update=function(n,e){var t=this,o=t.$el,a=t._vnode,i=Ze(t);t._vnode=n,t.$el=a?t.__patch__(a,n):t.__patch__(t.$el,n,e,!1),i(),o&&(o.__vue__=null),t.$el&&(t.$el.__vue__=t),t.$vnode&&t.$parent&&t.$vnode===t.$parent._vnode&&(t.$parent.$el=t.$el)},n.prototype.$forceUpdate=function(){this._watcher&&this._watcher.update()},n.prototype.$destroy=function(){var n=this;if(!n._isBeingDestroyed){Qe(n,"beforeDestroy"),n._isBeingDestroyed=!0;var e=n.$parent;!e||e._isBeingDestroyed||n.$options.abstract||w(e.$children,n),n._scope.stop(),n._data.__ob__&&n._data.__ob__.vmCount--,n._isDestroyed=!0,n.__patch__(n._vnode,null),Qe(n,"destroyed"),n.$off(),n.$el&&(n.$el.__vue__=null),n.$vnode&&(n.$vnode.parent=null)}}}(Ft),function(n){de(n.prototype),n.prototype.$nextTick=function(n){return Ue(n,this)},n.prototype._render=function(){var n,e=this,t=e.$options,o=t.render,i=t._parentVnode;i&&e._isMounted&&(e.$scopedSlots=me(e.$parent,i.data.scopedSlots,e.$slots,e.$scopedSlots),e._slotsProxy&&we(e._slotsProxy,e.$scopedSlots)),e.$vnode=i;try{un(e),ke=e,n=o.call(e._renderProxy,e.$createElement)}catch(t){Ce(t,e,"render"),n=e._vnode}finally{ke=null,un()}return a(n)&&1===n.length&&(n=n[0]),n instanceof hn||(n=mn()),n.parent=i,n}}(Ft);var Jt=[String,RegExp,Array],Yt={KeepAlive:{name:"keep-alive",abstract:!0,props:{include:Jt,exclude:Jt,max:[String,Number]},methods:{cacheVNode:function(){var n=this.cache,e=this.keys,t=this.vnodeToCache,o=this.keyToCache;if(t){var a=t.tag,i=t.componentInstance,r=t.componentOptions;n[o]={name:Vt(r),tag:a,componentInstance:i},e.push(o),this.max&&e.length>parseInt(this.max)&&Zt(n,e[0],e,this._vnode),this.vnodeToCache=null}}},created:function(){this.cache=Object.create(null),this.keys=[]},destroyed:function(){for(var n in this.cache)Zt(this.cache,n,this.keys)},mounted:function(){var n=this;this.cacheVNode(),this.$watch("include",(function(e){Kt(n,(function(n){return Xt(e,n)}))})),this.$watch("exclude",(function(e){Kt(n,(function(n){return!Xt(e,n)}))}))},updated:function(){this.cacheVNode()},render:function(){var n=this.$slots.default,e=Te(n),t=e&&e.componentOptions;if(t){var o=Vt(t),a=this.include,i=this.exclude;if(a&&(!o||!Xt(a,o))||i&&o&&Xt(i,o))return e;var r=this.cache,s=this.keys,c=null==e.key?t.Ctor.cid+(t.tag?"::".concat(t.tag):""):e.key;r[c]?(e.componentInstance=r[c].componentInstance,w(s,c),s.push(c)):(this.vnodeToCache=e,this.keyToCache=c),e.data.keepAlive=!0}return e||n&&n[0]}}};!function(n){var e={get:function(){return N}};Object.defineProperty(n,"config",e),n.util={warn:kt,extend:P,mergeOptions:At,defineReactive:Pn},n.set=zn,n.delete=Mn,n.nextTick=Ue,n.observable=function(n){return jn(n),n},n.options=Object.create(null),W.forEach((function(e){n.options[e+"s"]=Object.create(null)})),n.options._base=n,P(n.options.components,Yt),function(n){n.use=function(n){var e=this._installedPlugins||(this._installedPlugins=[]);if(e.indexOf(n)>-1)return this;var t=j(arguments,1);return t.unshift(this),l(n.install)?n.install.apply(n,t):l(n)&&n.apply(null,t),e.push(n),this}}(n),function(n){n.mixin=function(n){return this.options=At(this.options,n),this}}(n),qt(n),function(n){W.forEach((function(e){n[e]=function(n,t){return t?("component"===e&&u(t)&&(t.name=t.name||n,t=this.options._base.extend(t)),"directive"===e&&l(t)&&(t={bind:t,update:t}),this.options[e+"s"][n]=t,t):this.options[e+"s"][n]}}))}(n)}(Ft),Object.defineProperty(Ft.prototype,"$isServer",{get:rn}),Object.defineProperty(Ft.prototype,"$ssrContext",{get:function(){return this.$vnode&&this.$vnode.ssrContext}}),Object.defineProperty(Ft,"FunctionalRenderContext",{value:ht}),Ft.version="2.7.8";var Qt=v("style,class"),no=v("input,textarea,option,select,progress"),eo=v("contenteditable,draggable,spellcheck"),to=v("events,caret,typing,plaintext-only"),oo=v("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible"),ao="http://www.w3.org/1999/xlink",io=function(n){return":"===n.charAt(5)&&"xlink"===n.slice(0,5)},ro=function(n){return io(n)?n.slice(6,n.length):""},so=function(n){return null==n||!1===n};function co(n){for(var e=n.data,t=n,o=n;r(o.componentInstance);)(o=o.componentInstance._vnode)&&o.data&&(e=lo(o.data,e));for(;r(t=t.parent);)t&&t.data&&(e=lo(e,t.data));return function(n,e){if(r(n)||r(e))return po(n,uo(e));return""}(e.staticClass,e.class)}function lo(n,e){return{staticClass:po(n.staticClass,e.staticClass),class:r(n.class)?[n.class,e.class]:e.class}}function po(n,e){return n?e?n+" "+e:n:e||""}function uo(n){return Array.isArray(n)?function(n){for(var e,t="",o=0,a=n.length;o<a;o++)r(e=uo(n[o]))&&""!==e&&(t&&(t+=" "),t+=e);return t}(n):d(n)?function(n){var e="";for(var t in n)n[t]&&(e&&(e+=" "),e+=t);return e}(n):"string"==typeof n?n:""}var ho={svg:"http://www.w3.org/2000/svg",math:"http://www.w3.org/1998/Math/MathML"},mo=v("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"),fo=v("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",!0),go=function(n){return mo(n)||fo(n)};var yo=Object.create(null);var vo=v("text,number,password,search,email,tel,url");var bo=Object.freeze({__proto__:null,createElement:function(n,e){var t=document.createElement(n);return"select"!==n||e.data&&e.data.attrs&&void 0!==e.data.attrs.multiple&&t.setAttribute("multiple","multiple"),t},createElementNS:function(n,e){return document.createElementNS(ho[n],e)},createTextNode:function(n){return document.createTextNode(n)},createComment:function(n){return document.createComment(n)},insertBefore:function(n,e,t){n.insertBefore(e,t)},removeChild:function(n,e){n.removeChild(e)},appendChild:function(n,e){n.appendChild(e)},parentNode:function(n){return n.parentNode},nextSibling:function(n){return n.nextSibling},tagName:function(n){return n.tagName},setTextContent:function(n,e){n.textContent=e},setStyleScope:function(n,e){n.setAttribute(e,"")}}),wo={create:function(n,e){ko(e)},update:function(n,e){n.data.ref!==e.data.ref&&(ko(n,!0),ko(e))},destroy:function(n){ko(n,!0)}};function ko(n,e){var t=n.data.ref;if(r(t)){var o=n.context,i=n.componentInstance||n.elm,s=e?null:i,c=e?void 0:i;if(l(t))Ee(t,o,[s],o,"template ref function");else{var d=n.data.refInFor,p="string"==typeof t||"number"==typeof t,u=Un(t),h=o.$refs;if(p||u)if(d){var m=p?h[t]:t.value;e?a(m)&&w(m,i):a(m)?m.includes(i)||m.push(i):p?(h[t]=[i],xo(o,t,h[t])):t.value=[i]}else if(p){if(e&&h[t]!==i)return;h[t]=c,xo(o,t,s)}else if(u){if(e&&t.value!==i)return;t.value=s}else 0}}}function xo(n,e,t){var o=n._setupState;o&&x(o,e)&&(Un(o[e])?o[e].value=t:o[e]=t)}var To=new hn("",{},[]),_o=["create","activate","update","remove","destroy"];function Co(n,e){return n.key===e.key&&n.asyncFactory===e.asyncFactory&&(n.tag===e.tag&&n.isComment===e.isComment&&r(n.data)===r(e.data)&&function(n,e){if("input"!==n.tag)return!0;var t,o=r(t=n.data)&&r(t=t.attrs)&&t.type,a=r(t=e.data)&&r(t=t.attrs)&&t.type;return o===a||vo(o)&&vo(a)}(n,e)||s(n.isAsyncPlaceholder)&&i(e.asyncFactory.error))}function Eo(n,e,t){var o,a,i={};for(o=e;o<=t;++o)r(a=n[o].key)&&(i[a]=o);return i}var So={create:Ao,update:Ao,destroy:function(n){Ao(n,To)}};function Ao(n,e){(n.data.directives||e.data.directives)&&function(n,e){var t,o,a,i=n===To,r=e===To,s=jo(n.data.directives,n.context),c=jo(e.data.directives,e.context),l=[],d=[];for(t in c)o=s[t],a=c[t],o?(a.oldValue=o.value,a.oldArg=o.arg,zo(a,"update",e,n),a.def&&a.def.componentUpdated&&d.push(a)):(zo(a,"bind",e,n),a.def&&a.def.inserted&&l.push(a));if(l.length){var p=function(){for(var t=0;t<l.length;t++)zo(l[t],"inserted",e,n)};i?qn(e,"insert",p):p()}d.length&&qn(e,"postpatch",(function(){for(var t=0;t<d.length;t++)zo(d[t],"componentUpdated",e,n)}));if(!i)for(t in s)c[t]||zo(s[t],"unbind",n,n,r)}(n,e)}var Io=Object.create(null);function jo(n,e){var t,o,a=Object.create(null);if(!n)return a;for(t=0;t<n.length;t++)(o=n[t]).modifiers||(o.modifiers=Io),a[Po(o)]=o,e._setupState&&e._setupState.__sfc&&(o.def=o.def||It(e,"_setupState","v-"+o.name)),o.def=o.def||It(e.$options,"directives",o.name);return a}function Po(n){return n.rawName||"".concat(n.name,".").concat(Object.keys(n.modifiers||{}).join("."))}function zo(n,e,t,o,a){var i=n.def&&n.def[e];if(i)try{i(t.elm,n,t,o,a)}catch(o){Ce(o,t.context,"directive ".concat(n.name," ").concat(e," hook"))}}var Mo=[wo,So];function Oo(n,e){var t=e.componentOptions;if(!(r(t)&&!1===t.Ctor.options.inheritAttrs||i(n.data.attrs)&&i(e.data.attrs))){var o,a,c=e.elm,l=n.data.attrs||{},d=e.data.attrs||{};for(o in(r(d.__ob__)||s(d._v_attr_proxy))&&(d=e.data.attrs=P({},d)),d)a=d[o],l[o]!==a&&$o(c,o,a,e.data.pre);for(o in(Z||Y)&&d.value!==l.value&&$o(c,"value",d.value),l)i(d[o])&&(io(o)?c.removeAttributeNS(ao,ro(o)):eo(o)||c.removeAttribute(o))}}function $o(n,e,t,o){o||n.tagName.indexOf("-")>-1?Bo(n,e,t):oo(e)?so(t)?n.removeAttribute(e):(t="allowfullscreen"===e&&"EMBED"===n.tagName?"true":e,n.setAttribute(e,t)):eo(e)?n.setAttribute(e,function(n,e){return so(e)||"false"===e?"false":"contenteditable"===n&&to(e)?e:"true"}(e,t)):io(e)?so(t)?n.removeAttributeNS(ao,ro(e)):n.setAttributeNS(ao,e,t):Bo(n,e,t)}function Bo(n,e,t){if(so(t))n.removeAttribute(e);else{if(Z&&!J&&"TEXTAREA"===n.tagName&&"placeholder"===e&&""!==t&&!n.__ieph){var o=function(e){e.stopImmediatePropagation(),n.removeEventListener("input",o)};n.addEventListener("input",o),n.__ieph=!0}n.setAttribute(e,t)}}var Lo={create:Oo,update:Oo};function Uo(n,e){var t=e.elm,o=e.data,a=n.data;if(!(i(o.staticClass)&&i(o.class)&&(i(a)||i(a.staticClass)&&i(a.class)))){var s=co(e),c=t._transitionClasses;r(c)&&(s=po(s,uo(c))),s!==t._prevClass&&(t.setAttribute("class",s),t._prevClass=s)}}var Do,Wo={create:Uo,update:Uo};function Ro(n,e,t){var o=Do;return function a(){var i=e.apply(null,arguments);null!==i&&Ho(n,a,t,o)}}var No=je&&!(en&&Number(en[1])<=53);function Go(n,e,t,o){if(No){var a=rt,i=e;e=i._wrapper=function(n){if(n.target===n.currentTarget||n.timeStamp>=a||n.timeStamp<=0||n.target.ownerDocument!==document)return i.apply(this,arguments)}}Do.addEventListener(n,e,on?{capture:t,passive:o}:t)}function Ho(n,e,t,o){(o||Do).removeEventListener(n,e._wrapper||e,t)}function Fo(n,e){if(!i(n.data.on)||!i(e.data.on)){var t=e.data.on||{},o=n.data.on||{};Do=e.elm||n.elm,function(n){if(r(n.__r)){var e=Z?"change":"input";n[e]=[].concat(n.__r,n[e]||[]),delete n.__r}r(n.__c)&&(n.change=[].concat(n.__c,n.change||[]),delete n.__c)}(t),Fn(t,o,Go,Ho,Ro,e.context),Do=void 0}}var qo,Vo={create:Fo,update:Fo,destroy:function(n){return Fo(n,To)}};function Xo(n,e){if(!i(n.data.domProps)||!i(e.data.domProps)){var t,o,a=e.elm,c=n.data.domProps||{},l=e.data.domProps||{};for(t in(r(l.__ob__)||s(l._v_attr_proxy))&&(l=e.data.domProps=P({},l)),c)t in l||(a[t]="");for(t in l){if(o=l[t],"textContent"===t||"innerHTML"===t){if(e.children&&(e.children.length=0),o===c[t])continue;1===a.childNodes.length&&a.removeChild(a.childNodes[0])}if("value"===t&&"PROGRESS"!==a.tagName){a._value=o;var d=i(o)?"":String(o);Ko(a,d)&&(a.value=d)}else if("innerHTML"===t&&fo(a.tagName)&&i(a.innerHTML)){(qo=qo||document.createElement("div")).innerHTML="<svg>".concat(o,"</svg>");for(var p=qo.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;p.firstChild;)a.appendChild(p.firstChild)}else if(o!==c[t])try{a[t]=o}catch(n){}}}}function Ko(n,e){return!n.composing&&("OPTION"===n.tagName||function(n,e){var t=!0;try{t=document.activeElement!==n}catch(n){}return t&&n.value!==e}(n,e)||function(n,e){var t=n.value,o=n._vModifiers;if(r(o)){if(o.number)return y(t)!==y(e);if(o.trim)return t.trim()!==e.trim()}return t!==e}(n,e))}var Zo={create:Xo,update:Xo},Jo=T((function(n){var e={},t=/:(.+)/;return n.split(/;(?![^(]*\))/g).forEach((function(n){if(n){var o=n.split(t);o.length>1&&(e[o[0].trim()]=o[1].trim())}})),e}));function Yo(n){var e=Qo(n.style);return n.staticStyle?P(n.staticStyle,e):e}function Qo(n){return Array.isArray(n)?z(n):"string"==typeof n?Jo(n):n}var na,ea=/^--/,ta=/\s*!important$/,oa=function(n,e,t){if(ea.test(e))n.style.setProperty(e,t);else if(ta.test(t))n.style.setProperty(A(e),t.replace(ta,""),"important");else{var o=ia(e);if(Array.isArray(t))for(var a=0,i=t.length;a<i;a++)n.style[o]=t[a];else n.style[o]=t}},aa=["Webkit","Moz","ms"],ia=T((function(n){if(na=na||document.createElement("div").style,"filter"!==(n=C(n))&&n in na)return n;for(var e=n.charAt(0).toUpperCase()+n.slice(1),t=0;t<aa.length;t++){var o=aa[t]+e;if(o in na)return o}}));function ra(n,e){var t=e.data,o=n.data;if(!(i(t.staticStyle)&&i(t.style)&&i(o.staticStyle)&&i(o.style))){var a,s,c=e.elm,l=o.staticStyle,d=o.normalizedStyle||o.style||{},p=l||d,u=Qo(e.data.style)||{};e.data.normalizedStyle=r(u.__ob__)?P({},u):u;var h=function(n,e){var t,o={};if(e)for(var a=n;a.componentInstance;)(a=a.componentInstance._vnode)&&a.data&&(t=Yo(a.data))&&P(o,t);(t=Yo(n.data))&&P(o,t);for(var i=n;i=i.parent;)i.data&&(t=Yo(i.data))&&P(o,t);return o}(e,!0);for(s in p)i(h[s])&&oa(c,s,"");for(s in h)(a=h[s])!==p[s]&&oa(c,s,null==a?"":a)}}var sa={create:ra,update:ra},ca=/\s+/;function la(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(ca).forEach((function(e){return n.classList.add(e)})):n.classList.add(e);else{var t=" ".concat(n.getAttribute("class")||""," ");t.indexOf(" "+e+" ")<0&&n.setAttribute("class",(t+e).trim())}}function da(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(ca).forEach((function(e){return n.classList.remove(e)})):n.classList.remove(e),n.classList.length||n.removeAttribute("class");else{for(var t=" ".concat(n.getAttribute("class")||""," "),o=" "+e+" ";t.indexOf(o)>=0;)t=t.replace(o," ");(t=t.trim())?n.setAttribute("class",t):n.removeAttribute("class")}}function pa(n){if(n){if("object"==typeof n){var e={};return!1!==n.css&&P(e,ua(n.name||"v")),P(e,n),e}return"string"==typeof n?ua(n):void 0}}var ua=T((function(n){return{enterClass:"".concat(n,"-enter"),enterToClass:"".concat(n,"-enter-to"),enterActiveClass:"".concat(n,"-enter-active"),leaveClass:"".concat(n,"-leave"),leaveToClass:"".concat(n,"-leave-to"),leaveActiveClass:"".concat(n,"-leave-active")}})),ha=X&&!J,ma="transition",fa="transitionend",ga="animation",ya="animationend";ha&&(void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend&&(ma="WebkitTransition",fa="webkitTransitionEnd"),void 0===window.onanimationend&&void 0!==window.onwebkitanimationend&&(ga="WebkitAnimation",ya="webkitAnimationEnd"));var va=X?window.requestAnimationFrame?window.requestAnimationFrame.bind(window):setTimeout:function(n){return n()};function ba(n){va((function(){va(n)}))}function wa(n,e){var t=n._transitionClasses||(n._transitionClasses=[]);t.indexOf(e)<0&&(t.push(e),la(n,e))}function ka(n,e){n._transitionClasses&&w(n._transitionClasses,e),da(n,e)}function xa(n,e,t){var o=_a(n,e),a=o.type,i=o.timeout,r=o.propCount;if(!a)return t();var s="transition"===a?fa:ya,c=0,l=function(){n.removeEventListener(s,d),t()},d=function(e){e.target===n&&++c>=r&&l()};setTimeout((function(){c<r&&l()}),i+1),n.addEventListener(s,d)}var Ta=/\b(transform|all)(,|$)/;function _a(n,e){var t,o=window.getComputedStyle(n),a=(o[ma+"Delay"]||"").split(", "),i=(o[ma+"Duration"]||"").split(", "),r=Ca(a,i),s=(o[ga+"Delay"]||"").split(", "),c=(o[ga+"Duration"]||"").split(", "),l=Ca(s,c),d=0,p=0;return"transition"===e?r>0&&(t="transition",d=r,p=i.length):"animation"===e?l>0&&(t="animation",d=l,p=c.length):p=(t=(d=Math.max(r,l))>0?r>l?"transition":"animation":null)?"transition"===t?i.length:c.length:0,{type:t,timeout:d,propCount:p,hasTransform:"transition"===t&&Ta.test(o[ma+"Property"])}}function Ca(n,e){for(;n.length<e.length;)n=n.concat(n);return Math.max.apply(null,e.map((function(e,t){return Ea(e)+Ea(n[t])})))}function Ea(n){return 1e3*Number(n.slice(0,-1).replace(",","."))}function Sa(n,e){var t=n.elm;r(t._leaveCb)&&(t._leaveCb.cancelled=!0,t._leaveCb());var o=pa(n.data.transition);if(!i(o)&&!r(t._enterCb)&&1===t.nodeType){for(var a=o.css,s=o.type,c=o.enterClass,p=o.enterToClass,u=o.enterActiveClass,h=o.appearClass,m=o.appearToClass,f=o.appearActiveClass,g=o.beforeEnter,v=o.enter,b=o.afterEnter,w=o.enterCancelled,k=o.beforeAppear,x=o.appear,T=o.afterAppear,_=o.appearCancelled,C=o.duration,E=Ke,S=Ke.$vnode;S&&S.parent;)E=S.context,S=S.parent;var A=!E._isMounted||!n.isRootInsert;if(!A||x||""===x){var I=A&&h?h:c,j=A&&f?f:u,P=A&&m?m:p,z=A&&k||g,M=A&&l(x)?x:v,O=A&&T||b,$=A&&_||w,B=y(d(C)?C.enter:C);0;var L=!1!==a&&!J,D=ja(M),W=t._enterCb=U((function(){L&&(ka(t,P),ka(t,j)),W.cancelled?(L&&ka(t,I),$&&$(t)):O&&O(t),t._enterCb=null}));n.data.show||qn(n,"insert",(function(){var e=t.parentNode,o=e&&e._pending&&e._pending[n.key];o&&o.tag===n.tag&&o.elm._leaveCb&&o.elm._leaveCb(),M&&M(t,W)})),z&&z(t),L&&(wa(t,I),wa(t,j),ba((function(){ka(t,I),W.cancelled||(wa(t,P),D||(Ia(B)?setTimeout(W,B):xa(t,s,W)))}))),n.data.show&&(e&&e(),M&&M(t,W)),L||D||W()}}}function Aa(n,e){var t=n.elm;r(t._enterCb)&&(t._enterCb.cancelled=!0,t._enterCb());var o=pa(n.data.transition);if(i(o)||1!==t.nodeType)return e();if(!r(t._leaveCb)){var a=o.css,s=o.type,c=o.leaveClass,l=o.leaveToClass,p=o.leaveActiveClass,u=o.beforeLeave,h=o.leave,m=o.afterLeave,f=o.leaveCancelled,g=o.delayLeave,v=o.duration,b=!1!==a&&!J,w=ja(h),k=y(d(v)?v.leave:v);0;var x=t._leaveCb=U((function(){t.parentNode&&t.parentNode._pending&&(t.parentNode._pending[n.key]=null),b&&(ka(t,l),ka(t,p)),x.cancelled?(b&&ka(t,c),f&&f(t)):(e(),m&&m(t)),t._leaveCb=null}));g?g(T):T()}function T(){x.cancelled||(!n.data.show&&t.parentNode&&((t.parentNode._pending||(t.parentNode._pending={}))[n.key]=n),u&&u(t),b&&(wa(t,c),wa(t,p),ba((function(){ka(t,c),x.cancelled||(wa(t,l),w||(Ia(k)?setTimeout(x,k):xa(t,s,x)))}))),h&&h(t,x),b||w||x())}}function Ia(n){return"number"==typeof n&&!isNaN(n)}function ja(n){if(i(n))return!1;var e=n.fns;return r(e)?ja(Array.isArray(e)?e[0]:e):(n._length||n.length)>1}function Pa(n,e){!0!==e.data.show&&Sa(e)}var za=function(n){var e,t,o={},l=n.modules,d=n.nodeOps;for(e=0;e<_o.length;++e)for(o[_o[e]]=[],t=0;t<l.length;++t)r(l[t][_o[e]])&&o[_o[e]].push(l[t][_o[e]]);function p(n){var e=d.parentNode(n);r(e)&&d.removeChild(e,n)}function u(n,e,t,a,i,c,l){if(r(n.elm)&&r(c)&&(n=c[l]=gn(n)),n.isRootInsert=!i,!function(n,e,t,a){var i=n.data;if(r(i)){var c=r(n.componentInstance)&&i.keepAlive;if(r(i=i.hook)&&r(i=i.init)&&i(n,!1),r(n.componentInstance))return h(n,e),m(t,n.elm,a),s(c)&&function(n,e,t,a){var i,s=n;for(;s.componentInstance;)if(s=s.componentInstance._vnode,r(i=s.data)&&r(i=i.transition)){for(i=0;i<o.activate.length;++i)o.activate[i](To,s);e.push(s);break}m(t,n.elm,a)}(n,e,t,a),!0}}(n,e,t,a)){var p=n.data,u=n.children,g=n.tag;r(g)?(n.elm=n.ns?d.createElementNS(n.ns,g):d.createElement(g,n),b(n),f(n,u,e),r(p)&&y(n,e),m(t,n.elm,a)):s(n.isComment)?(n.elm=d.createComment(n.text),m(t,n.elm,a)):(n.elm=d.createTextNode(n.text),m(t,n.elm,a))}}function h(n,e){r(n.data.pendingInsert)&&(e.push.apply(e,n.data.pendingInsert),n.data.pendingInsert=null),n.elm=n.componentInstance.$el,g(n)?(y(n,e),b(n)):(ko(n),e.push(n))}function m(n,e,t){r(n)&&(r(t)?d.parentNode(t)===n&&d.insertBefore(n,e,t):d.appendChild(n,e))}function f(n,e,t){if(a(e)){0;for(var o=0;o<e.length;++o)u(e[o],t,n.elm,null,!0,e,o)}else c(n.text)&&d.appendChild(n.elm,d.createTextNode(String(n.text)))}function g(n){for(;n.componentInstance;)n=n.componentInstance._vnode;return r(n.tag)}function y(n,t){for(var a=0;a<o.create.length;++a)o.create[a](To,n);r(e=n.data.hook)&&(r(e.create)&&e.create(To,n),r(e.insert)&&t.push(n))}function b(n){var e;if(r(e=n.fnScopeId))d.setStyleScope(n.elm,e);else for(var t=n;t;)r(e=t.context)&&r(e=e.$options._scopeId)&&d.setStyleScope(n.elm,e),t=t.parent;r(e=Ke)&&e!==n.context&&e!==n.fnContext&&r(e=e.$options._scopeId)&&d.setStyleScope(n.elm,e)}function w(n,e,t,o,a,i){for(;o<=a;++o)u(t[o],i,n,e,!1,t,o)}function k(n){var e,t,a=n.data;if(r(a))for(r(e=a.hook)&&r(e=e.destroy)&&e(n),e=0;e<o.destroy.length;++e)o.destroy[e](n);if(r(e=n.children))for(t=0;t<n.children.length;++t)k(n.children[t])}function x(n,e,t){for(;e<=t;++e){var o=n[e];r(o)&&(r(o.tag)?(T(o),k(o)):p(o.elm))}}function T(n,e){if(r(e)||r(n.data)){var t,a=o.remove.length+1;for(r(e)?e.listeners+=a:e=function(n,e){function t(){0==--t.listeners&&p(n)}return t.listeners=e,t}(n.elm,a),r(t=n.componentInstance)&&r(t=t._vnode)&&r(t.data)&&T(t,e),t=0;t<o.remove.length;++t)o.remove[t](n,e);r(t=n.data.hook)&&r(t=t.remove)?t(n,e):e()}else p(n.elm)}function _(n,e,t,o){for(var a=t;a<o;a++){var i=e[a];if(r(i)&&Co(n,i))return a}}function C(n,e,t,a,c,l){if(n!==e){r(e.elm)&&r(a)&&(e=a[c]=gn(e));var p=e.elm=n.elm;if(s(n.isAsyncPlaceholder))r(e.asyncFactory.resolved)?A(n.elm,e,t):e.isAsyncPlaceholder=!0;else if(s(e.isStatic)&&s(n.isStatic)&&e.key===n.key&&(s(e.isCloned)||s(e.isOnce)))e.componentInstance=n.componentInstance;else{var h,m=e.data;r(m)&&r(h=m.hook)&&r(h=h.prepatch)&&h(n,e);var f=n.children,y=e.children;if(r(m)&&g(e)){for(h=0;h<o.update.length;++h)o.update[h](n,e);r(h=m.hook)&&r(h=h.update)&&h(n,e)}i(e.text)?r(f)&&r(y)?f!==y&&function(n,e,t,o,a){var s,c,l,p=0,h=0,m=e.length-1,f=e[0],g=e[m],y=t.length-1,v=t[0],b=t[y],k=!a;for(0;p<=m&&h<=y;)i(f)?f=e[++p]:i(g)?g=e[--m]:Co(f,v)?(C(f,v,o,t,h),f=e[++p],v=t[++h]):Co(g,b)?(C(g,b,o,t,y),g=e[--m],b=t[--y]):Co(f,b)?(C(f,b,o,t,y),k&&d.insertBefore(n,f.elm,d.nextSibling(g.elm)),f=e[++p],b=t[--y]):Co(g,v)?(C(g,v,o,t,h),k&&d.insertBefore(n,g.elm,f.elm),g=e[--m],v=t[++h]):(i(s)&&(s=Eo(e,p,m)),i(c=r(v.key)?s[v.key]:_(v,e,p,m))?u(v,o,n,f.elm,!1,t,h):Co(l=e[c],v)?(C(l,v,o,t,h),e[c]=void 0,k&&d.insertBefore(n,l.elm,f.elm)):u(v,o,n,f.elm,!1,t,h),v=t[++h]);p>m?w(n,i(t[y+1])?null:t[y+1].elm,t,h,y,o):h>y&&x(e,p,m)}(p,f,y,t,l):r(y)?(r(n.text)&&d.setTextContent(p,""),w(p,null,y,0,y.length-1,t)):r(f)?x(f,0,f.length-1):r(n.text)&&d.setTextContent(p,""):n.text!==e.text&&d.setTextContent(p,e.text),r(m)&&r(h=m.hook)&&r(h=h.postpatch)&&h(n,e)}}}function E(n,e,t){if(s(t)&&r(n.parent))n.parent.data.pendingInsert=e;else for(var o=0;o<e.length;++o)e[o].data.hook.insert(e[o])}var S=v("attrs,class,staticClass,staticStyle,key");function A(n,e,t,o){var a,i=e.tag,c=e.data,l=e.children;if(o=o||c&&c.pre,e.elm=n,s(e.isComment)&&r(e.asyncFactory))return e.isAsyncPlaceholder=!0,!0;if(r(c)&&(r(a=c.hook)&&r(a=a.init)&&a(e,!0),r(a=e.componentInstance)))return h(e,t),!0;if(r(i)){if(r(l))if(n.hasChildNodes())if(r(a=c)&&r(a=a.domProps)&&r(a=a.innerHTML)){if(a!==n.innerHTML)return!1}else{for(var d=!0,p=n.firstChild,u=0;u<l.length;u++){if(!p||!A(p,l[u],t,o)){d=!1;break}p=p.nextSibling}if(!d||p)return!1}else f(e,l,t);if(r(c)){var m=!1;for(var g in c)if(!S(g)){m=!0,y(e,t);break}!m&&c.class&&Re(c.class)}}else n.data!==e.text&&(n.data=e.text);return!0}return function(n,e,t,a){if(!i(e)){var c,l=!1,p=[];if(i(n))l=!0,u(e,p);else{var h=r(n.nodeType);if(!h&&Co(n,e))C(n,e,p,null,null,a);else{if(h){if(1===n.nodeType&&n.hasAttribute("data-server-rendered")&&(n.removeAttribute("data-server-rendered"),t=!0),s(t)&&A(n,e,p))return E(e,p,!0),n;c=n,n=new hn(d.tagName(c).toLowerCase(),{},[],void 0,c)}var m=n.elm,f=d.parentNode(m);if(u(e,p,m._leaveCb?null:f,d.nextSibling(m)),r(e.parent))for(var y=e.parent,v=g(e);y;){for(var b=0;b<o.destroy.length;++b)o.destroy[b](y);if(y.elm=e.elm,v){for(var w=0;w<o.create.length;++w)o.create[w](To,y);var T=y.data.hook.insert;if(T.merged)for(var _=1;_<T.fns.length;_++)T.fns[_]()}else ko(y);y=y.parent}r(f)?x([n],0,0):r(n.tag)&&k(n)}}return E(e,p,l),e.elm}r(n)&&k(n)}}({nodeOps:bo,modules:[Lo,Wo,Vo,Zo,sa,X?{create:Pa,activate:Pa,remove:function(n,e){!0!==n.data.show?Aa(n,e):e()}}:{}].concat(Mo)});J&&document.addEventListener("selectionchange",(function(){var n=document.activeElement;n&&n.vmodel&&Wa(n,"input")}));var Ma={inserted:function(n,e,t,o){"select"===t.tag?(o.elm&&!o.elm._vOptions?qn(t,"postpatch",(function(){Ma.componentUpdated(n,e,t)})):Oa(n,e,t.context),n._vOptions=[].map.call(n.options,La)):("textarea"===t.tag||vo(n.type))&&(n._vModifiers=e.modifiers,e.modifiers.lazy||(n.addEventListener("compositionstart",Ua),n.addEventListener("compositionend",Da),n.addEventListener("change",Da),J&&(n.vmodel=!0)))},componentUpdated:function(n,e,t){if("select"===t.tag){Oa(n,e,t.context);var o=n._vOptions,a=n._vOptions=[].map.call(n.options,La);if(a.some((function(n,e){return!B(n,o[e])})))(n.multiple?e.value.some((function(n){return Ba(n,a)})):e.value!==e.oldValue&&Ba(e.value,a))&&Wa(n,"change")}}};function Oa(n,e,t){$a(n,e,t),(Z||Y)&&setTimeout((function(){$a(n,e,t)}),0)}function $a(n,e,t){var o=e.value,a=n.multiple;if(!a||Array.isArray(o)){for(var i,r,s=0,c=n.options.length;s<c;s++)if(r=n.options[s],a)i=L(o,La(r))>-1,r.selected!==i&&(r.selected=i);else if(B(La(r),o))return void(n.selectedIndex!==s&&(n.selectedIndex=s));a||(n.selectedIndex=-1)}}function Ba(n,e){return e.every((function(e){return!B(e,n)}))}function La(n){return"_value"in n?n._value:n.value}function Ua(n){n.target.composing=!0}function Da(n){n.target.composing&&(n.target.composing=!1,Wa(n.target,"input"))}function Wa(n,e){var t=document.createEvent("HTMLEvents");t.initEvent(e,!0,!0),n.dispatchEvent(t)}function Ra(n){return!n.componentInstance||n.data&&n.data.transition?n:Ra(n.componentInstance._vnode)}var Na={model:Ma,show:{bind:function(n,e,t){var o=e.value,a=(t=Ra(t)).data&&t.data.transition,i=n.__vOriginalDisplay="none"===n.style.display?"":n.style.display;o&&a?(t.data.show=!0,Sa(t,(function(){n.style.display=i}))):n.style.display=o?i:"none"},update:function(n,e,t){var o=e.value;!o!=!e.oldValue&&((t=Ra(t)).data&&t.data.transition?(t.data.show=!0,o?Sa(t,(function(){n.style.display=n.__vOriginalDisplay})):Aa(t,(function(){n.style.display="none"}))):n.style.display=o?n.__vOriginalDisplay:"none")},unbind:function(n,e,t,o,a){a||(n.style.display=n.__vOriginalDisplay)}}},Ga={name:String,appear:Boolean,css:Boolean,mode:String,type:String,enterClass:String,leaveClass:String,enterToClass:String,leaveToClass:String,enterActiveClass:String,leaveActiveClass:String,appearClass:String,appearActiveClass:String,appearToClass:String,duration:[Number,String,Object]};function Ha(n){var e=n&&n.componentOptions;return e&&e.Ctor.options.abstract?Ha(Te(e.children)):n}function Fa(n){var e={},t=n.$options;for(var o in t.propsData)e[o]=n[o];var a=t._parentListeners;for(var o in a)e[C(o)]=a[o];return e}function qa(n,e){if(/\d-keep-alive$/.test(e.tag))return n("keep-alive",{props:e.componentOptions.propsData})}var Va=function(n){return n.tag||he(n)},Xa=function(n){return"show"===n.name},Ka={name:"transition",props:Ga,abstract:!0,render:function(n){var e=this,t=this.$slots.default;if(t&&(t=t.filter(Va)).length){0;var o=this.mode;0;var a=t[0];if(function(n){for(;n=n.parent;)if(n.data.transition)return!0}(this.$vnode))return a;var i=Ha(a);if(!i)return a;if(this._leaving)return qa(n,a);var r="__transition-".concat(this._uid,"-");i.key=null==i.key?i.isComment?r+"comment":r+i.tag:c(i.key)?0===String(i.key).indexOf(r)?i.key:r+i.key:i.key;var s=(i.data||(i.data={})).transition=Fa(this),l=this._vnode,d=Ha(l);if(i.data.directives&&i.data.directives.some(Xa)&&(i.data.show=!0),d&&d.data&&!function(n,e){return e.key===n.key&&e.tag===n.tag}(i,d)&&!he(d)&&(!d.componentInstance||!d.componentInstance._vnode.isComment)){var p=d.data.transition=P({},s);if("out-in"===o)return this._leaving=!0,qn(p,"afterLeave",(function(){e._leaving=!1,e.$forceUpdate()})),qa(n,a);if("in-out"===o){if(he(i))return l;var u,h=function(){u()};qn(s,"afterEnter",h),qn(s,"enterCancelled",h),qn(p,"delayLeave",(function(n){u=n}))}}return a}}},Za=P({tag:String,moveClass:String},Ga);function Ja(n){n.elm._moveCb&&n.elm._moveCb(),n.elm._enterCb&&n.elm._enterCb()}function Ya(n){n.data.newPos=n.elm.getBoundingClientRect()}function Qa(n){var e=n.data.pos,t=n.data.newPos,o=e.left-t.left,a=e.top-t.top;if(o||a){n.data.moved=!0;var i=n.elm.style;i.transform=i.WebkitTransform="translate(".concat(o,"px,").concat(a,"px)"),i.transitionDuration="0s"}}delete Za.mode;var ni={Transition:Ka,TransitionGroup:{props:Za,beforeMount:function(){var n=this,e=this._update;this._update=function(t,o){var a=Ze(n);n.__patch__(n._vnode,n.kept,!1,!0),n._vnode=n.kept,a(),e.call(n,t,o)}},render:function(n){for(var e=this.tag||this.$vnode.data.tag||"span",t=Object.create(null),o=this.prevChildren=this.children,a=this.$slots.default||[],i=this.children=[],r=Fa(this),s=0;s<a.length;s++){if((d=a[s]).tag)if(null!=d.key&&0!==String(d.key).indexOf("__vlist"))i.push(d),t[d.key]=d,(d.data||(d.data={})).transition=r;else;}if(o){var c=[],l=[];for(s=0;s<o.length;s++){var d;(d=o[s]).data.transition=r,d.data.pos=d.elm.getBoundingClientRect(),t[d.key]?c.push(d):l.push(d)}this.kept=n(e,null,c),this.removed=l}return n(e,null,i)},updated:function(){var n=this.prevChildren,e=this.moveClass||(this.name||"v")+"-move";n.length&&this.hasMove(n[0].elm,e)&&(n.forEach(Ja),n.forEach(Ya),n.forEach(Qa),this._reflow=document.body.offsetHeight,n.forEach((function(n){if(n.data.moved){var t=n.elm,o=t.style;wa(t,e),o.transform=o.WebkitTransform=o.transitionDuration="",t.addEventListener(fa,t._moveCb=function n(o){o&&o.target!==t||o&&!/transform$/.test(o.propertyName)||(t.removeEventListener(fa,n),t._moveCb=null,ka(t,e))})}})))},methods:{hasMove:function(n,e){if(!ha)return!1;if(this._hasMove)return this._hasMove;var t=n.cloneNode();n._transitionClasses&&n._transitionClasses.forEach((function(n){da(t,n)})),la(t,e),t.style.display="none",this.$el.appendChild(t);var o=_a(t);return this.$el.removeChild(t),this._hasMove=o.hasTransform}}}};function ei(n,e){for(var t in e)n[t]=e[t];return n}Ft.config.mustUseProp=function(n,e,t){return"value"===t&&no(n)&&"button"!==e||"selected"===t&&"option"===n||"checked"===t&&"input"===n||"muted"===t&&"video"===n},Ft.config.isReservedTag=go,Ft.config.isReservedAttr=Qt,Ft.config.getTagNamespace=function(n){return fo(n)?"svg":"math"===n?"math":void 0},Ft.config.isUnknownElement=function(n){if(!X)return!0;if(go(n))return!1;if(n=n.toLowerCase(),null!=yo[n])return yo[n];var e=document.createElement(n);return n.indexOf("-")>-1?yo[n]=e.constructor===window.HTMLUnknownElement||e.constructor===window.HTMLElement:yo[n]=/HTMLUnknownElement/.test(e.toString())},P(Ft.options.directives,Na),P(Ft.options.components,ni),Ft.prototype.__patch__=X?za:M,Ft.prototype.$mount=function(n,e){return function(n,e,t){var o;n.$el=e,n.$options.render||(n.$options.render=mn),Qe(n,"beforeMount"),o=function(){n._update(n._render(),t)},new He(n,o,M,{before:function(){n._isMounted&&!n._isDestroyed&&Qe(n,"beforeUpdate")}},!0),t=!1;var a=n._preWatchers;if(a)for(var i=0;i<a.length;i++)a[i].run();return null==n.$vnode&&(n._isMounted=!0,Qe(n,"mounted")),n}(this,n=n&&X?function(n){if("string"==typeof n){var e=document.querySelector(n);return e||document.createElement("div")}return n}(n):void 0,e)},X&&setTimeout((function(){N.devtools&&sn&&sn.emit("init",Ft)}),0);var ti=/[!'()*]/g,oi=function(n){return"%"+n.charCodeAt(0).toString(16)},ai=/%2C/g,ii=function(n){return encodeURIComponent(n).replace(ti,oi).replace(ai,",")};function ri(n){try{return decodeURIComponent(n)}catch(n){0}return n}var si=function(n){return null==n||"object"==typeof n?n:String(n)};function ci(n){var e={};return(n=n.trim().replace(/^(\?|#|&)/,""))?(n.split("&").forEach((function(n){var t=n.replace(/\+/g," ").split("="),o=ri(t.shift()),a=t.length>0?ri(t.join("=")):null;void 0===e[o]?e[o]=a:Array.isArray(e[o])?e[o].push(a):e[o]=[e[o],a]})),e):e}function li(n){var e=n?Object.keys(n).map((function(e){var t=n[e];if(void 0===t)return"";if(null===t)return ii(e);if(Array.isArray(t)){var o=[];return t.forEach((function(n){void 0!==n&&(null===n?o.push(ii(e)):o.push(ii(e)+"="+ii(n)))})),o.join("&")}return ii(e)+"="+ii(t)})).filter((function(n){return n.length>0})).join("&"):null;return e?"?"+e:""}var di=/\/?$/;function pi(n,e,t,o){var a=o&&o.options.stringifyQuery,i=e.query||{};try{i=ui(i)}catch(n){}var r={name:e.name||n&&n.name,meta:n&&n.meta||{},path:e.path||"/",hash:e.hash||"",query:i,params:e.params||{},fullPath:fi(e,a),matched:n?mi(n):[]};return t&&(r.redirectedFrom=fi(t,a)),Object.freeze(r)}function ui(n){if(Array.isArray(n))return n.map(ui);if(n&&"object"==typeof n){var e={};for(var t in n)e[t]=ui(n[t]);return e}return n}var hi=pi(null,{path:"/"});function mi(n){for(var e=[];n;)e.unshift(n),n=n.parent;return e}function fi(n,e){var t=n.path,o=n.query;void 0===o&&(o={});var a=n.hash;return void 0===a&&(a=""),(t||"/")+(e||li)(o)+a}function gi(n,e,t){return e===hi?n===e:!!e&&(n.path&&e.path?n.path.replace(di,"")===e.path.replace(di,"")&&(t||n.hash===e.hash&&yi(n.query,e.query)):!(!n.name||!e.name)&&(n.name===e.name&&(t||n.hash===e.hash&&yi(n.query,e.query)&&yi(n.params,e.params))))}function yi(n,e){if(void 0===n&&(n={}),void 0===e&&(e={}),!n||!e)return n===e;var t=Object.keys(n).sort(),o=Object.keys(e).sort();return t.length===o.length&&t.every((function(t,a){var i=n[t];if(o[a]!==t)return!1;var r=e[t];return null==i||null==r?i===r:"object"==typeof i&&"object"==typeof r?yi(i,r):String(i)===String(r)}))}function vi(n){for(var e=0;e<n.matched.length;e++){var t=n.matched[e];for(var o in t.instances){var a=t.instances[o],i=t.enteredCbs[o];if(a&&i){delete t.enteredCbs[o];for(var r=0;r<i.length;r++)a._isBeingDestroyed||i[r](a)}}}}var bi={name:"RouterView",functional:!0,props:{name:{type:String,default:"default"}},render:function(n,e){var t=e.props,o=e.children,a=e.parent,i=e.data;i.routerView=!0;for(var r=a.$createElement,s=t.name,c=a.$route,l=a._routerViewCache||(a._routerViewCache={}),d=0,p=!1;a&&a._routerRoot!==a;){var u=a.$vnode?a.$vnode.data:{};u.routerView&&d++,u.keepAlive&&a._directInactive&&a._inactive&&(p=!0),a=a.$parent}if(i.routerViewDepth=d,p){var h=l[s],m=h&&h.component;return m?(h.configProps&&wi(m,i,h.route,h.configProps),r(m,i,o)):r()}var f=c.matched[d],g=f&&f.components[s];if(!f||!g)return l[s]=null,r();l[s]={component:g},i.registerRouteInstance=function(n,e){var t=f.instances[s];(e&&t!==n||!e&&t===n)&&(f.instances[s]=e)},(i.hook||(i.hook={})).prepatch=function(n,e){f.instances[s]=e.componentInstance},i.hook.init=function(n){n.data.keepAlive&&n.componentInstance&&n.componentInstance!==f.instances[s]&&(f.instances[s]=n.componentInstance),vi(c)};var y=f.props&&f.props[s];return y&&(ei(l[s],{route:c,configProps:y}),wi(g,i,c,y)),r(g,i,o)}};function wi(n,e,t,o){var a=e.props=function(n,e){switch(typeof e){case"undefined":return;case"object":return e;case"function":return e(n);case"boolean":return e?n.params:void 0;default:0}}(t,o);if(a){a=e.props=ei({},a);var i=e.attrs=e.attrs||{};for(var r in a)n.props&&r in n.props||(i[r]=a[r],delete a[r])}}function ki(n,e,t){var o=n.charAt(0);if("/"===o)return n;if("?"===o||"#"===o)return e+n;var a=e.split("/");t&&a[a.length-1]||a.pop();for(var i=n.replace(/^\//,"").split("/"),r=0;r<i.length;r++){var s=i[r];".."===s?a.pop():"."!==s&&a.push(s)}return""!==a[0]&&a.unshift(""),a.join("/")}function xi(n){return n.replace(/\/(?:\s*\/)+/g,"/")}var Ti=Array.isArray||function(n){return"[object Array]"==Object.prototype.toString.call(n)},_i=Ui,Ci=ji,Ei=function(n,e){return zi(ji(n,e),e)},Si=zi,Ai=Li,Ii=new RegExp(["(\\\\.)","([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"].join("|"),"g");function ji(n,e){for(var t,o=[],a=0,i=0,r="",s=e&&e.delimiter||"/";null!=(t=Ii.exec(n));){var c=t[0],l=t[1],d=t.index;if(r+=n.slice(i,d),i=d+c.length,l)r+=l[1];else{var p=n[i],u=t[2],h=t[3],m=t[4],f=t[5],g=t[6],y=t[7];r&&(o.push(r),r="");var v=null!=u&&null!=p&&p!==u,b="+"===g||"*"===g,w="?"===g||"*"===g,k=t[2]||s,x=m||f;o.push({name:h||a++,prefix:u||"",delimiter:k,optional:w,repeat:b,partial:v,asterisk:!!y,pattern:x?Oi(x):y?".*":"[^"+Mi(k)+"]+?"})}}return i<n.length&&(r+=n.substr(i)),r&&o.push(r),o}function Pi(n){return encodeURI(n).replace(/[\/?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()}))}function zi(n,e){for(var t=new Array(n.length),o=0;o<n.length;o++)"object"==typeof n[o]&&(t[o]=new RegExp("^(?:"+n[o].pattern+")$",Bi(e)));return function(e,o){for(var a="",i=e||{},r=(o||{}).pretty?Pi:encodeURIComponent,s=0;s<n.length;s++){var c=n[s];if("string"!=typeof c){var l,d=i[c.name];if(null==d){if(c.optional){c.partial&&(a+=c.prefix);continue}throw new TypeError('Expected "'+c.name+'" to be defined')}if(Ti(d)){if(!c.repeat)throw new TypeError('Expected "'+c.name+'" to not repeat, but received `'+JSON.stringify(d)+"`");if(0===d.length){if(c.optional)continue;throw new TypeError('Expected "'+c.name+'" to not be empty')}for(var p=0;p<d.length;p++){if(l=r(d[p]),!t[s].test(l))throw new TypeError('Expected all "'+c.name+'" to match "'+c.pattern+'", but received `'+JSON.stringify(l)+"`");a+=(0===p?c.prefix:c.delimiter)+l}}else{if(l=c.asterisk?encodeURI(d).replace(/[?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()})):r(d),!t[s].test(l))throw new TypeError('Expected "'+c.name+'" to match "'+c.pattern+'", but received "'+l+'"');a+=c.prefix+l}}else a+=c}return a}}function Mi(n){return n.replace(/([.+*?=^!:${}()[\]|\/\\])/g,"\\$1")}function Oi(n){return n.replace(/([=!:$\/()])/g,"\\$1")}function $i(n,e){return n.keys=e,n}function Bi(n){return n&&n.sensitive?"":"i"}function Li(n,e,t){Ti(e)||(t=e||t,e=[]);for(var o=(t=t||{}).strict,a=!1!==t.end,i="",r=0;r<n.length;r++){var s=n[r];if("string"==typeof s)i+=Mi(s);else{var c=Mi(s.prefix),l="(?:"+s.pattern+")";e.push(s),s.repeat&&(l+="(?:"+c+l+")*"),i+=l=s.optional?s.partial?c+"("+l+")?":"(?:"+c+"("+l+"))?":c+"("+l+")"}}var d=Mi(t.delimiter||"/"),p=i.slice(-d.length)===d;return o||(i=(p?i.slice(0,-d.length):i)+"(?:"+d+"(?=$))?"),i+=a?"$":o&&p?"":"(?="+d+"|$)",$i(new RegExp("^"+i,Bi(t)),e)}function Ui(n,e,t){return Ti(e)||(t=e||t,e=[]),t=t||{},n instanceof RegExp?function(n,e){var t=n.source.match(/\((?!\?)/g);if(t)for(var o=0;o<t.length;o++)e.push({name:o,prefix:null,delimiter:null,optional:!1,repeat:!1,partial:!1,asterisk:!1,pattern:null});return $i(n,e)}(n,e):Ti(n)?function(n,e,t){for(var o=[],a=0;a<n.length;a++)o.push(Ui(n[a],e,t).source);return $i(new RegExp("(?:"+o.join("|")+")",Bi(t)),e)}(n,e,t):function(n,e,t){return Li(ji(n,t),e,t)}(n,e,t)}_i.parse=Ci,_i.compile=Ei,_i.tokensToFunction=Si,_i.tokensToRegExp=Ai;var Di=Object.create(null);function Wi(n,e,t){e=e||{};try{var o=Di[n]||(Di[n]=_i.compile(n));return"string"==typeof e.pathMatch&&(e[0]=e.pathMatch),o(e,{pretty:!0})}catch(n){return""}finally{delete e[0]}}function Ri(n,e,t,o){var a="string"==typeof n?{path:n}:n;if(a._normalized)return a;if(a.name){var i=(a=ei({},n)).params;return i&&"object"==typeof i&&(a.params=ei({},i)),a}if(!a.path&&a.params&&e){(a=ei({},a))._normalized=!0;var r=ei(ei({},e.params),a.params);if(e.name)a.name=e.name,a.params=r;else if(e.matched.length){var s=e.matched[e.matched.length-1].path;a.path=Wi(s,r,e.path)}else 0;return a}var c=function(n){var e="",t="",o=n.indexOf("#");o>=0&&(e=n.slice(o),n=n.slice(0,o));var a=n.indexOf("?");return a>=0&&(t=n.slice(a+1),n=n.slice(0,a)),{path:n,query:t,hash:e}}(a.path||""),l=e&&e.path||"/",d=c.path?ki(c.path,l,t||a.append):l,p=function(n,e,t){void 0===e&&(e={});var o,a=t||ci;try{o=a(n||"")}catch(n){o={}}for(var i in e){var r=e[i];o[i]=Array.isArray(r)?r.map(si):si(r)}return o}(c.query,a.query,o&&o.options.parseQuery),u=a.hash||c.hash;return u&&"#"!==u.charAt(0)&&(u="#"+u),{_normalized:!0,path:d,query:p,hash:u}}var Ni,Gi=function(){},Hi={name:"RouterLink",props:{to:{type:[String,Object],required:!0},tag:{type:String,default:"a"},custom:Boolean,exact:Boolean,exactPath:Boolean,append:Boolean,replace:Boolean,activeClass:String,exactActiveClass:String,ariaCurrentValue:{type:String,default:"page"},event:{type:[String,Array],default:"click"}},render:function(n){var e=this,t=this.$router,o=this.$route,a=t.resolve(this.to,o,this.append),i=a.location,r=a.route,s=a.href,c={},l=t.options.linkActiveClass,d=t.options.linkExactActiveClass,p=null==l?"router-link-active":l,u=null==d?"router-link-exact-active":d,h=null==this.activeClass?p:this.activeClass,m=null==this.exactActiveClass?u:this.exactActiveClass,f=r.redirectedFrom?pi(null,Ri(r.redirectedFrom),null,t):r;c[m]=gi(o,f,this.exactPath),c[h]=this.exact||this.exactPath?c[m]:function(n,e){return 0===n.path.replace(di,"/").indexOf(e.path.replace(di,"/"))&&(!e.hash||n.hash===e.hash)&&function(n,e){for(var t in e)if(!(t in n))return!1;return!0}(n.query,e.query)}(o,f);var g=c[m]?this.ariaCurrentValue:null,y=function(n){Fi(n)&&(e.replace?t.replace(i,Gi):t.push(i,Gi))},v={click:Fi};Array.isArray(this.event)?this.event.forEach((function(n){v[n]=y})):v[this.event]=y;var b={class:c},w=!this.$scopedSlots.$hasNormal&&this.$scopedSlots.default&&this.$scopedSlots.default({href:s,route:r,navigate:y,isActive:c[h],isExactActive:c[m]});if(w){if(1===w.length)return w[0];if(w.length>1||!w.length)return 0===w.length?n():n("span",{},w)}if("a"===this.tag)b.on=v,b.attrs={href:s,"aria-current":g};else{var k=function n(e){var t;if(e)for(var o=0;o<e.length;o++){if("a"===(t=e[o]).tag)return t;if(t.children&&(t=n(t.children)))return t}}(this.$slots.default);if(k){k.isStatic=!1;var x=k.data=ei({},k.data);for(var T in x.on=x.on||{},x.on){var _=x.on[T];T in v&&(x.on[T]=Array.isArray(_)?_:[_])}for(var C in v)C in x.on?x.on[C].push(v[C]):x.on[C]=y;var E=k.data.attrs=ei({},k.data.attrs);E.href=s,E["aria-current"]=g}else b.on=v}return n(this.tag,b,this.$slots.default)}};function Fi(n){if(!(n.metaKey||n.altKey||n.ctrlKey||n.shiftKey||n.defaultPrevented||void 0!==n.button&&0!==n.button)){if(n.currentTarget&&n.currentTarget.getAttribute){var e=n.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(e))return}return n.preventDefault&&n.preventDefault(),!0}}var qi="undefined"!=typeof window;function Vi(n,e,t,o,a){var i=e||[],r=t||Object.create(null),s=o||Object.create(null);n.forEach((function(n){!function n(e,t,o,a,i,r){var s=a.path,c=a.name;0;var l=a.pathToRegexpOptions||{},d=function(n,e,t){t||(n=n.replace(/\/$/,""));if("/"===n[0])return n;if(null==e)return n;return xi(e.path+"/"+n)}(s,i,l.strict);"boolean"==typeof a.caseSensitive&&(l.sensitive=a.caseSensitive);var p={path:d,regex:Xi(d,l),components:a.components||{default:a.component},alias:a.alias?"string"==typeof a.alias?[a.alias]:a.alias:[],instances:{},enteredCbs:{},name:c,parent:i,matchAs:r,redirect:a.redirect,beforeEnter:a.beforeEnter,meta:a.meta||{},props:null==a.props?{}:a.components?a.props:{default:a.props}};a.children&&a.children.forEach((function(a){var i=r?xi(r+"/"+a.path):void 0;n(e,t,o,a,p,i)}));t[p.path]||(e.push(p.path),t[p.path]=p);if(void 0!==a.alias)for(var u=Array.isArray(a.alias)?a.alias:[a.alias],h=0;h<u.length;++h){0;var m={path:u[h],children:a.children};n(e,t,o,m,i,p.path||"/")}c&&(o[c]||(o[c]=p))}(i,r,s,n,a)}));for(var c=0,l=i.length;c<l;c++)"*"===i[c]&&(i.push(i.splice(c,1)[0]),l--,c--);return{pathList:i,pathMap:r,nameMap:s}}function Xi(n,e){return _i(n,[],e)}function Ki(n,e){var t=Vi(n),o=t.pathList,a=t.pathMap,i=t.nameMap;function r(n,t,r){var s=Ri(n,t,!1,e),l=s.name;if(l){var d=i[l];if(!d)return c(null,s);var p=d.regex.keys.filter((function(n){return!n.optional})).map((function(n){return n.name}));if("object"!=typeof s.params&&(s.params={}),t&&"object"==typeof t.params)for(var u in t.params)!(u in s.params)&&p.indexOf(u)>-1&&(s.params[u]=t.params[u]);return s.path=Wi(d.path,s.params),c(d,s,r)}if(s.path){s.params={};for(var h=0;h<o.length;h++){var m=o[h],f=a[m];if(Zi(f.regex,s.path,s.params))return c(f,s,r)}}return c(null,s)}function s(n,t){var o=n.redirect,a="function"==typeof o?o(pi(n,t,null,e)):o;if("string"==typeof a&&(a={path:a}),!a||"object"!=typeof a)return c(null,t);var s=a,l=s.name,d=s.path,p=t.query,u=t.hash,h=t.params;if(p=s.hasOwnProperty("query")?s.query:p,u=s.hasOwnProperty("hash")?s.hash:u,h=s.hasOwnProperty("params")?s.params:h,l){i[l];return r({_normalized:!0,name:l,query:p,hash:u,params:h},void 0,t)}if(d){var m=function(n,e){return ki(n,e.parent?e.parent.path:"/",!0)}(d,n);return r({_normalized:!0,path:Wi(m,h),query:p,hash:u},void 0,t)}return c(null,t)}function c(n,t,o){return n&&n.redirect?s(n,o||t):n&&n.matchAs?function(n,e,t){var o=r({_normalized:!0,path:Wi(t,e.params)});if(o){var a=o.matched,i=a[a.length-1];return e.params=o.params,c(i,e)}return c(null,e)}(0,t,n.matchAs):pi(n,t,o,e)}return{match:r,addRoute:function(n,e){var t="object"!=typeof n?i[n]:void 0;Vi([e||n],o,a,i,t),t&&t.alias.length&&Vi(t.alias.map((function(n){return{path:n,children:[e]}})),o,a,i,t)},getRoutes:function(){return o.map((function(n){return a[n]}))},addRoutes:function(n){Vi(n,o,a,i)}}}function Zi(n,e,t){var o=e.match(n);if(!o)return!1;if(!t)return!0;for(var a=1,i=o.length;a<i;++a){var r=n.keys[a-1];r&&(t[r.name||"pathMatch"]="string"==typeof o[a]?ri(o[a]):o[a])}return!0}var Ji=qi&&window.performance&&window.performance.now?window.performance:Date;function Yi(){return Ji.now().toFixed(3)}var Qi=Yi();function nr(){return Qi}function er(n){return Qi=n}var tr=Object.create(null);function or(){"scrollRestoration"in window.history&&(window.history.scrollRestoration="manual");var n=window.location.protocol+"//"+window.location.host,e=window.location.href.replace(n,""),t=ei({},window.history.state);return t.key=nr(),window.history.replaceState(t,"",e),window.addEventListener("popstate",rr),function(){window.removeEventListener("popstate",rr)}}function ar(n,e,t,o){if(n.app){var a=n.options.scrollBehavior;a&&n.app.$nextTick((function(){var i=function(){var n=nr();if(n)return tr[n]}(),r=a.call(n,e,t,o?i:null);r&&("function"==typeof r.then?r.then((function(n){pr(n,i)})).catch((function(n){0})):pr(r,i))}))}}function ir(){var n=nr();n&&(tr[n]={x:window.pageXOffset,y:window.pageYOffset})}function rr(n){ir(),n.state&&n.state.key&&er(n.state.key)}function sr(n){return lr(n.x)||lr(n.y)}function cr(n){return{x:lr(n.x)?n.x:window.pageXOffset,y:lr(n.y)?n.y:window.pageYOffset}}function lr(n){return"number"==typeof n}var dr=/^#\d/;function pr(n,e){var t,o="object"==typeof n;if(o&&"string"==typeof n.selector){var a=dr.test(n.selector)?document.getElementById(n.selector.slice(1)):document.querySelector(n.selector);if(a){var i=n.offset&&"object"==typeof n.offset?n.offset:{};e=function(n,e){var t=document.documentElement.getBoundingClientRect(),o=n.getBoundingClientRect();return{x:o.left-t.left-e.x,y:o.top-t.top-e.y}}(a,i={x:lr((t=i).x)?t.x:0,y:lr(t.y)?t.y:0})}else sr(n)&&(e=cr(n))}else o&&sr(n)&&(e=cr(n));e&&("scrollBehavior"in document.documentElement.style?window.scrollTo({left:e.x,top:e.y,behavior:n.behavior}):window.scrollTo(e.x,e.y))}var ur,hr=qi&&((-1===(ur=window.navigator.userAgent).indexOf("Android 2.")&&-1===ur.indexOf("Android 4.0")||-1===ur.indexOf("Mobile Safari")||-1!==ur.indexOf("Chrome")||-1!==ur.indexOf("Windows Phone"))&&window.history&&"function"==typeof window.history.pushState);function mr(n,e){ir();var t=window.history;try{if(e){var o=ei({},t.state);o.key=nr(),t.replaceState(o,"",n)}else t.pushState({key:er(Yi())},"",n)}catch(t){window.location[e?"replace":"assign"](n)}}function fr(n){mr(n,!0)}function gr(n,e,t){var o=function(a){a>=n.length?t():n[a]?e(n[a],(function(){o(a+1)})):o(a+1)};o(0)}var yr={redirected:2,aborted:4,cancelled:8,duplicated:16};function vr(n,e){return wr(n,e,yr.redirected,'Redirected when going from "'+n.fullPath+'" to "'+function(n){if("string"==typeof n)return n;if("path"in n)return n.path;var e={};return kr.forEach((function(t){t in n&&(e[t]=n[t])})),JSON.stringify(e,null,2)}(e)+'" via a navigation guard.')}function br(n,e){return wr(n,e,yr.cancelled,'Navigation cancelled from "'+n.fullPath+'" to "'+e.fullPath+'" with a new navigation.')}function wr(n,e,t,o){var a=new Error(o);return a._isRouter=!0,a.from=n,a.to=e,a.type=t,a}var kr=["params","query","hash"];function xr(n){return Object.prototype.toString.call(n).indexOf("Error")>-1}function Tr(n,e){return xr(n)&&n._isRouter&&(null==e||n.type===e)}function _r(n){return function(e,t,o){var a=!1,i=0,r=null;Cr(n,(function(n,e,t,s){if("function"==typeof n&&void 0===n.cid){a=!0,i++;var c,l=Ar((function(e){var a;((a=e).__esModule||Sr&&"Module"===a[Symbol.toStringTag])&&(e=e.default),n.resolved="function"==typeof e?e:Ni.extend(e),t.components[s]=e,--i<=0&&o()})),d=Ar((function(n){var e="Failed to resolve async component "+s+": "+n;r||(r=xr(n)?n:new Error(e),o(r))}));try{c=n(l,d)}catch(n){d(n)}if(c)if("function"==typeof c.then)c.then(l,d);else{var p=c.component;p&&"function"==typeof p.then&&p.then(l,d)}}})),a||o()}}function Cr(n,e){return Er(n.map((function(n){return Object.keys(n.components).map((function(t){return e(n.components[t],n.instances[t],n,t)}))})))}function Er(n){return Array.prototype.concat.apply([],n)}var Sr="function"==typeof Symbol&&"symbol"==typeof Symbol.toStringTag;function Ar(n){var e=!1;return function(){for(var t=[],o=arguments.length;o--;)t[o]=arguments[o];if(!e)return e=!0,n.apply(this,t)}}var Ir=function(n,e){this.router=n,this.base=function(n){if(!n)if(qi){var e=document.querySelector("base");n=(n=e&&e.getAttribute("href")||"/").replace(/^https?:\/\/[^\/]+/,"")}else n="/";"/"!==n.charAt(0)&&(n="/"+n);return n.replace(/\/$/,"")}(e),this.current=hi,this.pending=null,this.ready=!1,this.readyCbs=[],this.readyErrorCbs=[],this.errorCbs=[],this.listeners=[]};function jr(n,e,t,o){var a=Cr(n,(function(n,o,a,i){var r=function(n,e){"function"!=typeof n&&(n=Ni.extend(n));return n.options[e]}(n,e);if(r)return Array.isArray(r)?r.map((function(n){return t(n,o,a,i)})):t(r,o,a,i)}));return Er(o?a.reverse():a)}function Pr(n,e){if(e)return function(){return n.apply(e,arguments)}}Ir.prototype.listen=function(n){this.cb=n},Ir.prototype.onReady=function(n,e){this.ready?n():(this.readyCbs.push(n),e&&this.readyErrorCbs.push(e))},Ir.prototype.onError=function(n){this.errorCbs.push(n)},Ir.prototype.transitionTo=function(n,e,t){var o,a=this;try{o=this.router.match(n,this.current)}catch(n){throw this.errorCbs.forEach((function(e){e(n)})),n}var i=this.current;this.confirmTransition(o,(function(){a.updateRoute(o),e&&e(o),a.ensureURL(),a.router.afterHooks.forEach((function(n){n&&n(o,i)})),a.ready||(a.ready=!0,a.readyCbs.forEach((function(n){n(o)})))}),(function(n){t&&t(n),n&&!a.ready&&(Tr(n,yr.redirected)&&i===hi||(a.ready=!0,a.readyErrorCbs.forEach((function(e){e(n)}))))}))},Ir.prototype.confirmTransition=function(n,e,t){var o=this,a=this.current;this.pending=n;var i,r,s=function(n){!Tr(n)&&xr(n)&&(o.errorCbs.length?o.errorCbs.forEach((function(e){e(n)})):console.error(n)),t&&t(n)},c=n.matched.length-1,l=a.matched.length-1;if(gi(n,a)&&c===l&&n.matched[c]===a.matched[l])return this.ensureURL(),n.hash&&ar(this.router,a,n,!1),s(((r=wr(i=a,n,yr.duplicated,'Avoided redundant navigation to current location: "'+i.fullPath+'".')).name="NavigationDuplicated",r));var d=function(n,e){var t,o=Math.max(n.length,e.length);for(t=0;t<o&&n[t]===e[t];t++);return{updated:e.slice(0,t),activated:e.slice(t),deactivated:n.slice(t)}}(this.current.matched,n.matched),p=d.updated,u=d.deactivated,h=d.activated,m=[].concat(function(n){return jr(n,"beforeRouteLeave",Pr,!0)}(u),this.router.beforeHooks,function(n){return jr(n,"beforeRouteUpdate",Pr)}(p),h.map((function(n){return n.beforeEnter})),_r(h)),f=function(e,t){if(o.pending!==n)return s(br(a,n));try{e(n,a,(function(e){!1===e?(o.ensureURL(!0),s(function(n,e){return wr(n,e,yr.aborted,'Navigation aborted from "'+n.fullPath+'" to "'+e.fullPath+'" via a navigation guard.')}(a,n))):xr(e)?(o.ensureURL(!0),s(e)):"string"==typeof e||"object"==typeof e&&("string"==typeof e.path||"string"==typeof e.name)?(s(vr(a,n)),"object"==typeof e&&e.replace?o.replace(e):o.push(e)):t(e)}))}catch(n){s(n)}};gr(m,f,(function(){gr(function(n){return jr(n,"beforeRouteEnter",(function(n,e,t,o){return function(n,e,t){return function(o,a,i){return n(o,a,(function(n){"function"==typeof n&&(e.enteredCbs[t]||(e.enteredCbs[t]=[]),e.enteredCbs[t].push(n)),i(n)}))}}(n,t,o)}))}(h).concat(o.router.resolveHooks),f,(function(){if(o.pending!==n)return s(br(a,n));o.pending=null,e(n),o.router.app&&o.router.app.$nextTick((function(){vi(n)}))}))}))},Ir.prototype.updateRoute=function(n){this.current=n,this.cb&&this.cb(n)},Ir.prototype.setupListeners=function(){},Ir.prototype.teardown=function(){this.listeners.forEach((function(n){n()})),this.listeners=[],this.current=hi,this.pending=null};var zr=function(n){function e(e,t){n.call(this,e,t),this._startLocation=Mr(this.base)}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router,t=e.options.scrollBehavior,o=hr&&t;o&&this.listeners.push(or());var a=function(){var t=n.current,a=Mr(n.base);n.current===hi&&a===n._startLocation||n.transitionTo(a,(function(n){o&&ar(e,n,t,!0)}))};window.addEventListener("popstate",a),this.listeners.push((function(){window.removeEventListener("popstate",a)}))}},e.prototype.go=function(n){window.history.go(n)},e.prototype.push=function(n,e,t){var o=this,a=this.current;this.transitionTo(n,(function(n){mr(xi(o.base+n.fullPath)),ar(o.router,n,a,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var o=this,a=this.current;this.transitionTo(n,(function(n){fr(xi(o.base+n.fullPath)),ar(o.router,n,a,!1),e&&e(n)}),t)},e.prototype.ensureURL=function(n){if(Mr(this.base)!==this.current.fullPath){var e=xi(this.base+this.current.fullPath);n?mr(e):fr(e)}},e.prototype.getCurrentLocation=function(){return Mr(this.base)},e}(Ir);function Mr(n){var e=window.location.pathname,t=e.toLowerCase(),o=n.toLowerCase();return!n||t!==o&&0!==t.indexOf(xi(o+"/"))||(e=e.slice(n.length)),(e||"/")+window.location.search+window.location.hash}var Or=function(n){function e(e,t,o){n.call(this,e,t),o&&function(n){var e=Mr(n);if(!/^\/#/.test(e))return window.location.replace(xi(n+"/#"+e)),!0}(this.base)||$r()}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router.options.scrollBehavior,t=hr&&e;t&&this.listeners.push(or());var o=function(){var e=n.current;$r()&&n.transitionTo(Br(),(function(o){t&&ar(n.router,o,e,!0),hr||Dr(o.fullPath)}))},a=hr?"popstate":"hashchange";window.addEventListener(a,o),this.listeners.push((function(){window.removeEventListener(a,o)}))}},e.prototype.push=function(n,e,t){var o=this,a=this.current;this.transitionTo(n,(function(n){Ur(n.fullPath),ar(o.router,n,a,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var o=this,a=this.current;this.transitionTo(n,(function(n){Dr(n.fullPath),ar(o.router,n,a,!1),e&&e(n)}),t)},e.prototype.go=function(n){window.history.go(n)},e.prototype.ensureURL=function(n){var e=this.current.fullPath;Br()!==e&&(n?Ur(e):Dr(e))},e.prototype.getCurrentLocation=function(){return Br()},e}(Ir);function $r(){var n=Br();return"/"===n.charAt(0)||(Dr("/"+n),!1)}function Br(){var n=window.location.href,e=n.indexOf("#");return e<0?"":n=n.slice(e+1)}function Lr(n){var e=window.location.href,t=e.indexOf("#");return(t>=0?e.slice(0,t):e)+"#"+n}function Ur(n){hr?mr(Lr(n)):window.location.hash=n}function Dr(n){hr?fr(Lr(n)):window.location.replace(Lr(n))}var Wr=function(n){function e(e,t){n.call(this,e,t),this.stack=[],this.index=-1}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.push=function(n,e,t){var o=this;this.transitionTo(n,(function(n){o.stack=o.stack.slice(0,o.index+1).concat(n),o.index++,e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var o=this;this.transitionTo(n,(function(n){o.stack=o.stack.slice(0,o.index).concat(n),e&&e(n)}),t)},e.prototype.go=function(n){var e=this,t=this.index+n;if(!(t<0||t>=this.stack.length)){var o=this.stack[t];this.confirmTransition(o,(function(){var n=e.current;e.index=t,e.updateRoute(o),e.router.afterHooks.forEach((function(e){e&&e(o,n)}))}),(function(n){Tr(n,yr.duplicated)&&(e.index=t)}))}},e.prototype.getCurrentLocation=function(){var n=this.stack[this.stack.length-1];return n?n.fullPath:"/"},e.prototype.ensureURL=function(){},e}(Ir),Rr=function(n){void 0===n&&(n={}),this.app=null,this.apps=[],this.options=n,this.beforeHooks=[],this.resolveHooks=[],this.afterHooks=[],this.matcher=Ki(n.routes||[],this);var e=n.mode||"hash";switch(this.fallback="history"===e&&!hr&&!1!==n.fallback,this.fallback&&(e="hash"),qi||(e="abstract"),this.mode=e,e){case"history":this.history=new zr(this,n.base);break;case"hash":this.history=new Or(this,n.base,this.fallback);break;case"abstract":this.history=new Wr(this,n.base);break;default:0}},Nr={currentRoute:{configurable:!0}};function Gr(n,e){return n.push(e),function(){var t=n.indexOf(e);t>-1&&n.splice(t,1)}}Rr.prototype.match=function(n,e,t){return this.matcher.match(n,e,t)},Nr.currentRoute.get=function(){return this.history&&this.history.current},Rr.prototype.init=function(n){var e=this;if(this.apps.push(n),n.$once("hook:destroyed",(function(){var t=e.apps.indexOf(n);t>-1&&e.apps.splice(t,1),e.app===n&&(e.app=e.apps[0]||null),e.app||e.history.teardown()})),!this.app){this.app=n;var t=this.history;if(t instanceof zr||t instanceof Or){var o=function(n){t.setupListeners(),function(n){var o=t.current,a=e.options.scrollBehavior;hr&&a&&"fullPath"in n&&ar(e,n,o,!1)}(n)};t.transitionTo(t.getCurrentLocation(),o,o)}t.listen((function(n){e.apps.forEach((function(e){e._route=n}))}))}},Rr.prototype.beforeEach=function(n){return Gr(this.beforeHooks,n)},Rr.prototype.beforeResolve=function(n){return Gr(this.resolveHooks,n)},Rr.prototype.afterEach=function(n){return Gr(this.afterHooks,n)},Rr.prototype.onReady=function(n,e){this.history.onReady(n,e)},Rr.prototype.onError=function(n){this.history.onError(n)},Rr.prototype.push=function(n,e,t){var o=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){o.history.push(n,e,t)}));this.history.push(n,e,t)},Rr.prototype.replace=function(n,e,t){var o=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){o.history.replace(n,e,t)}));this.history.replace(n,e,t)},Rr.prototype.go=function(n){this.history.go(n)},Rr.prototype.back=function(){this.go(-1)},Rr.prototype.forward=function(){this.go(1)},Rr.prototype.getMatchedComponents=function(n){var e=n?n.matched?n:this.resolve(n).route:this.currentRoute;return e?[].concat.apply([],e.matched.map((function(n){return Object.keys(n.components).map((function(e){return n.components[e]}))}))):[]},Rr.prototype.resolve=function(n,e,t){var o=Ri(n,e=e||this.history.current,t,this),a=this.match(o,e),i=a.redirectedFrom||a.fullPath;return{location:o,route:a,href:function(n,e,t){var o="hash"===t?"#"+e:e;return n?xi(n+"/"+o):o}(this.history.base,i,this.mode),normalizedTo:o,resolved:a}},Rr.prototype.getRoutes=function(){return this.matcher.getRoutes()},Rr.prototype.addRoute=function(n,e){this.matcher.addRoute(n,e),this.history.current!==hi&&this.history.transitionTo(this.history.getCurrentLocation())},Rr.prototype.addRoutes=function(n){this.matcher.addRoutes(n),this.history.current!==hi&&this.history.transitionTo(this.history.getCurrentLocation())},Object.defineProperties(Rr.prototype,Nr),Rr.install=function n(e){if(!n.installed||Ni!==e){n.installed=!0,Ni=e;var t=function(n){return void 0!==n},o=function(n,e){var o=n.$options._parentVnode;t(o)&&t(o=o.data)&&t(o=o.registerRouteInstance)&&o(n,e)};e.mixin({beforeCreate:function(){t(this.$options.router)?(this._routerRoot=this,this._router=this.$options.router,this._router.init(this),e.util.defineReactive(this,"_route",this._router.history.current)):this._routerRoot=this.$parent&&this.$parent._routerRoot||this,o(this,this)},destroyed:function(){o(this)}}),Object.defineProperty(e.prototype,"$router",{get:function(){return this._routerRoot._router}}),Object.defineProperty(e.prototype,"$route",{get:function(){return this._routerRoot._route}}),e.component("RouterView",bi),e.component("RouterLink",Hi);var a=e.config.optionMergeStrategies;a.beforeRouteEnter=a.beforeRouteLeave=a.beforeRouteUpdate=a.created}},Rr.version="3.5.4",Rr.isNavigationFailure=Tr,Rr.NavigationFailureType=yr,Rr.START_LOCATION=hi,qi&&window.Vue&&window.Vue.use(Rr);var Hr=Rr;t(96);t(124);var Fr={NotFound:()=>Promise.all([t.e(0),t.e(4)]).then(t.bind(null,313)),Layout:()=>Promise.all([t.e(0),t.e(2)]).then(t.bind(null,312))},qr={"v-59ee63fe":()=>t.e(7).then(t.bind(null,314)),"v-77c5ce9c":()=>t.e(8).then(t.bind(null,315)),"v-6a22f932":()=>t.e(9).then(t.bind(null,316)),"v-455f0d94":()=>t.e(10).then(t.bind(null,317)),"v-3dac3e03":()=>t.e(11).then(t.bind(null,318)),"v-15a9f55e":()=>t.e(12).then(t.bind(null,319)),"v-72b8a039":()=>t.e(13).then(t.bind(null,320)),"v-7d704a16":()=>t.e(14).then(t.bind(null,321)),"v-18a6fca4":()=>t.e(15).then(t.bind(null,322)),"v-1dc56f77":()=>t.e(16).then(t.bind(null,323)),"v-3ce102e1":()=>t.e(17).then(t.bind(null,324)),"v-3d087b67":()=>t.e(18).then(t.bind(null,325)),"v-e0ad2bb2":()=>t.e(19).then(t.bind(null,326)),"v-973514f8":()=>t.e(20).then(t.bind(null,327)),"v-2c9acafa":()=>t.e(21).then(t.bind(null,328)),"v-5d10c0ed":()=>t.e(22).then(t.bind(null,329)),"v-50562bab":()=>t.e(23).then(t.bind(null,330)),"v-640dd7dc":()=>t.e(24).then(t.bind(null,331)),"v-17cedb24":()=>t.e(25).then(t.bind(null,332)),"v-58f5998e":()=>t.e(26).then(t.bind(null,333)),"v-4ed835a8":()=>t.e(27).then(t.bind(null,334)),"v-3bf5446e":()=>t.e(28).then(t.bind(null,335)),"v-49b0f2aa":()=>t.e(29).then(t.bind(null,336)),"v-3bddb7a2":()=>t.e(30).then(t.bind(null,337)),"v-fdfe0ef0":()=>t.e(31).then(t.bind(null,338)),"v-075f2a06":()=>t.e(32).then(t.bind(null,339)),"v-0d66cacc":()=>t.e(33).then(t.bind(null,340)),"v-0cd550e5":()=>t.e(34).then(t.bind(null,341)),"v-4d16eb48":()=>t.e(35).then(t.bind(null,342)),"v-708b622a":()=>t.e(36).then(t.bind(null,343)),"v-8d136732":()=>t.e(37).then(t.bind(null,344)),"v-96f85bb2":()=>t.e(38).then(t.bind(null,345)),"v-5b320bc2":()=>t.e(39).then(t.bind(null,346)),"v-4ec77c26":()=>t.e(6).then(t.bind(null,347)),"v-36c869aa":()=>t.e(40).then(t.bind(null,348)),"v-7d4c8dc4":()=>Promise.all([t.e(0),t.e(5)]).then(t.bind(null,349))};function Vr(n){const e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}const Xr=/-(\w)/g,Kr=Vr(n=>n.replace(Xr,(n,e)=>e?e.toUpperCase():"")),Zr=/\B([A-Z])/g,Jr=Vr(n=>n.replace(Zr,"-$1").toLowerCase()),Yr=Vr(n=>n.charAt(0).toUpperCase()+n.slice(1));function Qr(n,e){if(!e)return;if(n(e))return n(e);return e.includes("-")?n(Yr(Kr(e))):n(Yr(e))||n(Jr(e))}const ns=Object.assign({},Fr,qr),es=n=>ns[n],ts=n=>qr[n],os=n=>Fr[n],as=n=>Ft.component(n);function is(n){return Qr(ts,n)}function rs(n){return Qr(os,n)}function ss(n){return Qr(es,n)}function cs(n){return Qr(as,n)}function ls(...n){return Promise.all(n.filter(n=>n).map(async n=>{if(!cs(n)&&ss(n)){const e=await ss(n)();Ft.component(n,e.default)}}))}function ds(n,e){"undefined"!=typeof window&&window.__VUEPRESS__&&(window.__VUEPRESS__[n]=e)}var ps=t(90),us=t.n(ps),hs=t(91),ms=t.n(hs),fs={created(){if(this.siteMeta=this.$site.headTags.filter(([n])=>"meta"===n).map(([n,e])=>e),this.$ssrContext){const e=this.getMergedMetaTags();this.$ssrContext.title=this.$title,this.$ssrContext.lang=this.$lang,this.$ssrContext.pageMeta=(n=e)?n.map(n=>{let e="<meta";return Object.keys(n).forEach(t=>{e+=` ${t}="${ms()(n[t])}"`}),e+">"}).join("\n    "):"",this.$ssrContext.canonicalLink=ys(this.$canonicalUrl)}var n},mounted(){this.currentMetaTags=[...document.querySelectorAll("meta")],this.updateMeta(),this.updateCanonicalLink()},methods:{updateMeta(){document.title=this.$title,document.documentElement.lang=this.$lang;const n=this.getMergedMetaTags();this.currentMetaTags=vs(n,this.currentMetaTags)},getMergedMetaTags(){const n=this.$page.frontmatter.meta||[];return us()([{name:"description",content:this.$description}],n,this.siteMeta,bs)},updateCanonicalLink(){gs(),this.$canonicalUrl&&document.head.insertAdjacentHTML("beforeend",ys(this.$canonicalUrl))}},watch:{$page(){this.updateMeta(),this.updateCanonicalLink()}},beforeDestroy(){vs(null,this.currentMetaTags),gs()}};function gs(){const n=document.querySelector("link[rel='canonical']");n&&n.remove()}function ys(n=""){return n?`<link href="${n}" rel="canonical" />`:""}function vs(n,e){if(e&&[...e].filter(n=>n.parentNode===document.head).forEach(n=>document.head.removeChild(n)),n)return n.map(n=>{const e=document.createElement("meta");return Object.keys(n).forEach(t=>{e.setAttribute(t,n[t])}),document.head.appendChild(e),e})}function bs(n){for(const e of["name","property","itemprop"])if(n.hasOwnProperty(e))return n[e]+e;return JSON.stringify(n)}var ws=t(43),ks={mounted(){window.addEventListener("scroll",this.onScroll)},methods:{onScroll:t.n(ws)()((function(){this.setActiveHash()}),300),setActiveHash(){const n=[].slice.call(document.querySelectorAll(".sidebar-link")),e=[].slice.call(document.querySelectorAll(".header-anchor")).filter(e=>n.some(n=>n.hash===e.hash)),t=Math.max(window.pageYOffset,document.documentElement.scrollTop,document.body.scrollTop),o=Math.max(document.documentElement.scrollHeight,document.body.scrollHeight),a=window.innerHeight+t;for(let n=0;n<e.length;n++){const i=e[n],r=e[n+1],s=0===n&&0===t||t>=i.parentElement.offsetTop+10&&(!r||t<r.parentElement.offsetTop-10),c=decodeURIComponent(this.$route.hash);if(s&&c!==decodeURIComponent(i.hash)){const t=i;if(a===o)for(let t=n+1;t<e.length;t++)if(c===decodeURIComponent(e[t].hash))return;return this.$vuepress.$set("disableScrollBehavior",!0),void this.$router.replace(decodeURIComponent(t.hash),()=>{this.$nextTick(()=>{this.$vuepress.$set("disableScrollBehavior",!1)})})}}}},beforeDestroy(){window.removeEventListener("scroll",this.onScroll)}},xs=t(23),Ts=t.n(xs),_s={mounted(){Ts.a.configure({showSpinner:!1}),this.$router.beforeEach((n,e,t)=>{n.path===e.path||Ft.component(n.name)||Ts.a.start(),t()}),this.$router.afterEach(()=>{Ts.a.done(),this.isSidebarOpen=!1})}};t(231),t(232);class Cs{constructor(){this.containerEl=document.getElementById("message-container"),this.containerEl||(this.containerEl=document.createElement("div"),this.containerEl.id="message-container",document.body.appendChild(this.containerEl))}show({text:n="",duration:e=3e3}){let t=document.createElement("div");t.className="message move-in",t.innerHTML=`\n      <i style="fill: #06a35a;font-size: 14px;display:inline-flex;align-items: center;">\n        <svg style="fill: #06a35a;font-size: 14px;" t="1572421810237" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2323" width="16" height="16"><path d="M822.811993 824.617989c-83.075838 81.99224-188.546032 124.613757-316.049383 127.86455-122.085362-3.250794-223.943563-45.87231-305.935802-127.86455s-124.613757-184.21164-127.86455-305.935802c3.250794-127.503351 45.87231-232.973545 127.86455-316.049383 81.99224-83.075838 184.21164-126.058554 305.935802-129.309347 127.503351 3.250794 232.973545 46.23351 316.049383 129.309347 83.075838 83.075838 126.058554 188.546032 129.309347 316.049383C949.231746 640.406349 905.887831 742.62575 822.811993 824.617989zM432.716755 684.111464c3.973192 3.973192 8.307584 5.779189 13.364374 6.140388 5.05679 0.361199 9.752381-1.444797 13.364374-5.417989l292.571429-287.514638c3.973192-3.973192 5.779189-8.307584 5.779189-13.364374 0-5.05679-1.805996-9.752381-5.779189-13.364374l1.805996 1.805996c-3.973192-3.973192-8.668783-5.779189-14.086772-6.140388-5.417989-0.361199-10.47478 1.444797-14.809171 5.417989l-264.397884 220.33157c-3.973192 3.250794-8.668783 4.695591-14.447972 4.695591-5.779189 0-10.835979-1.444797-15.53157-3.973192l-94.273016-72.962257c-4.334392-3.250794-9.391182-4.334392-14.447972-3.973192s-9.391182 3.250794-12.641975 7.585185l-2.889594 3.973192c-3.250794 4.334392-4.334392 9.391182-3.973192 14.809171 0.722399 5.417989 2.528395 10.11358 5.779189 14.086772L432.716755 684.111464z" p-id="2324"></path></svg>\n      </i>\n      <div class="text">${n}</div>\n    `,this.containerEl.appendChild(t),e>0&&setTimeout(()=>{this.close(t)},e)}close(n){n.className=n.className.replace("move-in",""),n.className+="move-out",n.addEventListener("animationend",()=>{n.remove()})}}var Es={mounted(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},updated(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},methods:{updateCopy(){setTimeout(()=>{(['div[class*="language-"] pre','div[class*="aside-code"] aside']instanceof Array||Array.isArray(['div[class*="language-"] pre','div[class*="aside-code"] aside']))&&['div[class*="language-"] pre','div[class*="aside-code"] aside'].forEach(n=>{document.querySelectorAll(n).forEach(this.generateCopyButton)})},1e3)},generateCopyButton(n){if(n.classList.contains("codecopy-enabled"))return;const e=document.createElement("i");e.className="code-copy",e.innerHTML='<svg  style="color:#aaa;font-size:14px" t="1572422231464" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3201" width="14" height="14"><path d="M866.461538 39.384615H354.461538c-43.323077 0-78.769231 35.446154-78.76923 78.769231v39.384616h472.615384c43.323077 0 78.769231 35.446154 78.769231 78.76923v551.384616h39.384615c43.323077 0 78.769231-35.446154 78.769231-78.769231V118.153846c0-43.323077-35.446154-78.769231-78.769231-78.769231z m-118.153846 275.692308c0-43.323077-35.446154-78.769231-78.76923-78.769231H157.538462c-43.323077 0-78.769231 35.446154-78.769231 78.769231v590.769231c0 43.323077 35.446154 78.769231 78.769231 78.769231h512c43.323077 0 78.769231-35.446154 78.76923-78.769231V315.076923z m-354.461538 137.846154c0 11.815385-7.876923 19.692308-19.692308 19.692308h-157.538461c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h157.538461c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z m157.538461 315.076923c0 11.815385-7.876923 19.692308-19.692307 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h315.076923c11.815385 0 19.692308 7.876923 19.692307 19.692308v39.384615z m78.769231-157.538462c0 11.815385-7.876923 19.692308-19.692308 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h393.846153c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z" p-id="3202"></path></svg>',e.title="Copy to clipboard",e.addEventListener("click",()=>{this.copyToClipboard(n.innerText)}),n.appendChild(e),n.classList.add("codecopy-enabled")},copyToClipboard(n){const e=document.createElement("textarea");e.value=n,e.setAttribute("readonly",""),e.style.position="absolute",e.style.left="-9999px",document.body.appendChild(e);const t=document.getSelection().rangeCount>0&&document.getSelection().getRangeAt(0);e.select(),document.execCommand("copy");(new Cs).show({text:"复制成功",duration:1e3}),document.body.removeChild(e),t&&(document.getSelection().removeAllRanges(),document.getSelection().addRange(t))}}};!function(n,e){void 0===e&&(e={});var t=e.insertAt;if(n&&"undefined"!=typeof document){var o=document.head||document.getElementsByTagName("head")[0],a=document.createElement("style");a.type="text/css","top"===t&&o.firstChild?o.insertBefore(a,o.firstChild):o.appendChild(a),a.styleSheet?a.styleSheet.cssText=n:a.appendChild(document.createTextNode(n))}}("@media (max-width: 1000px) {\n  .vuepress-plugin-demo-block__h_code {\n    display: none;\n  }\n  .vuepress-plugin-demo-block__app {\n    margin-left: auto !important;\n    margin-right: auto !important;\n  }\n}\n.vuepress-plugin-demo-block__wrapper {\n  margin-top: 10px;\n  border: 1px solid #ebebeb;\n  border-radius: 4px;\n  transition: all 0.2s;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display {\n  height: 400px;\n  display: flex;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__app {\n  width: 300px;\n  border: 1px solid #ebebeb;\n  box-shadow: 1px 1px 3px #ebebeb;\n  margin-right: 5px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code {\n  flex: 1;\n  overflow: auto;\n  height: 100%;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code > pre {\n  overflow: visible;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  max-height: 400px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper div {\n  box-sizing: border-box;\n}\n.vuepress-plugin-demo-block__wrapper:hover {\n  box-shadow: 0 0 11px rgba(33, 33, 33, 0.2);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code {\n  overflow: hidden;\n  height: 0;\n  padding: 0 !important;\n  background-color: #282c34;\n  border-radius: 0 !important;\n  transition: height 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code pre {\n  margin: 0 !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  padding: 20px;\n  border-bottom: 1px solid #ebebeb;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer {\n  position: relative;\n  text-align: center;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__codepen {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__expand::before {\n  border-top: none;\n  border-right: 6px solid transparent;\n  border-bottom: 6px solid #ccc;\n  border-left: 6px solid transparent;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__codepen,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand span,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand::before {\n  border-top-color: #3eaf7c !important;\n  border-bottom-color: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover svg {\n  fill: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand-text {\n  transition: all 0.5s;\n  opacity: 0;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:nth-last-child(2) {\n  right: 50px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:last-child {\n  right: 10px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button {\n  border-color: transparent;\n  background-color: transparent;\n  font-size: 14px;\n  color: #3eaf7c;\n  cursor: pointer;\n  outline: none;\n  margin: 0;\n  width: 46px;\n  position: relative;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::before {\n  content: attr(data-tip);\n  white-space: nowrap;\n  position: absolute;\n  top: -30px;\n  left: 50%;\n  color: #eee;\n  line-height: 1;\n  z-index: 1000;\n  border-radius: 4px;\n  padding: 6px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  background-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::after {\n  content: '' !important;\n  display: block;\n  position: absolute;\n  left: 50%;\n  top: -5px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  border: 5px solid transparent;\n  border-top-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button svg {\n  width: 34px;\n  height: 20px;\n  fill: #ccc;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__codepen {\n  position: absolute;\n  top: 10px;\n  transition: all 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand {\n  position: relative;\n  width: 100px;\n  height: 40px;\n  margin: 0;\n  color: #3eaf7c;\n  font-size: 14px;\n  background-color: transparent;\n  border-color: transparent;\n  outline: none;\n  transition: all 0.5s;\n  cursor: pointer;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand::before {\n  content: \"\";\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  width: 0;\n  height: 0;\n  border-top: 6px solid #ccc;\n  border-right: 6px solid transparent;\n  border-left: 6px solid transparent;\n  -webkit-transform: translate(-50%, -50%);\n          transform: translate(-50%, -50%);\n}\n");var Ss={jsLib:[],cssLib:[],jsfiddle:!0,codepen:!0,codepenLayout:"left",codepenJsProcessor:"babel",codepenEditors:"101",horizontal:!1,vue:"https://cdn.jsdelivr.net/npm/vue/dist/vue.min.js",react:"https://cdn.jsdelivr.net/npm/react/umd/react.production.min.js",reactDOM:"https://cdn.jsdelivr.net/npm/react-dom/umd/react-dom.production.min.js"},As={},Is=function(n){return'<div id="app">\n'.concat(n,"\n</div>")},js=function(n){return window.$VUEPRESS_DEMO_BLOCK&&void 0!==window.$VUEPRESS_DEMO_BLOCK[n]?window.$VUEPRESS_DEMO_BLOCK[n]:Ss[n]},Ps=function n(e,t,o){var a=document.createElement(e);return t&&Object.keys(t).forEach((function(n){if(n.indexOf("data"))a[n]=t[n];else{var e=n.replace("data","");a.dataset[e]=t[n]}})),o&&o.forEach((function(e){var t=e.tag,o=e.attrs,i=e.children;a.appendChild(n(t,o,i))})),a},zs=function(n,e,t){var o,a=(o=n.querySelectorAll(".".concat(e)),Array.prototype.slice.call(o));return 1!==a.length||t?a:a[0]},Ms=function(n,e){var t,o,a=n.match(/<style>([\s\S]+)<\/style>/),i=n.match(/<template>([\s\S]+)<\/template>/),r=n.match(/<script>([\s\S]+)<\/script>/),s={css:a&&a[1].replace(/^\n|\n$/g,""),html:i&&i[1].replace(/^\n|\n$/g,""),js:r&&r[1].replace(/^\n|\n$/g,""),jsLib:e.jsLib||[],cssLib:e.cssLib||[]};s.htmlTpl=Is(s.html),s.jsTpl=(t=s.js,o=t.replace(/export\s+default\s*?\{\n*/,"").replace(/\n*\}\s*$/,"").trim(),"new Vue({\n  el: '#app',\n  ".concat(o,"\n})")),s.script=function(n,e){var t=n.split(/export\s+default/),o="(function() {".concat(t[0]," ; return ").concat(t[1],"})()"),a=window.Babel?window.Babel.transform(o,{presets:["es2015"]}).code:o,i=[eval][0](a);return i.template=e,i}(s.js,s.html);var c=js("vue");return s.jsLib.unshift(c),s},Os=function(n,e){var t,o=n.match(/<style>([\s\S]+)<\/style>/),a=n.match(/<html>([\s\S]+)<\/html>/),i=n.match(/<script>([\s\S]+)<\/script>/),r={css:o&&o[1].replace(/^\n|\n$/g,""),html:a&&a[1].replace(/^\n|\n$/g,""),js:i&&i[1].replace(/^\n|\n$/g,""),jsLib:e.jsLib||[],cssLib:e.cssLib||[]};return r.htmlTpl=r.html,r.jsTpl=r.js,r.script=(t=r.js,window.Babel?window.Babel.transform(t,{presets:["es2015"]}).code:t),r},$s=function(n){return n=n.replace("export default ","").replace(/App\.__style__(\s*)=(\s*)`([\s\S]*)?`/,""),n+='ReactDOM.render(React.createElement(App), document.getElementById("app"))'};function Bs(){var n=zs(document,"vuepress-plugin-demo-block__wrapper",!0);n.length?n.forEach((function(n){if("true"!==n.dataset.created){n.style.display="block";var e=zs(n,"vuepress-plugin-demo-block__code"),t=zs(n,"vuepress-plugin-demo-block__display"),o=zs(n,"vuepress-plugin-demo-block__footer"),a=zs(t,"vuepress-plugin-demo-block__app"),i=decodeURIComponent(n.dataset.code),r=decodeURIComponent(n.dataset.config),s=decodeURIComponent(n.dataset.type);r=r?JSON.parse(r):{};var c=e.querySelector("div").clientHeight,l="react"===s?function(n,e){var t=(0,window.Babel.transform)(n,{presets:["es2015","react"]}).code,o="(function(exports){var module={};module.exports=exports;".concat(t,";return module.exports.__esModule?module.exports.default:module.exports;})({})"),a=new Function("return ".concat(o))(),i={js:a,css:a.__style__||"",jsLib:e.jsLib||[],cssLib:e.cssLib||[],jsTpl:$s(n),htmlTpl:Is("")},r=js("react"),s=js("reactDOM");return i.jsLib.unshift(r,s),i}(i,r):"vanilla"===s?Os(i,r):Ms(i,r),d=Ps("button",{className:"".concat("vuepress-plugin-demo-block__expand")});if(o.appendChild(d),d.addEventListener("click",Ls.bind(null,d,c,e,o)),js("jsfiddle")&&o.appendChild(function(n){var e=n.css,t=n.htmlTpl,o=n.jsTpl,a=n.jsLib,i=n.cssLib,r=a.concat(i).concat(js("cssLib")).concat(js("jsLib")).join(",");return Ps("form",{className:"vuepress-plugin-demo-block__jsfiddle",target:"_blank",action:"https://jsfiddle.net/api/post/library/pure/",method:"post"},[{tag:"input",attrs:{type:"hidden",name:"css",value:e}},{tag:"input",attrs:{type:"hidden",name:"html",value:t}},{tag:"input",attrs:{type:"hidden",name:"js",value:o}},{tag:"input",attrs:{type:"hidden",name:"panel_js",value:3}},{tag:"input",attrs:{type:"hidden",name:"wrap",value:1}},{tag:"input",attrs:{type:"hidden",name:"resources",value:r}},{tag:"button",attrs:{type:"submit",className:"vuepress-plugin-demo-block__button",innerHTML:'<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088289967" class="icon" style="" viewBox="0 0 1170 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1952" xmlns:xlink="http://www.w3.org/1999/xlink" width="228.515625" height="200"><defs><style type="text/css"></style></defs><path d="M1028.571429 441.142857q63.428571 26.285714 102.571428 83.142857T1170.285714 650.857143q0 93.714286-67.428571 160.285714T940 877.714286q-2.285714 0-6.571429-0.285715t-6-0.285714H232q-97.142857-5.714286-164.571429-71.714286T0 645.142857q0-62.857143 31.428571-116t84-84q-6.857143-22.285714-6.857142-46.857143 0-65.714286 46.857142-112t113.714286-46.285714q54.285714 0 98.285714 33.142857 42.857143-88 127.142858-141.714286t186.571428-53.714285q94.857143 0 174.857143 46T982.571429 248.571429t46.571428 172q0 3.428571-0.285714 10.285714t-0.285714 10.285714zM267.428571 593.142857q0 69.714286 48 110.285714t118.857143 40.571429q78.285714 0 137.142857-56.571429-9.142857-11.428571-27.142857-32.285714T519.428571 626.285714q-38.285714 37.142857-82.285714 37.142857-31.428571 0-53.428571-19.142857T361.714286 594.285714q0-30.285714 22-49.714285t52.285714-19.428572q25.142857 0 48.285714 12t41.714286 31.428572 37.142857 42.857142 39.428572 46.857143 44 42.857143 55.428571 31.428572 69.428571 12q69.142857 0 116.857143-40.857143T936 594.857143q0-69.142857-48-109.714286t-118.285714-40.571428q-81.714286 0-137.714286 55.428571l53.142857 61.714286q37.714286-36.571429 81.142857-36.571429 29.714286 0 52.571429 18.857143t22.857143 48q0 32.571429-21.142857 52.285714t-53.714286 19.714286q-24.571429 0-47.142857-12t-41.142857-31.428571-37.428572-42.857143-39.714286-46.857143-44.285714-42.857143-55.142857-31.428571T434.285714 444.571429q-69.714286 0-118.285714 40.285714T267.428571 593.142857z" p-id="1953"></path></svg>',datatip:"JSFiddle"}}])}(l)),js("codepen")&&o.appendChild(function(n){var e=n.css,t=n.htmlTpl,o=n.jsTpl,a=n.jsLib,i=n.cssLib,r=JSON.stringify({css:e,html:t,js:o,js_external:a.concat(js("jsLib")).join(";"),css_external:i.concat(js("cssLib")).join(";"),layout:js("codepenLayout"),js_pre_processor:js("codepenJsProcessor"),editors:js("codepenEditors")});return Ps("form",{className:"vuepress-plugin-demo-block__codepen",target:"_blank",action:"https://codepen.io/pen/define",method:"post"},[{tag:"input",attrs:{type:"hidden",name:"data",value:r}},{tag:"button",attrs:{type:"submit",innerHTML:'<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088271207" class="icon" style="" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1737" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="200"><defs><style type="text/css"></style></defs><path d="M123.428571 668l344.571429 229.714286v-205.142857L277.142857 565.142857z m-35.428571-82.285714l110.285714-73.714286-110.285714-73.714286v147.428572z m468 312l344.571429-229.714286-153.714286-102.857143-190.857143 127.428572v205.142857z m-44-281.714286l155.428571-104-155.428571-104-155.428571 104zM277.142857 458.857143l190.857143-127.428572V126.285714L123.428571 356z m548.571429 53.142857l110.285714 73.714286V438.285714z m-78.857143-53.142857l153.714286-102.857143-344.571429-229.714286v205.142857z m277.142857-102.857143v312q0 23.428571-19.428571 36.571429l-468 312q-12 7.428571-24.571429 7.428571t-24.571429-7.428571L19.428571 704.571429q-19.428571-13.142857-19.428571-36.571429V356q0-23.428571 19.428571-36.571429L487.428571 7.428571q12-7.428571 24.571429-7.428571t24.571429 7.428571l468 312q19.428571 13.142857 19.428571 36.571429z" p-id="1738"></path></svg>',className:"vuepress-plugin-demo-block__button",datatip:"Codepen"}}])}(l)),void 0!==r.horizontal?r.horizontal:js("horizontal")){n.classList.add("vuepress-plugin-demo-block__horizontal");var p=e.firstChild.cloneNode(!0);p.classList.add("vuepress-plugin-demo-block__h_code"),t.appendChild(p)}if(l.css&&function(n){if(!As[n]){var e=Ps("style",{innerHTML:n});document.body.appendChild(e),As[n]=!0}}(l.css),"react"===s)ReactDOM.render(React.createElement(l.js),a);else if("vue"===s){var u=(new(Vue.extend(l.script))).$mount();a.appendChild(u.$el)}else"vanilla"===s&&(a.innerHTML=l.html,new Function("return (function(){".concat(l.script,"})()"))());n.dataset.created="true"}})):setTimeout((function(n){Bs()}),300)}function Ls(n,e,t,o){var a="1"!==n.dataset.isExpand;t.style.height=a?"".concat(e,"px"):0,a?o.classList.add("vuepress-plugin-demo-block__show-link"):o.classList.remove("vuepress-plugin-demo-block__show-link"),n.dataset.isExpand=a?"1":"0"}var Us={mounted:function(){window.$VUEPRESS_DEMO_BLOCK={jsfiddle:!1,codepen:!0,horizontal:!1},Bs()},updated:function(){Bs()}},Ds="auto",Ws="zoom-in",Rs="zoom-out",Ns="grab",Gs="move";function Hs(n,e,t){var o=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],a={passive:!1};o?n.addEventListener(e,t,a):n.removeEventListener(e,t,a)}function Fs(n,e){if(n){var t=new Image;t.onload=function(){e&&e(t)},t.src=n}}function qs(n){return n.dataset.original?n.dataset.original:"A"===n.parentNode.tagName?n.parentNode.getAttribute("href"):null}function Vs(n,e,t){!function(n){var e=Xs,t=Ks;if(n.transition){var o=n.transition;delete n.transition,n[e]=o}if(n.transform){var a=n.transform;delete n.transform,n[t]=a}}(e);var o=n.style,a={};for(var i in e)t&&(a[i]=o[i]||""),o[i]=e[i];return a}var Xs="transition",Ks="transform",Zs="transform",Js="transitionend";var Ys=function(){},Qs={enableGrab:!0,preloadImage:!1,closeOnWindowResize:!0,transitionDuration:.4,transitionTimingFunction:"cubic-bezier(0.4, 0, 0, 1)",bgColor:"rgb(255, 255, 255)",bgOpacity:1,scaleBase:1,scaleExtra:.5,scrollThreshold:40,zIndex:998,customSize:null,onOpen:Ys,onClose:Ys,onGrab:Ys,onMove:Ys,onRelease:Ys,onBeforeOpen:Ys,onBeforeClose:Ys,onBeforeGrab:Ys,onBeforeRelease:Ys,onImageLoading:Ys,onImageLoaded:Ys},nc={init:function(n){var e,t;e=this,t=n,Object.getOwnPropertyNames(Object.getPrototypeOf(e)).forEach((function(n){e[n]=e[n].bind(t)}))},click:function(n){if(n.preventDefault(),tc(n))return window.open(this.target.srcOriginal||n.currentTarget.src,"_blank");this.shown?this.released?this.close():this.release():this.open(n.currentTarget)},scroll:function(){var n=document.documentElement||document.body.parentNode||document.body,e=window.pageXOffset||n.scrollLeft,t=window.pageYOffset||n.scrollTop;null===this.lastScrollPosition&&(this.lastScrollPosition={x:e,y:t});var o=this.lastScrollPosition.x-e,a=this.lastScrollPosition.y-t,i=this.options.scrollThreshold;(Math.abs(a)>=i||Math.abs(o)>=i)&&(this.lastScrollPosition=null,this.close())},keydown:function(n){(function(n){return"Escape"===(n.key||n.code)||27===n.keyCode})(n)&&(this.released?this.close():this.release(this.close))},mousedown:function(n){if(ec(n)&&!tc(n)){n.preventDefault();var e=n.clientX,t=n.clientY;this.pressTimer=setTimeout(function(){this.grab(e,t)}.bind(this),200)}},mousemove:function(n){this.released||this.move(n.clientX,n.clientY)},mouseup:function(n){ec(n)&&!tc(n)&&(clearTimeout(this.pressTimer),this.released?this.close():this.release())},touchstart:function(n){n.preventDefault();var e=n.touches[0],t=e.clientX,o=e.clientY;this.pressTimer=setTimeout(function(){this.grab(t,o)}.bind(this),200)},touchmove:function(n){if(!this.released){var e=n.touches[0],t=e.clientX,o=e.clientY;this.move(t,o)}},touchend:function(n){(function(n){n.targetTouches.length})(n)||(clearTimeout(this.pressTimer),this.released?this.close():this.release())},clickOverlay:function(){this.close()},resizeWindow:function(){this.close()}};function ec(n){return 0===n.button}function tc(n){return n.metaKey||n.ctrlKey}var oc={init:function(n){this.el=document.createElement("div"),this.instance=n,this.parent=document.body,Vs(this.el,{position:"fixed",top:0,left:0,right:0,bottom:0,opacity:0}),this.updateStyle(n.options),Hs(this.el,"click",n.handler.clickOverlay.bind(n))},updateStyle:function(n){Vs(this.el,{zIndex:n.zIndex,backgroundColor:n.bgColor,transition:"opacity\n        "+n.transitionDuration+"s\n        "+n.transitionTimingFunction})},insert:function(){this.parent.appendChild(this.el)},remove:function(){this.parent.removeChild(this.el)},fadeIn:function(){this.el.offsetWidth,this.el.style.opacity=this.instance.options.bgOpacity},fadeOut:function(){this.el.style.opacity=0}},ac="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},ic=function(){function n(n,e){for(var t=0;t<e.length;t++){var o=e[t];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(n,o.key,o)}}return function(e,t,o){return t&&n(e.prototype,t),o&&n(e,o),e}}(),rc=Object.assign||function(n){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var o in t)Object.prototype.hasOwnProperty.call(t,o)&&(n[o]=t[o])}return n},sc={init:function(n,e){this.el=n,this.instance=e,this.srcThumbnail=this.el.getAttribute("src"),this.srcset=this.el.getAttribute("srcset"),this.srcOriginal=qs(this.el),this.rect=this.el.getBoundingClientRect(),this.translate=null,this.scale=null,this.styleOpen=null,this.styleClose=null},zoomIn:function(){var n=this.instance.options,e=n.zIndex,t=n.enableGrab,o=n.transitionDuration,a=n.transitionTimingFunction;this.translate=this.calculateTranslate(),this.scale=this.calculateScale(),this.styleOpen={position:"relative",zIndex:e+1,cursor:t?Ns:Rs,transition:Zs+"\n        "+o+"s\n        "+a,transform:"translate3d("+this.translate.x+"px, "+this.translate.y+"px, 0px)\n        scale("+this.scale.x+","+this.scale.y+")",height:this.rect.height+"px",width:this.rect.width+"px"},this.el.offsetWidth,this.styleClose=Vs(this.el,this.styleOpen,!0)},zoomOut:function(){this.el.offsetWidth,Vs(this.el,{transform:"none"})},grab:function(n,e,t){var o=cc(),a=o.x-n,i=o.y-e;Vs(this.el,{cursor:Gs,transform:"translate3d(\n        "+(this.translate.x+a)+"px, "+(this.translate.y+i)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},move:function(n,e,t){var o=cc(),a=o.x-n,i=o.y-e;Vs(this.el,{transition:Zs,transform:"translate3d(\n        "+(this.translate.x+a)+"px, "+(this.translate.y+i)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},restoreCloseStyle:function(){Vs(this.el,this.styleClose)},restoreOpenStyle:function(){Vs(this.el,this.styleOpen)},upgradeSource:function(){if(this.srcOriginal){var n=this.el.parentNode;this.srcset&&this.el.removeAttribute("srcset");var e=this.el.cloneNode(!1);e.setAttribute("src",this.srcOriginal),e.style.position="fixed",e.style.visibility="hidden",n.appendChild(e),setTimeout(function(){this.el.setAttribute("src",this.srcOriginal),n.removeChild(e)}.bind(this),50)}},downgradeSource:function(){this.srcOriginal&&(this.srcset&&this.el.setAttribute("srcset",this.srcset),this.el.setAttribute("src",this.srcThumbnail))},calculateTranslate:function(){var n=cc(),e=this.rect.left+this.rect.width/2,t=this.rect.top+this.rect.height/2;return{x:n.x-e,y:n.y-t}},calculateScale:function(){var n=this.el.dataset,e=n.zoomingHeight,t=n.zoomingWidth,o=this.instance.options,a=o.customSize,i=o.scaleBase;if(!a&&e&&t)return{x:t/this.rect.width,y:e/this.rect.height};if(a&&"object"===(void 0===a?"undefined":ac(a)))return{x:a.width/this.rect.width,y:a.height/this.rect.height};var r=this.rect.width/2,s=this.rect.height/2,c=cc(),l={x:c.x-r,y:c.y-s},d=l.x/r,p=l.y/s,u=i+Math.min(d,p);if(a&&"string"==typeof a){var h=t||this.el.naturalWidth,m=e||this.el.naturalHeight,f=parseFloat(a)*h/(100*this.rect.width),g=parseFloat(a)*m/(100*this.rect.height);if(u>f||u>g)return{x:f,y:g}}return{x:u,y:u}}};function cc(){var n=document.documentElement;return{x:Math.min(n.clientWidth,window.innerWidth)/2,y:Math.min(n.clientHeight,window.innerHeight)/2}}function lc(n,e,t){["mousedown","mousemove","mouseup","touchstart","touchmove","touchend"].forEach((function(o){Hs(n,o,e[o],t)}))}var dc=function(){function n(e){!function(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}(this,n),this.target=Object.create(sc),this.overlay=Object.create(oc),this.handler=Object.create(nc),this.body=document.body,this.shown=!1,this.lock=!1,this.released=!0,this.lastScrollPosition=null,this.pressTimer=null,this.options=rc({},Qs,e),this.overlay.init(this),this.handler.init(this)}return ic(n,[{key:"listen",value:function(n){if("string"==typeof n)for(var e=document.querySelectorAll(n),t=e.length;t--;)this.listen(e[t]);else"IMG"===n.tagName&&(n.style.cursor=Ws,Hs(n,"click",this.handler.click),this.options.preloadImage&&Fs(qs(n)));return this}},{key:"config",value:function(n){return n?(rc(this.options,n),this.overlay.updateStyle(this.options),this):this.options}},{key:"open",value:function(n){var e=this,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.options.onOpen;if(!this.shown&&!this.lock){var o="string"==typeof n?document.querySelector(n):n;if("IMG"===o.tagName){if(this.options.onBeforeOpen(o),this.target.init(o,this),!this.options.preloadImage){var a=this.target.srcOriginal;null!=a&&(this.options.onImageLoading(o),Fs(a,this.options.onImageLoaded))}this.shown=!0,this.lock=!0,this.target.zoomIn(),this.overlay.insert(),this.overlay.fadeIn(),Hs(document,"scroll",this.handler.scroll),Hs(document,"keydown",this.handler.keydown),this.options.closeOnWindowResize&&Hs(window,"resize",this.handler.resizeWindow);var i=function n(){Hs(o,Js,n,!1),e.lock=!1,e.target.upgradeSource(),e.options.enableGrab&&lc(document,e.handler,!0),t(o)};return Hs(o,Js,i),this}}}},{key:"close",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onClose;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeClose(t),this.lock=!0,this.body.style.cursor=Ds,this.overlay.fadeOut(),this.target.zoomOut(),Hs(document,"scroll",this.handler.scroll,!1),Hs(document,"keydown",this.handler.keydown,!1),this.options.closeOnWindowResize&&Hs(window,"resize",this.handler.resizeWindow,!1);var o=function o(){Hs(t,Js,o,!1),n.shown=!1,n.lock=!1,n.target.downgradeSource(),n.options.enableGrab&&lc(document,n.handler,!1),n.target.restoreCloseStyle(),n.overlay.remove(),e(t)};return Hs(t,Js,o),this}}},{key:"grab",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onGrab;if(this.shown&&!this.lock){var a=this.target.el;this.options.onBeforeGrab(a),this.released=!1,this.target.grab(n,e,t);var i=function n(){Hs(a,Js,n,!1),o(a)};return Hs(a,Js,i),this}}},{key:"move",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onMove;if(this.shown&&!this.lock){this.released=!1,this.body.style.cursor=Gs,this.target.move(n,e,t);var a=this.target.el,i=function n(){Hs(a,Js,n,!1),o(a)};return Hs(a,Js,i),this}}},{key:"release",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onRelease;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeRelease(t),this.lock=!0,this.body.style.cursor=Ds,this.target.restoreOpenStyle();var o=function o(){Hs(t,Js,o,!1),n.lock=!1,n.released=!0,e(t)};return Hs(t,Js,o),this}}}]),n}();const pc=JSON.parse('{"bgColor":"rgba(0,0,0,0.6)"}'),uc=Number("500");class hc{constructor(){this.instance=new dc(pc)}update(n=".theme-vdoing-content img:not(.no-zoom)"){"undefined"!=typeof window&&this.instance.listen(n)}updateDelay(n=".theme-vdoing-content img:not(.no-zoom)",e=uc){setTimeout(()=>this.update(n),e)}}var mc=[fs,ks,_s,Es,Us,{watch:{"$page.path"(){void 0!==this.$vuepress.zooming&&this.$vuepress.zooming.updateDelay()}},mounted(){this.$vuepress.zooming=new hc,this.$vuepress.zooming.updateDelay()}}],fc={name:"GlobalLayout",computed:{layout(){const n=this.getLayout();return ds("layout",n),Ft.component(n)}},methods:{getLayout(){if(this.$page.path){const n=this.$page.frontmatter.layout;return n&&(this.$vuepress.getLayoutAsyncComponent(n)||this.$vuepress.getVueComponent(n))?n:"Layout"}return"NotFound"}}},gc=t(6),yc=Object(gc.a)(fc,(function(){return(0,this._self._c)(this.layout,{tag:"component"})}),[],!1,null,null,null).exports;!function(n,e,t){switch(e){case"components":n[e]||(n[e]={}),Object.assign(n[e],t);break;case"mixins":n[e]||(n[e]=[]),n[e].push(...t);break;default:throw new Error("Unknown option name.")}}(yc,"mixins",mc);const vc=[{name:"v-59ee63fe",path:"/pages/a2f161/",component:yc,beforeEnter:(n,e,t)=>{ls("Layout","v-59ee63fe").then(t)}},{path:"/pages/a2f161/index.html",redirect:"/pages/a2f161/"},{path:"/01.指南/01.ETBbook_中文/01.介绍.html",redirect:"/pages/a2f161/"},{name:"v-77c5ce9c",path:"/pages/52d5c3/",component:yc,beforeEnter:(n,e,t)=>{ls("Layout","v-77c5ce9c").then(t)}},{path:"/pages/52d5c3/index.html",redirect:"/pages/52d5c3/"},{path:"/01.指南/01.ETBbook_中文/02.1.1运行指南.html",redirect:"/pages/52d5c3/"},{name:"v-6a22f932",path:"/pages/ff62ec/",component:yc,beforeEnter:(n,e,t)=>{ls("Layout","v-6a22f932").then(t)}},{path:"/pages/ff62ec/index.html",redirect:"/pages/ff62ec/"},{path:"/01.指南/01.ETBbook_中文/03.目录结构.html",redirect:"/pages/ff62ec/"},{name:"v-455f0d94",path:"/pages/f62a4d/",component:yc,beforeEnter:(n,e,t)=>{ls("Layout","v-455f0d94").then(t)}},{path:"/pages/f62a4d/index.html",redirect:"/pages/f62a4d/"},{path:"/01.指南/01.ETBbook_中文/12.1.2为什么使用.net core.html",redirect:"/pages/f62a4d/"},{name:"v-3dac3e03",path:"/pages/500d39/",component:yc,beforeEnter:(n,e,t)=>{ls("Layout","v-3dac3e03").then(t)}},{path:"/pages/500d39/index.html",redirect:"/pages/500d39/"},{path:"/01.指南/01.ETBbook_中文/21.2.1CSharp的协程.html",redirect:"/pages/500d39/"},{name:"v-15a9f55e",path:"/pages/0f0a88/",component:yc,beforeEnter:(n,e,t)=>{ls("Layout","v-15a9f55e").then(t)}},{path:"/pages/0f0a88/index.html",redirect:"/pages/0f0a88/"},{path:"/01.指南/01.ETBbook_中文/22.2.2更好的协程.html",redirect:"/pages/0f0a88/"},{name:"v-72b8a039",path:"/pages/d3ef38/",component:yc,beforeEnter:(n,e,t)=>{ls("Layout","v-72b8a039").then(t)}},{path:"/pages/d3ef38/index.html",redirect:"/pages/d3ef38/"},{path:"/01.指南/01.ETBbook_中文/23.2.3单线程异步.html",redirect:"/pages/d3ef38/"},{name:"v-7d704a16",path:"/pages/037ea6/",component:yc,beforeEnter:(n,e,t)=>{ls("Layout","v-7d704a16").then(t)}},{path:"/pages/037ea6/index.html",redirect:"/pages/037ea6/"},{path:"/01.指南/01.ETBbook_中文/32.3.2强大的MongoBson库.html",redirect:"/pages/037ea6/"},{name:"v-18a6fca4",path:"/pages/81bdb3/",component:yc,beforeEnter:(n,e,t)=>{ls("Layout","v-18a6fca4").then(t)}},{path:"/pages/81bdb3/index.html",redirect:"/pages/81bdb3/"},{path:"/01.指南/01.ETBbook_中文/33.3.3一切皆组件.html",redirect:"/pages/81bdb3/"},{name:"v-1dc56f77",path:"/pages/c77b6a/",component:yc,beforeEnter:(n,e,t)=>{ls("Layout","v-1dc56f77").then(t)}},{path:"/pages/c77b6a/index.html",redirect:"/pages/c77b6a/"},{path:"/01.指南/01.ETBbook_中文/34.3.3一切皆实体.html",redirect:"/pages/c77b6a/"},{name:"v-3ce102e1",path:"/pages/e49330/",component:yc,beforeEnter:(n,e,t)=>{ls("Layout","v-3ce102e1").then(t)}},{path:"/pages/e49330/index.html",redirect:"/pages/e49330/"},{path:"/01.指南/01.ETBbook_中文/35.3.4事件机制EventSystem.html",redirect:"/pages/e49330/"},{name:"v-3d087b67",path:"/pages/002c9b/",component:yc,beforeEnter:(n,e,t)=>{ls("Layout","v-3d087b67").then(t)}},{path:"/pages/002c9b/index.html",redirect:"/pages/002c9b/"},{path:"/01.指南/01.ETBbook_中文/41.4.1组件式设计.html",redirect:"/pages/002c9b/"},{name:"v-e0ad2bb2",path:"/pages/96869e/",component:yc,beforeEnter:(n,e,t)=>{ls("Layout","v-e0ad2bb2").then(t)}},{path:"/pages/96869e/index.html",redirect:"/pages/96869e/"},{path:"/01.指南/01.ETBbook_中文/54.5.4Actor模型.html",redirect:"/pages/96869e/"},{name:"v-973514f8",path:"/pages/9f7296/",component:yc,beforeEnter:(n,e,t)=>{ls("Layout","v-973514f8").then(t)}},{path:"/pages/9f7296/index.html",redirect:"/pages/9f7296/"},{path:"/01.指南/01.ETBbook_中文/55.5.5Actor Location-ZH.html",redirect:"/pages/9f7296/"},{name:"v-2c9acafa",path:"/pages/1dc51a/",component:yc,beforeEnter:(n,e,t)=>{ls("Layout","v-2c9acafa").then(t)}},{path:"/pages/1dc51a/index.html",redirect:"/pages/1dc51a/"},{path:"/01.指南/01.ETBbook_中文/56.5.6数值组件设计.html",redirect:"/pages/1dc51a/"},{name:"v-5d10c0ed",path:"/pages/d9bb29/",component:yc,beforeEnter:(n,e,t)=>{ls("Layout","v-5d10c0ed").then(t)}},{path:"/pages/d9bb29/index.html",redirect:"/pages/d9bb29/"},{path:"/01.指南/01.ETBbook_中文/61.6.1AI框架.html",redirect:"/pages/d9bb29/"},{name:"v-50562bab",path:"/pages/1e1b9a/",component:yc,beforeEnter:(n,e,t)=>{ls("Layout","v-50562bab").then(t)}},{path:"/pages/1e1b9a/index.html",redirect:"/pages/1e1b9a/"},{path:"/02.Guide/01.ETBook_English/02.1.1RunGuide.html",redirect:"/pages/1e1b9a/"},{name:"v-640dd7dc",path:"/pages/f9f601/",component:yc,beforeEnter:(n,e,t)=>{ls("Layout","v-640dd7dc").then(t)}},{path:"/pages/f9f601/index.html",redirect:"/pages/f9f601/"},{path:"/02.Guide/01.ETBook_English/12.1.2Why use .net core.html",redirect:"/pages/f9f601/"},{name:"v-17cedb24",path:"/pages/97d2cf/",component:yc,beforeEnter:(n,e,t)=>{ls("Layout","v-17cedb24").then(t)}},{path:"/pages/97d2cf/index.html",redirect:"/pages/97d2cf/"},{path:"/02.Guide/01.ETBook_English/21.2.1CSharp Coroutine.html",redirect:"/pages/97d2cf/"},{name:"v-58f5998e",path:"/pages/e03bce/",component:yc,beforeEnter:(n,e,t)=>{ls("Layout","v-58f5998e").then(t)}},{path:"/pages/e03bce/index.html",redirect:"/pages/e03bce/"},{path:"/02.Guide/01.ETBook_English/22.2.2Better Coroutine.html",redirect:"/pages/e03bce/"},{name:"v-4ed835a8",path:"/pages/735741/",component:yc,beforeEnter:(n,e,t)=>{ls("Layout","v-4ed835a8").then(t)}},{path:"/pages/735741/index.html",redirect:"/pages/735741/"},{path:"/02.Guide/01.ETBook_English/23.2.3Single-threaded asynchronous.html",redirect:"/pages/735741/"},{name:"v-3bf5446e",path:"/pages/947d76/",component:yc,beforeEnter:(n,e,t)=>{ls("Layout","v-3bf5446e").then(t)}},{path:"/pages/947d76/index.html",redirect:"/pages/947d76/"},{path:"/02.Guide/01.ETBook_English/32.3.2The powerful MongoBson library.html",redirect:"/pages/947d76/"},{name:"v-49b0f2aa",path:"/pages/b631b2/",component:yc,beforeEnter:(n,e,t)=>{ls("Layout","v-49b0f2aa").then(t)}},{path:"/pages/b631b2/index.html",redirect:"/pages/b631b2/"},{path:"/02.Guide/01.ETBook_English/33.3.3Everything is Entity.html",redirect:"/pages/b631b2/"},{name:"v-3bddb7a2",path:"/pages/53296b/",component:yc,beforeEnter:(n,e,t)=>{ls("Layout","v-3bddb7a2").then(t)}},{path:"/pages/53296b/index.html",redirect:"/pages/53296b/"},{path:"/02.Guide/01.ETBook_English/35.3.4EventSystem.html",redirect:"/pages/53296b/"},{name:"v-fdfe0ef0",path:"/pages/66fec6/",component:yc,beforeEnter:(n,e,t)=>{ls("Layout","v-fdfe0ef0").then(t)}},{path:"/pages/66fec6/index.html",redirect:"/pages/66fec6/"},{path:"/02.Guide/01.ETBook_English/41.4.1Component-based design.html",redirect:"/pages/66fec6/"},{name:"v-075f2a06",path:"/pages/a3279e/",component:yc,beforeEnter:(n,e,t)=>{ls("Layout","v-075f2a06").then(t)}},{path:"/pages/a3279e/index.html",redirect:"/pages/a3279e/"},{path:"/02.Guide/01.ETBook_English/54.5.4Actor Model.html",redirect:"/pages/a3279e/"},{name:"v-0d66cacc",path:"/pages/d00821/",component:yc,beforeEnter:(n,e,t)=>{ls("Layout","v-0d66cacc").then(t)}},{path:"/pages/d00821/index.html",redirect:"/pages/d00821/"},{path:"/02.Guide/01.ETBook_English/55.5.5Actor Location-EN.html",redirect:"/pages/d00821/"},{name:"v-0cd550e5",path:"/pages/ae8fe0/",component:yc,beforeEnter:(n,e,t)=>{ls("Layout","v-0cd550e5").then(t)}},{path:"/pages/ae8fe0/index.html",redirect:"/pages/ae8fe0/"},{path:"/02.Guide/01.ETBook_English/56.5.6Numerical component design.html",redirect:"/pages/ae8fe0/"},{name:"v-4d16eb48",path:"/pages/58cf5c/",component:yc,beforeEnter:(n,e,t)=>{ls("Layout","v-4d16eb48").then(t)}},{path:"/pages/58cf5c/index.html",redirect:"/pages/58cf5c/"},{path:"/02.Guide/01.ETBook_English/61.6.1.AI Framwork.html",redirect:"/pages/58cf5c/"},{name:"v-708b622a",path:"/pages/b70448/",component:yc,beforeEnter:(n,e,t)=>{ls("Layout","v-708b622a").then(t)}},{path:"/pages/b70448/index.html",redirect:"/pages/b70448/"},{path:"/02.Guide/01.ETBook_English/98.test2.html",redirect:"/pages/b70448/"},{name:"v-8d136732",path:"/pages/578b97/",component:yc,beforeEnter:(n,e,t)=>{ls("Layout","v-8d136732").then(t)}},{path:"/pages/578b97/index.html",redirect:"/pages/578b97/"},{path:"/02.Guide/01.ETBook_English/99.test.html",redirect:"/pages/578b97/"},{name:"v-96f85bb2",path:"/doc/todo/",component:yc,beforeEnter:(n,e,t)=>{ls("Layout","v-96f85bb2").then(t)}},{path:"/doc/todo/index.html",redirect:"/doc/todo/"},{path:"/30.文档/01.Todo.html",redirect:"/doc/todo/"},{name:"v-5b320bc2",path:"/doc/todo_en/",component:yc,beforeEnter:(n,e,t)=>{ls("Layout","v-5b320bc2").then(t)}},{path:"/doc/todo_en/index.html",redirect:"/doc/todo_en/"},{path:"/31.Doc/01.Todo.html",redirect:"/doc/todo_en/"},{name:"v-4ec77c26",path:"/doc/notes/",component:yc,beforeEnter:(n,e,t)=>{ls("Layout","v-4ec77c26").then(t)}},{path:"/doc/notes/index.html",redirect:"/doc/notes/"},{path:"/99.文档编写/01.文档仓库提交说明.html",redirect:"/doc/notes/"},{name:"v-36c869aa",path:"/blog/",component:yc,beforeEnter:(n,e,t)=>{ls("Layout","v-36c869aa").then(t)}},{path:"/blog/index.html",redirect:"/blog/"},{path:"/@pages/archivesPage.html",redirect:"/blog/"},{name:"v-7d4c8dc4",path:"/",component:yc,beforeEnter:(n,e,t)=>{ls("Layout","v-7d4c8dc4").then(t)}},{path:"/index.html",redirect:"/"},{path:"*",component:yc}],bc={title:"ET",description:"ET是一个开源的游戏客户端基于『unity3d』服务端双端框架",base:"/",headTags:[["link",{rel:"icon",href:"/img/logo1.png"}],["meta",{name:"keywords",content:"ET,et,game,framework,ECS,Server"}],["meta",{name:"theme-color",content:"#11a8cd"}]],pages:[{title:"介绍",frontmatter:{title:"介绍",date:"2020-05-11T13:54:03.000Z",permalink:"/pages/a2f161",article:!1},regularPath:"/01.%E6%8C%87%E5%8D%97/01.ETBbook_%E4%B8%AD%E6%96%87/01.%E4%BB%8B%E7%BB%8D.html",relativePath:"01.指南/01.ETBbook_中文/01.介绍.md",key:"v-59ee63fe",path:"/pages/a2f161/",headers:[{level:3,title:"1.可用VS单步调试的分布式服务端，N变1",slug:"_1-可用vs单步调试的分布式服务端-n变1",normalizedTitle:"1.可用vs单步调试的分布式服务端，n变1",charIndex:1521},{level:3,title:"2.随意可拆分功能的分布式服务端，1变N",slug:"_2-随意可拆分功能的分布式服务端-1变n",normalizedTitle:"2.随意可拆分功能的分布式服务端，1变n",charIndex:1973},{level:3,title:"3.跨平台的分布式服务端",slug:"_3-跨平台的分布式服务端",normalizedTitle:"3.跨平台的分布式服务端",charIndex:2343},{level:3,title:"4.提供协程支持",slug:"_4-提供协程支持",normalizedTitle:"4.提供协程支持",charIndex:2643},{level:3,title:"5.提供类似erlang的actor消息机制",slug:"_5-提供类似erlang的actor消息机制",normalizedTitle:"5.提供类似erlang的actor消息机制",charIndex:3175},{level:3,title:"6.提供服务器不停服动态更新逻辑功能",slug:"_6-提供服务器不停服动态更新逻辑功能",normalizedTitle:"6.提供服务器不停服动态更新逻辑功能",charIndex:3510},{level:3,title:"7.客户端使用C#热更新，热更新一键切换",slug:"_7-客户端使用c-热更新-热更新一键切换",normalizedTitle:"7.客户端使用c#热更新，热更新一键切换",charIndex:3625},{level:3,title:"8.客户端热重载",slug:"_8-客户端热重载",normalizedTitle:"8.客户端热重载",charIndex:3735},{level:3,title:"9.客户端服务端用同一种语言，并且共享代码",slug:"_9-客户端服务端用同一种语言-并且共享代码",normalizedTitle:"9.客户端服务端用同一种语言，并且共享代码",charIndex:3777},{level:3,title:"10.KCP ENET TCP Websocket协议无缝切换",slug:"_10-kcp-enet-tcp-websocket协议无缝切换",normalizedTitle:"10.kcp enet tcp websocket协议无缝切换",charIndex:3902},{level:3,title:"11. 3D Recast寻路功能",slug:"_11-3d-recast寻路功能",normalizedTitle:"11. 3d recast寻路功能",charIndex:4162},{level:3,title:"12. 服务端支持repl，也可以动态执行一段新代码",slug:"_12-服务端支持repl-也可以动态执行一段新代码",normalizedTitle:"12. 服务端支持repl，也可以动态执行一段新代码",charIndex:4239},{level:3,title:"13.提供客户端机器人框架支持",slug:"_13-提供客户端机器人框架支持",normalizedTitle:"13.提供客户端机器人框架支持",charIndex:4342},{level:3,title:"14.AI框架",slug:"_14-ai框架",normalizedTitle:"14.ai框架",charIndex:4426},{level:3,title:"15.测试用例框架",slug:"_15-测试用例框架",normalizedTitle:"15.测试用例框架",charIndex:4458},{level:3,title:"16.还有很多很多功能，我就不详细介绍了",slug:"_16-还有很多很多功能-我就不详细介绍了",normalizedTitle:"16.还有很多很多功能，我就不详细介绍了",charIndex:4533}],headersStr:"1.可用VS单步调试的分布式服务端，N变1 2.随意可拆分功能的分布式服务端，1变N 3.跨平台的分布式服务端 4.提供协程支持 5.提供类似erlang的actor消息机制 6.提供服务器不停服动态更新逻辑功能 7.客户端使用C#热更新，热更新一键切换 8.客户端热重载 9.客户端服务端用同一种语言，并且共享代码 10.KCP ENET TCP Websocket协议无缝切换 11. 3D Recast寻路功能 12. 服务端支持repl，也可以动态执行一段新代码 13.提供客户端机器人框架支持 14.AI框架 15.测试用例框架 16.还有很多很多功能，我就不详细介绍了",content:'English\n\n\n# 讨论QQ群 : 474643097\n\n\n# ET论坛\n\n\n# ET商店\n\n\n# ET6.0视频教程上线\n\n\n# 运行指南\n\n重大注意事项\n\n 1. Hotfix跟HotfixView是纯逻辑的，类中不要带有任何字段，否则热更就会丢失\n 2. ETTask跟要么调用Coroutine要么就await，打开VS中的错误列表窗口，没有使用这两种的会报出问题，虽然既不await也不Coroutine的话能够编译通过，但是会丢失异常，十分危险\n 3. 请不要使用任何虚函数，用逻辑分发替代\n 4. 请不要使用任何继承，除了继承Entity，用组件替代\n\n测试!\n\n\n# ET6 发布！ET6相比ET5有巨大变化，可以说是凤姐变亦菲，6.0拥有如下惊人的特点\n\n 1. 客户端逻辑全热更新（基于ILRuntime），没有不能更的部分\n 2. 客户端服务端均可热重载，开发不用重启客户端服务端即可修改逻辑代码，开发极其方便\n 3. 机器人框架，ET6的客户端的逻辑跟表现分离，机器人程序直接共享利用客户端的逻辑层代码做压测，只需要极少代码即可做出机器人，方便压测服务端\n 4. 测试用例框架，利用客户端的逻辑层代码写单元测试，每个单元测试都是完整的游戏环境，无需各种恶心的mock\n 5. AI框架，比行为树更加方便，写AI比写UI还简单\n 6. 新的服务端架构，极其优美\n 7. 内外网kcp网络，性能强劲，搭配软路由模块，可以防各种网络攻击\n\n\n# ET开发的商业mmo项目千古风流成功上线\n\n> 64核128G内存的单服单物理机1.5W在线（实际线上策划为了生态限制为单服6000人同时在线，6000人的话cpu消耗约为30%）。 为了堆栈行号正常，线上跑得是Debug版，如果使用Release版开启优化，性能还能翻一倍，达到单物理机3W在线！上线5个月来十分稳定。 千古风流使用了ET框架从零开发，用时两年，这个开发速度可以说无人出其右。 千古风流的成功上线证明了ET具备开发任何大型游戏的能力，开发速度，开发效率都令人叹为观止！千古风流使用到的客户端服务器技术：\n\n 1.  动态副本跟分线，按需分配，用完回收\n 2.  分线合线，分线人数较少会把多条线合并。合线功能基本上其它mmo游戏很少见到\n 3.  客户端服务端场景无缝切换，也就是无缝大世界技术\n 4.  跨服副本，跨服战场\n 5.  前后端一体化，利用客户端代码开发服务器压测机器人，4台24核机器轻松模拟1W人做任务\n 6.  千古风流各种ai设计，使用ET的全新开发的ai框架，使ai开发简单到跟写ui一样简单\n 7.  测试用例框架，大部分重要系统，千古风流都写了测试用例，跟市面上的测试用例不同，每个千古风流的测试用例都是一个完整的游戏环境，针对协议级别，不需要搞各种接口去mock。写起来非常快速。\n 8.  九宫格的aoi实现，动态调整看见的玩家，降低服务器负载\n 9.  防攻击，千古风流开发了软路由功能，即使攻击也只能攻击到软路由，一旦被攻击，玩家客户端发现几秒钟无响应，即可动态切换到其它软路由，用户几乎无感知。整个过程客户端网络连接不断开，数据不丢失。\n 10. 还有很多很多，这里就不啰嗦了\n\n\n# ET的介绍：\n\nET是一个开源的游戏客户端（基于unity3d）服务端双端框架，服务端是使用C# .net core开发的分布式游戏服务端，其特点是开发效率高，性能强，双端共享逻辑代码，客户端服务端热更机制完善，同时支持可靠udp tcp websocket协议，支持服务端3D recast寻路等等\n\n\n# ET的功能：\n\n\n# 1.可用VS单步调试的分布式服务端，N变1\n\n一般来说，分布式服务端要启动很多进程，一旦进程多了，单步调试就变得非常困难，导致服务端开发基本上靠打log来查找问题。平常开发游戏逻辑也得开启一大堆进程，不仅启动慢，而且查找问题及其不方便，要在一堆堆日志里面查问题，这感觉非常糟糕，这么多年也没人解决这个问题。ET框架使用了类似守望先锋的组件设计，所有服务端内容都拆成了一个个组件，启动时根据服务器类型挂载自己所需要的组件。这有点类似电脑，电脑都模块化的拆成了内存，CPU，主板等等零件，搭配不同的零件就能组装成一台不同的电脑，例如家用台式机需要内存，CPU，主板，显卡，显示器，硬盘。而公司用的服务器却不需要显示器和显卡，网吧的电脑可能不需要硬盘等。正因为这样的设计，ET框架可以将所有的服务器组件都挂在一个服务器进程上，那么这个服务器进程就有了所有服务器的功能，一个进程就可以作为整组分布式服务器使用。这也类似电脑，台式机有所有的电脑组件，那它也完全可以当作公司服务器使用，也可以当作网吧电脑。\n\n\n# 2.随意可拆分功能的分布式服务端，1变N\n\n分布式服务端要开发多种类型的服务器进程，比如Login server，gate server，battle server，chat server friend server等等一大堆各种server，传统开发方式需要预先知道当前的功能要放在哪个服务器上，当功能越来越多的时候，比如聊天功能之前在一个中心服务器上，之后需要拆出来单独做成一个服务器，这时会牵扯到大量迁移代码的工作，烦不胜烦。ET框架在平常开发的时候根本不太需要关心当前开发的这个功能会放在什么server上，只用一个进程进行开发，功能开发成组件的形式。发布的时候使用一份多进程的配置即可发布成多进程的形式，是不是很方便呢？随便你怎么拆分服务器。只需要修改极少的代码就可以进行拆分。不同的server挂上不同的组件就行了嘛！\n\n\n# 3.跨平台的分布式服务端\n\nET框架使用C#做服务端，现在C#是完全可以跨平台的，在linux上安装.netcore，即可，不需要修改任何代码，就能跑起来。性能方面，现在.netcore的性能非常强，比lua，python，js什么快的多了。做游戏服务端完全不在话下。平常我们开发的时候用VS在windows上开发调试，发布的时候发布到linux上即可。ET框架还提供了一键同步工具，打开unity->tools->rsync同步，即可同步代码到linux上\n\n./Run.sh Config/StartConfig/192.168.12.188.txt \n\n\n1\n\n\n即可编译启动服务器。\n\n\n# 4.提供协程支持\n\nC#天生支持异步变同步语法 async和await，比lua，python的协程强大的多，新版python以及javascript语言甚至照搬了C#的协程语法。分布式服务端大量服务器之间的远程调用，没有异步语法的支持，开发将非常麻烦。所以java没有异步语法，做单服还行，不适合做大型分布式游戏服务端。例如：\n\n// 发送C2R_Ping并且等待响应消息R2C_Ping\nR2C_Ping pong = await session.Call(new C2R_Ping()) as R2C_Ping;\nLog.Debug("收到R2C_Ping");\n\n// 向mongodb查询一个id为1的Player，并且等待返回\nPlayer player = await Game.Scene.GetComponent<DBProxyComponent>().Query<Player>(1);\nLog.Debug($"打印player name: {player.Name}")\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n可以看出，有了async await，所有的服务器间的异步操作将变得非常连贯，不用再拆成多段逻辑。大大简化了分布式服务器开发\n\n\n# 5.提供类似erlang的actor消息机制\n\nerlang语言一大优势就是位置透明的消息机制，用户完全不用关心对象在哪个进程，拿到id就可以对对象发送消息。ET框架也提供了actor消息机制，实体对象只需要挂上MailBoxComponent组件，这个实体对象就成了一个Actor，任何服务器只需要知道这个实体对象的id就可以向其发送消息，完全不用关心这个实体对象在哪个server，在哪台物理机器上。其实现原理也很简单，ET框架提供了一个位置服务器，所有挂载MailBoxComponent的实体对象都会将自己的id跟位置注册到这个位置服务器，其它服务器向这个实体对象发送消息的时候如果不知道这个实体对象的位置，会先去位置服务器查询，查询到位置再进行发送。\n\n\n# 6.提供服务器不停服动态更新逻辑功能\n\n热更是游戏服务器不可缺少的功能，ET框架使用的组件设计，可以做成守望先锋的设计，组件只有成员，无方法，将所有方法做成扩展方法放到热更dll中，运行时重新加载dll即可热更所有逻辑。\n\n\n# 7.客户端使用C#热更新，热更新一键切换\n\n可以使用csharp.lua或者ILRuntime稍加改造即可做客户端热更。再也不用使用狗屎lua了，客户端可以实现所有逻辑热更新，包括协议，config，ui等等。\n\n\n# 8.客户端热重载\n\n开发不用重启客户端即可修改客户端逻辑代码，开发极其方便\n\n\n# 9.客户端服务端用同一种语言，并且共享代码\n\n下载ET框架，打开服务端工程，可以看到服务端引用了客户端很多代码，通过引用客户端代码的方式实现了双端共享代码。例如客户端服务端之间的网络消息两边完全共用一个文件即可，添加一个消息只需要修改一遍。\n\n\n# 10.KCP ENET TCP Websocket协议无缝切换\n\nET框架不但支持TCP，而且支持可靠的UDP协议（ENET跟KCP），ENet是英雄联盟所使用的网络库，其特点是快速，并且网络丢包的情况下性能也非常好，这个我们做过测试TCP在丢包5%的情况下，moba游戏就卡的不行了，但是使用ENet，丢包20%仍然不会感到卡。非常强大。框架还支持使用KCP协议，KCP也是可靠UDP协议，据说比ENET性能更好，使用kcp请注意，需要自己加心跳机制，否则20秒没收到包，服务端将断开连接。协议可以无缝切换。\n\n\n# 11. 3D Recast寻路功能\n\n可以Unity导出场景数据，给服务端做recast寻路。做MMO非常方便，demo演示了服务端3d寻路功能\n\n\n# 12. 服务端支持repl，也可以动态执行一段新代码\n\n这样就可以打印出进程中任何数据，大大简化了服务端查找问题的难度，开启repl方法，直接在console中输入repl回车即可进入repl模式\n\n\n# 13.提供客户端机器人框架支持\n\n几行代码即可创建机器人登录游戏。机器人压测轻而易举，机器人跟正常的玩家完全一样，上线前用机器人做好压测，大大降低上线崩溃几率\n\n\n# 14.AI框架\n\nET的AI框架让AI编写比UI还简单\n\n\n# 15.测试用例框架\n\n跟市面上的测试用例不同，ET的测试用例都是一个完整的游戏环境，针对协议级别，不需要搞各种接口去mock。写起来非常快速\n\n\n# 16.还有很多很多功能，我就不详细介绍了\n\na.及其方便检查CPU占用和内存泄漏检查，vs自带分析工具，不用再为性能和内存泄漏检查而烦恼\nb.使用NLog库，打log及其方便，平常开发时，可以将所有服务器log打到一个文件中，再也不用一个个文件搜索log了\nc.统一使用Mongodb的bson做序列化，消息和配置文件全部都是bson或者json，并且以后使用mongodb做数据库，再也不用做格式转换了。\nd.提供一个同步工具\n\nET框架是一个强大灵活的分布式服务端架构，完全可以满足绝大部分大型游戏需求。使用这套框架，客户端开发者就可以自己完成双端开发，节省大量人力物力，节省大量沟通时间。\n\n相关网站:\nET论坛\n\n群友分享：\n行为树与fgui分支(Duke Chiang开发维护)\nET学习笔记系列(烟雨迷离半世殇写)\nET学习笔记系列(咲夜詩写)\n框架服务端运行流程\nET启动配置\n框架demo介绍\nlinux部署\nlinux部署，mongo安装，资源服搭建\nET框架心跳包组件开发\nET框架Actor使用与心得\n基于ET框架和UGUI的简单UI框架实现（渐渐写）\nET框架笔记 (笑览世界写)\nET框架如何用MAC开发\nET的动态添加事件和触发组件\n\n商业项目:\n\n 1. 千古风流\n 2. 魔法点点2\n 3. 养不大\n 4. 天天躲猫猫2（ios2019春节下载排行19）\n 5. 牛虎棋牌\n 6. 五星麻将\n\n群友demo：\n\n 1. 斗地主（客户端服务端）\n 2. 背包系统\n 3. ET小游戏合集\n\n视频教程：\n字母哥ET6.0教程\n肉饼老师主讲\n官剑铭主讲\nET新手教程-初见主讲 密码: ru1j\nET新手教程新版-初见主讲\nET在Mac上运行指南-L主讲 密码: l3e3\nET框架系列教程-烟雨主讲-6.0版本\n\n.net core 游戏资源分享\n各种dotnet core项目收集\n\n讨论QQ群 : 474643097\n\n\n# 支付宝捐赠\n\n\n\n\n# 友情链接\n\nBox2DSharp box2d的C#移植版，性能很强\nxasset 致力于为 Unity 项目提供了一套 精简稳健 的资源管理环境\nQFramework Your first K.I.S.S Unity3d Framework\nET UI框架 字母哥实现的UI框架，ET风格，各种事件分发\nETCsharpToXLua 字母哥使用csharp.lua实现的ET客户端热更新\net-6-with-ilruntime 烟雨使用ILRuntime实现的ET客户端热更新\nLuban 适用于大中型项目的游戏配置解决方案',normalizedContent:'english\n\n\n# 讨论qq群 : 474643097\n\n\n# et论坛\n\n\n# et商店\n\n\n# et6.0视频教程上线\n\n\n# 运行指南\n\n重大注意事项\n\n 1. hotfix跟hotfixview是纯逻辑的，类中不要带有任何字段，否则热更就会丢失\n 2. ettask跟要么调用coroutine要么就await，打开vs中的错误列表窗口，没有使用这两种的会报出问题，虽然既不await也不coroutine的话能够编译通过，但是会丢失异常，十分危险\n 3. 请不要使用任何虚函数，用逻辑分发替代\n 4. 请不要使用任何继承，除了继承entity，用组件替代\n\n测试!\n\n\n# et6 发布！et6相比et5有巨大变化，可以说是凤姐变亦菲，6.0拥有如下惊人的特点\n\n 1. 客户端逻辑全热更新（基于ilruntime），没有不能更的部分\n 2. 客户端服务端均可热重载，开发不用重启客户端服务端即可修改逻辑代码，开发极其方便\n 3. 机器人框架，et6的客户端的逻辑跟表现分离，机器人程序直接共享利用客户端的逻辑层代码做压测，只需要极少代码即可做出机器人，方便压测服务端\n 4. 测试用例框架，利用客户端的逻辑层代码写单元测试，每个单元测试都是完整的游戏环境，无需各种恶心的mock\n 5. ai框架，比行为树更加方便，写ai比写ui还简单\n 6. 新的服务端架构，极其优美\n 7. 内外网kcp网络，性能强劲，搭配软路由模块，可以防各种网络攻击\n\n\n# et开发的商业mmo项目千古风流成功上线\n\n> 64核128g内存的单服单物理机1.5w在线（实际线上策划为了生态限制为单服6000人同时在线，6000人的话cpu消耗约为30%）。 为了堆栈行号正常，线上跑得是debug版，如果使用release版开启优化，性能还能翻一倍，达到单物理机3w在线！上线5个月来十分稳定。 千古风流使用了et框架从零开发，用时两年，这个开发速度可以说无人出其右。 千古风流的成功上线证明了et具备开发任何大型游戏的能力，开发速度，开发效率都令人叹为观止！千古风流使用到的客户端服务器技术：\n\n 1.  动态副本跟分线，按需分配，用完回收\n 2.  分线合线，分线人数较少会把多条线合并。合线功能基本上其它mmo游戏很少见到\n 3.  客户端服务端场景无缝切换，也就是无缝大世界技术\n 4.  跨服副本，跨服战场\n 5.  前后端一体化，利用客户端代码开发服务器压测机器人，4台24核机器轻松模拟1w人做任务\n 6.  千古风流各种ai设计，使用et的全新开发的ai框架，使ai开发简单到跟写ui一样简单\n 7.  测试用例框架，大部分重要系统，千古风流都写了测试用例，跟市面上的测试用例不同，每个千古风流的测试用例都是一个完整的游戏环境，针对协议级别，不需要搞各种接口去mock。写起来非常快速。\n 8.  九宫格的aoi实现，动态调整看见的玩家，降低服务器负载\n 9.  防攻击，千古风流开发了软路由功能，即使攻击也只能攻击到软路由，一旦被攻击，玩家客户端发现几秒钟无响应，即可动态切换到其它软路由，用户几乎无感知。整个过程客户端网络连接不断开，数据不丢失。\n 10. 还有很多很多，这里就不啰嗦了\n\n\n# et的介绍：\n\net是一个开源的游戏客户端（基于unity3d）服务端双端框架，服务端是使用c# .net core开发的分布式游戏服务端，其特点是开发效率高，性能强，双端共享逻辑代码，客户端服务端热更机制完善，同时支持可靠udp tcp websocket协议，支持服务端3d recast寻路等等\n\n\n# et的功能：\n\n\n# 1.可用vs单步调试的分布式服务端，n变1\n\n一般来说，分布式服务端要启动很多进程，一旦进程多了，单步调试就变得非常困难，导致服务端开发基本上靠打log来查找问题。平常开发游戏逻辑也得开启一大堆进程，不仅启动慢，而且查找问题及其不方便，要在一堆堆日志里面查问题，这感觉非常糟糕，这么多年也没人解决这个问题。et框架使用了类似守望先锋的组件设计，所有服务端内容都拆成了一个个组件，启动时根据服务器类型挂载自己所需要的组件。这有点类似电脑，电脑都模块化的拆成了内存，cpu，主板等等零件，搭配不同的零件就能组装成一台不同的电脑，例如家用台式机需要内存，cpu，主板，显卡，显示器，硬盘。而公司用的服务器却不需要显示器和显卡，网吧的电脑可能不需要硬盘等。正因为这样的设计，et框架可以将所有的服务器组件都挂在一个服务器进程上，那么这个服务器进程就有了所有服务器的功能，一个进程就可以作为整组分布式服务器使用。这也类似电脑，台式机有所有的电脑组件，那它也完全可以当作公司服务器使用，也可以当作网吧电脑。\n\n\n# 2.随意可拆分功能的分布式服务端，1变n\n\n分布式服务端要开发多种类型的服务器进程，比如login server，gate server，battle server，chat server friend server等等一大堆各种server，传统开发方式需要预先知道当前的功能要放在哪个服务器上，当功能越来越多的时候，比如聊天功能之前在一个中心服务器上，之后需要拆出来单独做成一个服务器，这时会牵扯到大量迁移代码的工作，烦不胜烦。et框架在平常开发的时候根本不太需要关心当前开发的这个功能会放在什么server上，只用一个进程进行开发，功能开发成组件的形式。发布的时候使用一份多进程的配置即可发布成多进程的形式，是不是很方便呢？随便你怎么拆分服务器。只需要修改极少的代码就可以进行拆分。不同的server挂上不同的组件就行了嘛！\n\n\n# 3.跨平台的分布式服务端\n\net框架使用c#做服务端，现在c#是完全可以跨平台的，在linux上安装.netcore，即可，不需要修改任何代码，就能跑起来。性能方面，现在.netcore的性能非常强，比lua，python，js什么快的多了。做游戏服务端完全不在话下。平常我们开发的时候用vs在windows上开发调试，发布的时候发布到linux上即可。et框架还提供了一键同步工具，打开unity->tools->rsync同步，即可同步代码到linux上\n\n./run.sh config/startconfig/192.168.12.188.txt \n\n\n1\n\n\n即可编译启动服务器。\n\n\n# 4.提供协程支持\n\nc#天生支持异步变同步语法 async和await，比lua，python的协程强大的多，新版python以及javascript语言甚至照搬了c#的协程语法。分布式服务端大量服务器之间的远程调用，没有异步语法的支持，开发将非常麻烦。所以java没有异步语法，做单服还行，不适合做大型分布式游戏服务端。例如：\n\n// 发送c2r_ping并且等待响应消息r2c_ping\nr2c_ping pong = await session.call(new c2r_ping()) as r2c_ping;\nlog.debug("收到r2c_ping");\n\n// 向mongodb查询一个id为1的player，并且等待返回\nplayer player = await game.scene.getcomponent<dbproxycomponent>().query<player>(1);\nlog.debug($"打印player name: {player.name}")\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n可以看出，有了async await，所有的服务器间的异步操作将变得非常连贯，不用再拆成多段逻辑。大大简化了分布式服务器开发\n\n\n# 5.提供类似erlang的actor消息机制\n\nerlang语言一大优势就是位置透明的消息机制，用户完全不用关心对象在哪个进程，拿到id就可以对对象发送消息。et框架也提供了actor消息机制，实体对象只需要挂上mailboxcomponent组件，这个实体对象就成了一个actor，任何服务器只需要知道这个实体对象的id就可以向其发送消息，完全不用关心这个实体对象在哪个server，在哪台物理机器上。其实现原理也很简单，et框架提供了一个位置服务器，所有挂载mailboxcomponent的实体对象都会将自己的id跟位置注册到这个位置服务器，其它服务器向这个实体对象发送消息的时候如果不知道这个实体对象的位置，会先去位置服务器查询，查询到位置再进行发送。\n\n\n# 6.提供服务器不停服动态更新逻辑功能\n\n热更是游戏服务器不可缺少的功能，et框架使用的组件设计，可以做成守望先锋的设计，组件只有成员，无方法，将所有方法做成扩展方法放到热更dll中，运行时重新加载dll即可热更所有逻辑。\n\n\n# 7.客户端使用c#热更新，热更新一键切换\n\n可以使用csharp.lua或者ilruntime稍加改造即可做客户端热更。再也不用使用狗屎lua了，客户端可以实现所有逻辑热更新，包括协议，config，ui等等。\n\n\n# 8.客户端热重载\n\n开发不用重启客户端即可修改客户端逻辑代码，开发极其方便\n\n\n# 9.客户端服务端用同一种语言，并且共享代码\n\n下载et框架，打开服务端工程，可以看到服务端引用了客户端很多代码，通过引用客户端代码的方式实现了双端共享代码。例如客户端服务端之间的网络消息两边完全共用一个文件即可，添加一个消息只需要修改一遍。\n\n\n# 10.kcp enet tcp websocket协议无缝切换\n\net框架不但支持tcp，而且支持可靠的udp协议（enet跟kcp），enet是英雄联盟所使用的网络库，其特点是快速，并且网络丢包的情况下性能也非常好，这个我们做过测试tcp在丢包5%的情况下，moba游戏就卡的不行了，但是使用enet，丢包20%仍然不会感到卡。非常强大。框架还支持使用kcp协议，kcp也是可靠udp协议，据说比enet性能更好，使用kcp请注意，需要自己加心跳机制，否则20秒没收到包，服务端将断开连接。协议可以无缝切换。\n\n\n# 11. 3d recast寻路功能\n\n可以unity导出场景数据，给服务端做recast寻路。做mmo非常方便，demo演示了服务端3d寻路功能\n\n\n# 12. 服务端支持repl，也可以动态执行一段新代码\n\n这样就可以打印出进程中任何数据，大大简化了服务端查找问题的难度，开启repl方法，直接在console中输入repl回车即可进入repl模式\n\n\n# 13.提供客户端机器人框架支持\n\n几行代码即可创建机器人登录游戏。机器人压测轻而易举，机器人跟正常的玩家完全一样，上线前用机器人做好压测，大大降低上线崩溃几率\n\n\n# 14.ai框架\n\net的ai框架让ai编写比ui还简单\n\n\n# 15.测试用例框架\n\n跟市面上的测试用例不同，et的测试用例都是一个完整的游戏环境，针对协议级别，不需要搞各种接口去mock。写起来非常快速\n\n\n# 16.还有很多很多功能，我就不详细介绍了\n\na.及其方便检查cpu占用和内存泄漏检查，vs自带分析工具，不用再为性能和内存泄漏检查而烦恼\nb.使用nlog库，打log及其方便，平常开发时，可以将所有服务器log打到一个文件中，再也不用一个个文件搜索log了\nc.统一使用mongodb的bson做序列化，消息和配置文件全部都是bson或者json，并且以后使用mongodb做数据库，再也不用做格式转换了。\nd.提供一个同步工具\n\net框架是一个强大灵活的分布式服务端架构，完全可以满足绝大部分大型游戏需求。使用这套框架，客户端开发者就可以自己完成双端开发，节省大量人力物力，节省大量沟通时间。\n\n相关网站:\net论坛\n\n群友分享：\n行为树与fgui分支(duke chiang开发维护)\net学习笔记系列(烟雨迷离半世殇写)\net学习笔记系列(咲夜詩写)\n框架服务端运行流程\net启动配置\n框架demo介绍\nlinux部署\nlinux部署，mongo安装，资源服搭建\net框架心跳包组件开发\net框架actor使用与心得\n基于et框架和ugui的简单ui框架实现（渐渐写）\net框架笔记 (笑览世界写)\net框架如何用mac开发\net的动态添加事件和触发组件\n\n商业项目:\n\n 1. 千古风流\n 2. 魔法点点2\n 3. 养不大\n 4. 天天躲猫猫2（ios2019春节下载排行19）\n 5. 牛虎棋牌\n 6. 五星麻将\n\n群友demo：\n\n 1. 斗地主（客户端服务端）\n 2. 背包系统\n 3. et小游戏合集\n\n视频教程：\n字母哥et6.0教程\n肉饼老师主讲\n官剑铭主讲\net新手教程-初见主讲 密码: ru1j\net新手教程新版-初见主讲\net在mac上运行指南-l主讲 密码: l3e3\net框架系列教程-烟雨主讲-6.0版本\n\n.net core 游戏资源分享\n各种dotnet core项目收集\n\n讨论qq群 : 474643097\n\n\n# 支付宝捐赠\n\n\n\n\n# 友情链接\n\nbox2dsharp box2d的c#移植版，性能很强\nxasset 致力于为 unity 项目提供了一套 精简稳健 的资源管理环境\nqframework your first k.i.s.s unity3d framework\net ui框架 字母哥实现的ui框架，et风格，各种事件分发\netcsharptoxlua 字母哥使用csharp.lua实现的et客户端热更新\net-6-with-ilruntime 烟雨使用ilruntime实现的et客户端热更新\nluban 适用于大中型项目的游戏配置解决方案',charsets:{cjk:!0},lastUpdated:"2022/07/25, 23:10:19",lastUpdatedTimestamp:1658761819e3},{title:"运行指南",frontmatter:{title:"运行指南",date:"2020-05-11T13:59:38.000Z",permalink:"/pages/52d5c3",article:!1},regularPath:"/01.%E6%8C%87%E5%8D%97/01.ETBbook_%E4%B8%AD%E6%96%87/02.1.1%E8%BF%90%E8%A1%8C%E6%8C%87%E5%8D%97.html",relativePath:"01.指南/01.ETBbook_中文/02.1.1运行指南.md",key:"v-77c5ce9c",path:"/pages/52d5c3/",headersStr:null,content:'# 运行步骤\n\n 1.  visual studio用户须知：\n     \n     * 版本：\n       * Win10及以上用户，使用.net6, VS 版本，必须使用2022及以上。注意，VS 2019 不支持 .net6，不能使用。\n       * Win7 用户，无法安装 VS 2022，需要使用 .net 5 和 VS 2019，但注意需要额外设置以支持ET编译。\n     * 依赖：\n       * 需要安装"使用Unity的游戏开发"扩展。\n       * 需要在"工具-选项-适用于Unity的工具-常规"里，把杂项里的禁止完整生成项目改为False，否则导致你Codes目录里的代码报错。\n\n 2.  使用Rider2021.2.2（更新到最新版）, 需要安装以下内容:\n     \n     * Rider的Unity插件\n     * 安装 .net6\n     * 2021.2.2 会报".NET SDK 6.0.101 is not fully supported in Rider"，但实际不影响编译(2021.12.21)\n     * 2021.3.x 完全支持 .net6\n\n 3.  master分支需要unity2020.3版（用到了C#8的语法）\n\n 4.  启动Unity， 菜单 File -> Open Project... -> Open 选中ET/Unity文件夹，点击选择文件夹按钮。\n\n 5.  点击Unity菜单 Assets -> Open C# Project 启动vs\n\n 6.  运行Unity菜单上的 Tools->BuildCode，这一步将编译客户端代码\n\n 7.  用Rider打开 ET/Client-Server.sln 编译（一定要全部工程编译，右键VS解决方案，全部编译） 这里报红发现引用错误，是因为Unity的库还没编译到Unity/Temp/Debug目录下面，一般不用管，必须保证Unity是开启的，然后只需要直接编译Client-Server即可， Client-Server会编译Unity.Mono。Unity.Mono会把自己依赖的Unity的库复制到Unity/Temp/Debug中。Unity.Model Unity.Hotfix Unity.ModelView UnityHotfix.View都会依赖Unity/Temp/Debug下的库。如果还是爆红，关闭vs或者rider，先打开unity，再打开Client-Server.sln，再 编译Client-Server\n\n 8.  导表工具，编译完成后命令行进入 Bin 目录，执行 dotnet Tools.dll --AppType=ExcelExporter\n\n 9.  导出协议工具，编译完成后进入 Bin 目录，执行 dotnet Tools.dll --AppType=Proto2CS\n\n 10. 启动服务器: dotnet Server.dll --Process=1 --Console=1\n\n 11. Unity中双击Scenes目录中的Init场景，点击Play即可运行\n\n\n# 测试状态同步demo\n\n 1. 想修改配置就进入 Excel 目录修改对应的表格，做运行步骤的第6步，然后重新运行 Server.App工程来启动服务端。\n\n 2. Unity->tools菜单->打包工具，选择PC，勾选是否打包exe，点击开始打包，打出一个PC包在Release目录下。\n\n 3. 运行Unity 登录 进入大厅 进入场景\n\n 4. 运行PC包 登录 进入大厅\n\n 5. 点击鼠标右键即可移动人物\n\n\n# 注意事项：\n\n一. 出错原因都是：\n\n 1.  中文目录。\n 2.  VS 版本低\n 3.  Rider没有安装相关组件\n 4.  没安装 .net6\n 5.  没编译服务端所有工程\n 6.  Rider要更新到最新版本\n 7.  Unity版本太低\n 8.  Win7 用户，没有特别设置\n 9.  *编译过程中如果出现依赖问题，也有可能是 Unity - External Tools - Generate .csproj files for: 当中勾选了\n     1. Registry packages\n     2. Build-in packages\n 10. *如果打包报错缺少"StreamingAsset"，自己在 ET\\Unity\\Assets 下新建一个 StreamingAsset 文件夹即可。',normalizedContent:'# 运行步骤\n\n 1.  visual studio用户须知：\n     \n     * 版本：\n       * win10及以上用户，使用.net6, vs 版本，必须使用2022及以上。注意，vs 2019 不支持 .net6，不能使用。\n       * win7 用户，无法安装 vs 2022，需要使用 .net 5 和 vs 2019，但注意需要额外设置以支持et编译。\n     * 依赖：\n       * 需要安装"使用unity的游戏开发"扩展。\n       * 需要在"工具-选项-适用于unity的工具-常规"里，把杂项里的禁止完整生成项目改为false，否则导致你codes目录里的代码报错。\n\n 2.  使用rider2021.2.2（更新到最新版）, 需要安装以下内容:\n     \n     * rider的unity插件\n     * 安装 .net6\n     * 2021.2.2 会报".net sdk 6.0.101 is not fully supported in rider"，但实际不影响编译(2021.12.21)\n     * 2021.3.x 完全支持 .net6\n\n 3.  master分支需要unity2020.3版（用到了c#8的语法）\n\n 4.  启动unity， 菜单 file -> open project... -> open 选中et/unity文件夹，点击选择文件夹按钮。\n\n 5.  点击unity菜单 assets -> open c# project 启动vs\n\n 6.  运行unity菜单上的 tools->buildcode，这一步将编译客户端代码\n\n 7.  用rider打开 et/client-server.sln 编译（一定要全部工程编译，右键vs解决方案，全部编译） 这里报红发现引用错误，是因为unity的库还没编译到unity/temp/debug目录下面，一般不用管，必须保证unity是开启的，然后只需要直接编译client-server即可， client-server会编译unity.mono。unity.mono会把自己依赖的unity的库复制到unity/temp/debug中。unity.model unity.hotfix unity.modelview unityhotfix.view都会依赖unity/temp/debug下的库。如果还是爆红，关闭vs或者rider，先打开unity，再打开client-server.sln，再 编译client-server\n\n 8.  导表工具，编译完成后命令行进入 bin 目录，执行 dotnet tools.dll --apptype=excelexporter\n\n 9.  导出协议工具，编译完成后进入 bin 目录，执行 dotnet tools.dll --apptype=proto2cs\n\n 10. 启动服务器: dotnet server.dll --process=1 --console=1\n\n 11. unity中双击scenes目录中的init场景，点击play即可运行\n\n\n# 测试状态同步demo\n\n 1. 想修改配置就进入 excel 目录修改对应的表格，做运行步骤的第6步，然后重新运行 server.app工程来启动服务端。\n\n 2. unity->tools菜单->打包工具，选择pc，勾选是否打包exe，点击开始打包，打出一个pc包在release目录下。\n\n 3. 运行unity 登录 进入大厅 进入场景\n\n 4. 运行pc包 登录 进入大厅\n\n 5. 点击鼠标右键即可移动人物\n\n\n# 注意事项：\n\n一. 出错原因都是：\n\n 1.  中文目录。\n 2.  vs 版本低\n 3.  rider没有安装相关组件\n 4.  没安装 .net6\n 5.  没编译服务端所有工程\n 6.  rider要更新到最新版本\n 7.  unity版本太低\n 8.  win7 用户，没有特别设置\n 9.  *编译过程中如果出现依赖问题，也有可能是 unity - external tools - generate .csproj files for: 当中勾选了\n     1. registry packages\n     2. build-in packages\n 10. *如果打包报错缺少"streamingasset"，自己在 et\\unity\\assets 下新建一个 streamingasset 文件夹即可。',charsets:{cjk:!0},lastUpdated:"2022/07/25, 23:10:19",lastUpdatedTimestamp:1658761819e3},{title:"目录结构",frontmatter:{title:"目录结构",date:"2022-05-30T17:12:34.000Z",permalink:"/pages/ff62ec/",author:{name:"小弟",href:"https://www.yuque.com/et-xd/docs"}},regularPath:"/01.%E6%8C%87%E5%8D%97/01.ETBbook_%E4%B8%AD%E6%96%87/03.%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.html",relativePath:"01.指南/01.ETBbook_中文/03.目录结构.md",key:"v-6a22f932",path:"/pages/ff62ec/",headersStr:null,content:"\n\n\n1\n",normalizedContent:"\n\n\n1\n",charsets:{},lastUpdated:"2022/07/25, 23:10:19",lastUpdatedTimestamp:1658761819e3},{title:"1.2为什么使用.net core",frontmatter:{title:"1.2为什么使用.net core",date:"2022-05-31T19:10:27.000Z",permalink:"/pages/f62a4d/"},regularPath:"/01.%E6%8C%87%E5%8D%97/01.ETBbook_%E4%B8%AD%E6%96%87/12.1.2%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8.net%20core.html",relativePath:"01.指南/01.ETBbook_中文/12.1.2为什么使用.net core.md",key:"v-455f0d94",path:"/pages/f62a4d/",headers:[{level:6,title:"1. 语言的稳定性（致命性）",slug:"_1-语言的稳定性-致命性",normalizedTitle:"1. 语言的稳定性（致命性）",charIndex:237},{level:6,title:"2. 运行时热更（致命性）",slug:"_2-运行时热更-致命性",normalizedTitle:"2. 运行时热更（致命性）",charIndex:311},{level:6,title:"3. 是否有协程支持（重要性5星）",slug:"_3-是否有协程支持-重要性5星",normalizedTitle:"3. 是否有协程支持（重要性5星）",charIndex:413},{level:6,title:"4. 编译速度（重要性5星）",slug:"_4-编译速度-重要性5星",normalizedTitle:"4. 编译速度（重要性5星）",charIndex:520},{level:6,title:"5. 跨平台（4星）",slug:"_5-跨平台-4星",normalizedTitle:"5. 跨平台（4星）",charIndex:587},{level:6,title:"6. 可阅读性，可重构性（3星）",slug:"_6-可阅读性-可重构性-3星",normalizedTitle:"6. 可阅读性，可重构性（3星）",charIndex:691},{level:6,title:"7. 库是否齐全，生态是否完善（3星）",slug:"_7-库是否齐全-生态是否完善-3星",normalizedTitle:"7. 库是否齐全，生态是否完善（3星）",charIndex:730},{level:6,title:"8.跟客户端统一语言（3星）",slug:"_8-跟客户端统一语言-3星",normalizedTitle:"8.跟客户端统一语言（3星）",charIndex:773},{level:6,title:"9. IDE的支持（3星）",slug:"_9-ide的支持-3星",normalizedTitle:"9. ide的支持（3星）",charIndex:867},{level:6,title:"10. 语言的性能（1星）",slug:"_10-语言的性能-1星",normalizedTitle:"10. 语言的性能（1星）",charIndex:914}],headersStr:"1. 语言的稳定性（致命性） 2. 运行时热更（致命性） 3. 是否有协程支持（重要性5星） 4. 编译速度（重要性5星） 5. 跨平台（4星） 6. 可阅读性，可重构性（3星） 7. 库是否齐全，生态是否完善（3星） 8.跟客户端统一语言（3星） 9. IDE的支持（3星） 10. 语言的性能（1星）",content:"# 为什么使用C# .net core做服务端？\n\n游戏服务端从早期的单服到分布式，开发越来越复杂，对稳定性，开发效率要求越来越高。开发语言的选择也逐步发生了变化，C 到 C++ 到 C++ + PYTHON 或者C++ + LUA 到现在 很多公司开始使用erlang，go，java，c#。目前是一个百花齐放的局面。\n\n但是如果是要你重新做一个网游server，不考虑对公司或者已有的东西兼容性，你会怎么选择？我仔细想了一下这个问题，大概有这个几个方面需要考虑：\n\n# 1. 语言的稳定性（致命性）\n\n游戏服务器的特点是高负载低延时。所以一般服务端进程都是带状态的，一旦挂掉就意味着数据丢失，这点是无法容忍的。\n\n# 2. 运行时热更（致命性）\n\n游戏服务器逻辑极其复杂，很容易出现bug，但是又不能经常停服，所以热更修复bug就显得十分必要。出现错误开发人员可以立即编写代码，然后热更修复，线上用户完全感觉不到。\n\n# 3. 是否有协程支持（重要性5星）\n\n分布式服务器架构，进程与进程之间必然会有大量交互。由于游戏逻辑很难拆分成多线程，所以一般来说都是逻辑单线程。如果没有协程支持，必然产生大量回调，代码维护会变得非常困难。\n\n# 4. 编译速度（重要性5星）\n\n使用c++开发，30%的时间都浪费在编译上。假如编译很快或者不需要编译，必定大大提高开发效率。\n\n# 5. 跨平台（4星）\n\n一般游戏服务器都架设在linux上面。但是平常开发，使用windows会更加方便，如果跨平台，开发以及测试效率会大大提升，并且不需要单独搞一个开发机，本机电脑就可以满足平常开发\n\n# 6. 可阅读性，可重构性（3星）\n\n代码可以重构能大大减轻写代码的难度\n\n# 7. 库是否齐全，生态是否完善（3星）\n\n库齐全，生态好，自己需要造的轮子就少\n\n# 8.跟客户端统一语言（3星）\n\n客户端服务端共用语言，优势十分明显，很多代码可以复用，逻辑程序员不再需要区分前后端，双端都可以写，一个人即可完成一个功能，大大减少了沟通的时间成本。\n\n# 9. IDE的支持（3星）\n\n代码提示，重构等支持，优秀的IDE能提高几倍的开发效率。\n\n# 10. 语言的性能（1星）\n\n目前服务器性能都不是太大问题，不过性能好总比性能差要强。\n\n语言        C#      C/C++       JAVA   GO    LUA         PYTHON   ERLANG\n稳定性       稳定      容易挂         稳定     稳定    稳定          稳定       稳定\n运行时热更     支持      较难支持        支持     不支持   支持          支持       支持\n跨平台       支持      较难支持        支持     支持    较难支持        支持       支持\n协程        有       需要自己实现      支持不好   支持    支持          支持       支持\n编译速度      快       慢           快      快     不需要编译       不需要编译    不需要编译\n阅读性重构性    好       一般          好      一般    差           差        差\n游戏库跟生态    好       好           一般     一般    差           好        一般\n客户端统一语言   Unity   Unity、UE4   暂无     暂无    Unity、UE4   UE4      暂无\nIDE的支持    好       好           好      普通    差           差        差\n语言的性能     好       极好          好      好     差           很差       差\n\n从表格可以看出:\n\n 1. C/C++稳定性差，编译速度慢，存在致命缺陷\n 2. Go不支持热更，由于不支持泛型，重构性较差，无法跟客户端共享代码，存在致命缺陷\n 3. Java协程支持差，无法跟客户端共享代码\n 4. Lua库少，性能差，代码可阅读性可重构性差，跨平台完全依赖C/C++，处理起来麻烦，ide支持差\n 5. Python 性能很差，代码可阅读性可重构性差，无法跟客户端共享代码，ide支持差\n 6. Erlang 性能差，函数式风格不好上手，ide支持差\n 7. C# .net core各个方便都非常优秀，不过跟UE4无法共享代码\n\n当前Unity是最火的游戏引擎，C#服务端搭配Unity完全是天作之合，基本上找不到缺陷。",normalizedContent:"# 为什么使用c# .net core做服务端？\n\n游戏服务端从早期的单服到分布式，开发越来越复杂，对稳定性，开发效率要求越来越高。开发语言的选择也逐步发生了变化，c 到 c++ 到 c++ + python 或者c++ + lua 到现在 很多公司开始使用erlang，go，java，c#。目前是一个百花齐放的局面。\n\n但是如果是要你重新做一个网游server，不考虑对公司或者已有的东西兼容性，你会怎么选择？我仔细想了一下这个问题，大概有这个几个方面需要考虑：\n\n# 1. 语言的稳定性（致命性）\n\n游戏服务器的特点是高负载低延时。所以一般服务端进程都是带状态的，一旦挂掉就意味着数据丢失，这点是无法容忍的。\n\n# 2. 运行时热更（致命性）\n\n游戏服务器逻辑极其复杂，很容易出现bug，但是又不能经常停服，所以热更修复bug就显得十分必要。出现错误开发人员可以立即编写代码，然后热更修复，线上用户完全感觉不到。\n\n# 3. 是否有协程支持（重要性5星）\n\n分布式服务器架构，进程与进程之间必然会有大量交互。由于游戏逻辑很难拆分成多线程，所以一般来说都是逻辑单线程。如果没有协程支持，必然产生大量回调，代码维护会变得非常困难。\n\n# 4. 编译速度（重要性5星）\n\n使用c++开发，30%的时间都浪费在编译上。假如编译很快或者不需要编译，必定大大提高开发效率。\n\n# 5. 跨平台（4星）\n\n一般游戏服务器都架设在linux上面。但是平常开发，使用windows会更加方便，如果跨平台，开发以及测试效率会大大提升，并且不需要单独搞一个开发机，本机电脑就可以满足平常开发\n\n# 6. 可阅读性，可重构性（3星）\n\n代码可以重构能大大减轻写代码的难度\n\n# 7. 库是否齐全，生态是否完善（3星）\n\n库齐全，生态好，自己需要造的轮子就少\n\n# 8.跟客户端统一语言（3星）\n\n客户端服务端共用语言，优势十分明显，很多代码可以复用，逻辑程序员不再需要区分前后端，双端都可以写，一个人即可完成一个功能，大大减少了沟通的时间成本。\n\n# 9. ide的支持（3星）\n\n代码提示，重构等支持，优秀的ide能提高几倍的开发效率。\n\n# 10. 语言的性能（1星）\n\n目前服务器性能都不是太大问题，不过性能好总比性能差要强。\n\n语言        c#      c/c++       java   go    lua         python   erlang\n稳定性       稳定      容易挂         稳定     稳定    稳定          稳定       稳定\n运行时热更     支持      较难支持        支持     不支持   支持          支持       支持\n跨平台       支持      较难支持        支持     支持    较难支持        支持       支持\n协程        有       需要自己实现      支持不好   支持    支持          支持       支持\n编译速度      快       慢           快      快     不需要编译       不需要编译    不需要编译\n阅读性重构性    好       一般          好      一般    差           差        差\n游戏库跟生态    好       好           一般     一般    差           好        一般\n客户端统一语言   unity   unity、ue4   暂无     暂无    unity、ue4   ue4      暂无\nide的支持    好       好           好      普通    差           差        差\n语言的性能     好       极好          好      好     差           很差       差\n\n从表格可以看出:\n\n 1. c/c++稳定性差，编译速度慢，存在致命缺陷\n 2. go不支持热更，由于不支持泛型，重构性较差，无法跟客户端共享代码，存在致命缺陷\n 3. java协程支持差，无法跟客户端共享代码\n 4. lua库少，性能差，代码可阅读性可重构性差，跨平台完全依赖c/c++，处理起来麻烦，ide支持差\n 5. python 性能很差，代码可阅读性可重构性差，无法跟客户端共享代码，ide支持差\n 6. erlang 性能差，函数式风格不好上手，ide支持差\n 7. c# .net core各个方便都非常优秀，不过跟ue4无法共享代码\n\n当前unity是最火的游戏引擎，c#服务端搭配unity完全是天作之合，基本上找不到缺陷。",charsets:{cjk:!0},lastUpdated:"2022/07/25, 23:10:19",lastUpdatedTimestamp:1658761819e3},{title:"2.1CSharp的协程",frontmatter:{title:"2.1CSharp的协程",date:"2022-05-31T19:10:27.000Z",permalink:"/pages/500d39/"},regularPath:"/01.%E6%8C%87%E5%8D%97/01.ETBbook_%E4%B8%AD%E6%96%87/21.2.1CSharp%E7%9A%84%E5%8D%8F%E7%A8%8B.html",relativePath:"01.指南/01.ETBbook_中文/21.2.1CSharp的协程.md",key:"v-3dac3e03",path:"/pages/500d39/",headersStr:null,content:'# 什么是协程\n\n说到协程，我们先了解什么是异步，异步简单说来就是，我要发起一个调用，但是这个被调用方（可能是其它线程，也可能是IO）出结果需要一段时间，我不想让这个调用阻塞住调用方的整个线程，因此传给被调用方一个回调函数，被调用方运行完成后回调这个回调函数就能通知调用方继续往下执行。举个例子:\n下面的代码，主线程一直循环，每循环一次sleep 1毫秒，计数加一，每10000次打印一次。\n\n        private static void Main()\n        {\n            int loopCount = 0;\n            while (true)\n            {\n                int temp = watcherValue;\n                \n                Thread.Sleep(1);\n                \n                ++loopCount;\n                if (loopCount % 10000 == 0)\n                {\n                    Console.WriteLine($"loop count: {loopCount}");\n                }\n            }\n        }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n这时我需要加个功能，在程序一开始，我希望在5秒钟之后打印出loopCount的值。看到5秒后我们可以想到Sleep方法，它会阻塞线程一定时间然后继续执行。我们显然不能在主线程中Sleep，因为会破坏掉每10000次计数打印一次的逻辑。\n\n    // example2_1\n    class Program\n    {\n        private static int loopCount = 0;\n\n        private static void Main()\n        {\n            OneThreadSynchronizationContext _ = OneThreadSynchronizationContext.Instance;\n            \n            WaitTimeAsync(5000, WaitTimeFinishCallback);\n            \n            while (true)\n            {\n                OneThreadSynchronizationContext.Instance.Update();\n                \n                Thread.Sleep(1);\n                \n                ++loopCount;\n                if (loopCount % 10000 == 0)\n                {\n                    Console.WriteLine($"loop count: {loopCount}");\n                }\n            }\n        }\n\n        private static void WaitTimeAsync(int waitTime, Action action)\n        {\n            Thread thread = new Thread(()=>WaitTime(waitTime, action));\n            thread.Start();\n        }\n        \n        private static void WaitTimeFinishCallback()\n        {\n            Console.WriteLine($"WaitTimeAsync finsih loopCount的值是: {loopCount}");\n        }\n\n        /// <summary>\n        /// 在另外的线程等待\n        /// </summary>\n        private static void WaitTime(int waitTime, Action action)\n        {\n            Thread.Sleep(waitTime);\n            \n            // 将action扔回主线程执行\n            OneThreadSynchronizationContext.Instance.Post((o)=>action(), null);\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n我们在这里设计了一个WaitTimeAsync方法，WaitTimeAsync其实就是一个典型的异步方法，它从主线程发起调用，传入了一个WaitTimeFinishCallback回调方法做参数，开启了一个线程，线程Sleep一定时间后，将传过来的回调扔回到主线程执行。OneThreadSynchronizationContext是一个跨线程队列，任何线程可以往里面扔委托，OneThreadSynchronizationContext的Update方法在主线程中调用，会将这些委托取出来放到主线程执行。为什么回调方法需要扔回到主线程执行呢？因为回调方法中读取了loopCount，loopCount在主线程中也有读写，所以要么加锁，要么永远保证只在主线程中读写。加锁是个不好的做法，代码中到处是锁会导致阅读跟维护困难，很容易产生多线程bug。这种将逻辑打包成委托然后扔回另外一个线程是多线程开发中常用的技巧。\n\n我们可能又有个新需求，WaitTimeFinishCallback执行完成之后，再想等3秒，再打印一下loopCount。\n\n        private static void WaitTimeAsync(int waitTime, Action action)\n        {\n            Thread thread = new Thread(()=>WaitTime(waitTime, action));\n            thread.Start();\n        }\n        private static void WaitTimeFinishCallback()\n        {\n            Console.WriteLine($"WaitTimeAsync finsih loopCount的值是: {loopCount}");\n            WaitTimeAsync(3000, WaitTimeFinishCallback2);\n        }\n        \n        private static void WaitTimeFinishCallback2()\n        {\n            Console.WriteLine($"WaitTimeAsync finsih loopCount的值是: {loopCount}");\n        }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n我们这时还可能改需求，需要在程序启动5秒后，接下来4秒，再接下来3秒，打印loopCount，也就是上面的逻辑中间再插入一个3秒等待。\n\n        private static void WaitTimeAsync(int waitTime, Action action)\n        {\n            Thread thread = new Thread(()=>WaitTime(waitTime, action));\n            thread.Start();\n        }\n        \n        private static void WaitTimeFinishCallback()\n        {\n            Console.WriteLine($"WaitTimeAsync finsih loopCount的值是: {loopCount}");\n            WaitTimeAsync(4000, WaitTimeFinishCallback3);\n        }\n        \n        private static void WaitTimeFinishCallback3()\n        {\n            Console.WriteLine($"WaitTimeAsync finsih loopCount的值是: {loopCount}");\n            WaitTimeAsync(3000, WaitTimeFinishCallback2);\n        }\n        \n        private static void WaitTimeFinishCallback2()\n        {\n            Console.WriteLine($"WaitTimeAsync finsih loopCount的值是: {loopCount}");\n        }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n这样中间插入一段代码，显得非常麻烦。这里可以回答什么是协程了，其实这一串串回调就是协程。',normalizedContent:'# 什么是协程\n\n说到协程，我们先了解什么是异步，异步简单说来就是，我要发起一个调用，但是这个被调用方（可能是其它线程，也可能是io）出结果需要一段时间，我不想让这个调用阻塞住调用方的整个线程，因此传给被调用方一个回调函数，被调用方运行完成后回调这个回调函数就能通知调用方继续往下执行。举个例子:\n下面的代码，主线程一直循环，每循环一次sleep 1毫秒，计数加一，每10000次打印一次。\n\n        private static void main()\n        {\n            int loopcount = 0;\n            while (true)\n            {\n                int temp = watchervalue;\n                \n                thread.sleep(1);\n                \n                ++loopcount;\n                if (loopcount % 10000 == 0)\n                {\n                    console.writeline($"loop count: {loopcount}");\n                }\n            }\n        }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n这时我需要加个功能，在程序一开始，我希望在5秒钟之后打印出loopcount的值。看到5秒后我们可以想到sleep方法，它会阻塞线程一定时间然后继续执行。我们显然不能在主线程中sleep，因为会破坏掉每10000次计数打印一次的逻辑。\n\n    // example2_1\n    class program\n    {\n        private static int loopcount = 0;\n\n        private static void main()\n        {\n            onethreadsynchronizationcontext _ = onethreadsynchronizationcontext.instance;\n            \n            waittimeasync(5000, waittimefinishcallback);\n            \n            while (true)\n            {\n                onethreadsynchronizationcontext.instance.update();\n                \n                thread.sleep(1);\n                \n                ++loopcount;\n                if (loopcount % 10000 == 0)\n                {\n                    console.writeline($"loop count: {loopcount}");\n                }\n            }\n        }\n\n        private static void waittimeasync(int waittime, action action)\n        {\n            thread thread = new thread(()=>waittime(waittime, action));\n            thread.start();\n        }\n        \n        private static void waittimefinishcallback()\n        {\n            console.writeline($"waittimeasync finsih loopcount的值是: {loopcount}");\n        }\n\n        /// <summary>\n        /// 在另外的线程等待\n        /// </summary>\n        private static void waittime(int waittime, action action)\n        {\n            thread.sleep(waittime);\n            \n            // 将action扔回主线程执行\n            onethreadsynchronizationcontext.instance.post((o)=>action(), null);\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n我们在这里设计了一个waittimeasync方法，waittimeasync其实就是一个典型的异步方法，它从主线程发起调用，传入了一个waittimefinishcallback回调方法做参数，开启了一个线程，线程sleep一定时间后，将传过来的回调扔回到主线程执行。onethreadsynchronizationcontext是一个跨线程队列，任何线程可以往里面扔委托，onethreadsynchronizationcontext的update方法在主线程中调用，会将这些委托取出来放到主线程执行。为什么回调方法需要扔回到主线程执行呢？因为回调方法中读取了loopcount，loopcount在主线程中也有读写，所以要么加锁，要么永远保证只在主线程中读写。加锁是个不好的做法，代码中到处是锁会导致阅读跟维护困难，很容易产生多线程bug。这种将逻辑打包成委托然后扔回另外一个线程是多线程开发中常用的技巧。\n\n我们可能又有个新需求，waittimefinishcallback执行完成之后，再想等3秒，再打印一下loopcount。\n\n        private static void waittimeasync(int waittime, action action)\n        {\n            thread thread = new thread(()=>waittime(waittime, action));\n            thread.start();\n        }\n        private static void waittimefinishcallback()\n        {\n            console.writeline($"waittimeasync finsih loopcount的值是: {loopcount}");\n            waittimeasync(3000, waittimefinishcallback2);\n        }\n        \n        private static void waittimefinishcallback2()\n        {\n            console.writeline($"waittimeasync finsih loopcount的值是: {loopcount}");\n        }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n我们这时还可能改需求，需要在程序启动5秒后，接下来4秒，再接下来3秒，打印loopcount，也就是上面的逻辑中间再插入一个3秒等待。\n\n        private static void waittimeasync(int waittime, action action)\n        {\n            thread thread = new thread(()=>waittime(waittime, action));\n            thread.start();\n        }\n        \n        private static void waittimefinishcallback()\n        {\n            console.writeline($"waittimeasync finsih loopcount的值是: {loopcount}");\n            waittimeasync(4000, waittimefinishcallback3);\n        }\n        \n        private static void waittimefinishcallback3()\n        {\n            console.writeline($"waittimeasync finsih loopcount的值是: {loopcount}");\n            waittimeasync(3000, waittimefinishcallback2);\n        }\n        \n        private static void waittimefinishcallback2()\n        {\n            console.writeline($"waittimeasync finsih loopcount的值是: {loopcount}");\n        }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n这样中间插入一段代码，显得非常麻烦。这里可以回答什么是协程了，其实这一串串回调就是协程。',charsets:{cjk:!0},lastUpdated:"2022/07/25, 23:10:19",lastUpdatedTimestamp:1658761819e3},{title:"2.2更好的协程",frontmatter:{title:"2.2更好的协程",date:"2022-05-31T19:10:27.000Z",permalink:"/pages/0f0a88/"},regularPath:"/01.%E6%8C%87%E5%8D%97/01.ETBbook_%E4%B8%AD%E6%96%87/22.2.2%E6%9B%B4%E5%A5%BD%E7%9A%84%E5%8D%8F%E7%A8%8B.html",relativePath:"01.指南/01.ETBbook_中文/22.2.2更好的协程.md",key:"v-15a9f55e",path:"/pages/0f0a88/",headersStr:null,content:'# 更好的协程\n\n上文讲了一串回调就是协程，显然这样写代码，增加逻辑，插入逻辑非常容易出错。我们需要利用异步语法把这个异步回调的形式改成同步的形式，幸好C#已经帮我们设计好了，看代码\n\n    // example2_2\n    class Program\n    {\n        private static int loopCount = 0;\n        \n        static void Main(string[] args)\n        {\n            OneThreadSynchronizationContext _ = OneThreadSynchronizationContext.Instance;\n\n            Console.WriteLine($"主线程: {Thread.CurrentThread.ManagedThreadId}");\n            \n            Crontine();\n            \n            while (true)\n            {\n                OneThreadSynchronizationContext.Instance.Update();\n                \n                Thread.Sleep(1);\n                \n                ++loopCount;\n                if (loopCount % 10000 == 0)\n                {\n                    Console.WriteLine($"loop count: {loopCount}");\n                }\n            }\n        }\n\n        private static async void Crontine()\n        {\n            await WaitTimeAsync(5000);\n            Console.WriteLine($"当前线程: {Thread.CurrentThread.ManagedThreadId}, WaitTimeAsync finsih loopCount的值是: {loopCount}");\n            await WaitTimeAsync(4000);\n            Console.WriteLine($"当前线程: {Thread.CurrentThread.ManagedThreadId}, WaitTimeAsync finsih loopCount的值是: {loopCount}");\n            await WaitTimeAsync(3000);\n            Console.WriteLine($"当前线程: {Thread.CurrentThread.ManagedThreadId}, WaitTimeAsync finsih loopCount的值是: {loopCount}");\n        }\n        \n        private static Task WaitTimeAsync(int waitTime)\n        {\n            TaskCompletionSource<bool> tcs = new TaskCompletionSource<bool>();\n            Thread thread = new Thread(()=>WaitTime(waitTime, tcs));\n            thread.Start();\n            return tcs.Task;\n        }\n        \n        /// <summary>\n        /// 在另外的线程等待\n        /// </summary>\n        private static void WaitTime(int waitTime, TaskCompletionSource<bool> tcs)\n        {\n            Thread.Sleep(waitTime);\n            \n            // 将tcs扔回主线程执行\n            OneThreadSynchronizationContext.Instance.Post(o=>tcs.SetResult(true), null);\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n\n\n在这段代码里面，WaitTimeAsync方法中，我们利用了TaskCompletionSource类替代了之前传入的Action参数，WaitTimeAsync方法返回了一个Task类型的结果。WaitTime中我们把action()替换成了tcs.SetResult(true),WaitTimeAsync方法前使用await关键字，这样可以将一连串的回调改成同步的形式。这样一来代码显得十分简洁，开发起来也方便多了。\n\n这里还有个技巧，我们发现WaitTime中需要将tcs.SetResult扔回到主线程执行，微软给我们提供了一种简单的方法，参考example2_2_2，在主线程设置好同步上下文，\n\n// example2_2_2\nSynchronizationContext.SetSynchronizationContext(OneThreadSynchronizationContext.Instance);\n\n\n1\n2\n\n\n在WaitTime中直接调用tcs.SetResult(true)就行了，回调会自动扔到同步上下文中，而同步上下文我们可以在主线程中取出回调执行，这样自动能够完成回到主线程的操作\n\n        private static void WaitTime(int waitTime, TaskCompletionSource<bool> tcs)\n        {\n            Thread.Sleep(waitTime);\n\n            tcs.SetResult(true);\n        }\n\n\n1\n2\n3\n4\n5\n6\n\n\n如果不设置同步上下文，你会发现打印出来当前线程就不是主线程了，这也是很多第三方库跟.net core内置库的用法，默认不回调到主线程，所以我们使用的时候需要设置下同步上下文。其实这个设计本人觉得没有必要，交由库的开发者去实现更好，尤其是在游戏开发中，逻辑全部是单线程的，回调每次都走一遍同步上下文就显得多余了，所以ET框架提供了不使用同步上下文的实现ETTask，代码更加简洁更加高效，这个后面会讲到。',normalizedContent:'# 更好的协程\n\n上文讲了一串回调就是协程，显然这样写代码，增加逻辑，插入逻辑非常容易出错。我们需要利用异步语法把这个异步回调的形式改成同步的形式，幸好c#已经帮我们设计好了，看代码\n\n    // example2_2\n    class program\n    {\n        private static int loopcount = 0;\n        \n        static void main(string[] args)\n        {\n            onethreadsynchronizationcontext _ = onethreadsynchronizationcontext.instance;\n\n            console.writeline($"主线程: {thread.currentthread.managedthreadid}");\n            \n            crontine();\n            \n            while (true)\n            {\n                onethreadsynchronizationcontext.instance.update();\n                \n                thread.sleep(1);\n                \n                ++loopcount;\n                if (loopcount % 10000 == 0)\n                {\n                    console.writeline($"loop count: {loopcount}");\n                }\n            }\n        }\n\n        private static async void crontine()\n        {\n            await waittimeasync(5000);\n            console.writeline($"当前线程: {thread.currentthread.managedthreadid}, waittimeasync finsih loopcount的值是: {loopcount}");\n            await waittimeasync(4000);\n            console.writeline($"当前线程: {thread.currentthread.managedthreadid}, waittimeasync finsih loopcount的值是: {loopcount}");\n            await waittimeasync(3000);\n            console.writeline($"当前线程: {thread.currentthread.managedthreadid}, waittimeasync finsih loopcount的值是: {loopcount}");\n        }\n        \n        private static task waittimeasync(int waittime)\n        {\n            taskcompletionsource<bool> tcs = new taskcompletionsource<bool>();\n            thread thread = new thread(()=>waittime(waittime, tcs));\n            thread.start();\n            return tcs.task;\n        }\n        \n        /// <summary>\n        /// 在另外的线程等待\n        /// </summary>\n        private static void waittime(int waittime, taskcompletionsource<bool> tcs)\n        {\n            thread.sleep(waittime);\n            \n            // 将tcs扔回主线程执行\n            onethreadsynchronizationcontext.instance.post(o=>tcs.setresult(true), null);\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n\n\n在这段代码里面，waittimeasync方法中，我们利用了taskcompletionsource类替代了之前传入的action参数，waittimeasync方法返回了一个task类型的结果。waittime中我们把action()替换成了tcs.setresult(true),waittimeasync方法前使用await关键字，这样可以将一连串的回调改成同步的形式。这样一来代码显得十分简洁，开发起来也方便多了。\n\n这里还有个技巧，我们发现waittime中需要将tcs.setresult扔回到主线程执行，微软给我们提供了一种简单的方法，参考example2_2_2，在主线程设置好同步上下文，\n\n// example2_2_2\nsynchronizationcontext.setsynchronizationcontext(onethreadsynchronizationcontext.instance);\n\n\n1\n2\n\n\n在waittime中直接调用tcs.setresult(true)就行了，回调会自动扔到同步上下文中，而同步上下文我们可以在主线程中取出回调执行，这样自动能够完成回到主线程的操作\n\n        private static void waittime(int waittime, taskcompletionsource<bool> tcs)\n        {\n            thread.sleep(waittime);\n\n            tcs.setresult(true);\n        }\n\n\n1\n2\n3\n4\n5\n6\n\n\n如果不设置同步上下文，你会发现打印出来当前线程就不是主线程了，这也是很多第三方库跟.net core内置库的用法，默认不回调到主线程，所以我们使用的时候需要设置下同步上下文。其实这个设计本人觉得没有必要，交由库的开发者去实现更好，尤其是在游戏开发中，逻辑全部是单线程的，回调每次都走一遍同步上下文就显得多余了，所以et框架提供了不使用同步上下文的实现ettask，代码更加简洁更加高效，这个后面会讲到。',charsets:{cjk:!0},lastUpdated:"2022/07/25, 23:10:19",lastUpdatedTimestamp:1658761819e3},{title:"2.3单线程异步",frontmatter:{title:"2.3单线程异步",date:"2022-05-31T19:10:27.000Z",permalink:"/pages/d3ef38/"},regularPath:"/01.%E6%8C%87%E5%8D%97/01.ETBbook_%E4%B8%AD%E6%96%87/23.2.3%E5%8D%95%E7%BA%BF%E7%A8%8B%E5%BC%82%E6%AD%A5.html",relativePath:"01.指南/01.ETBbook_中文/23.2.3单线程异步.md",key:"v-72b8a039",path:"/pages/d3ef38/",headersStr:null,content:'# 单线程异步\n\n前面几个例子都是多线程实现的异步，但是异步显然不仅仅是多线程的。我们在之前的例子中使用了Sleep来实现时间的等待，每一个计时器都需要使用一个线程，会导致线程切换频繁，这个实现效率很低，平常是不会这样做的。一般游戏逻辑中会设计一个单线程的计时器，我们这里做一个简单的实现，用来讲解单线程异步。\n\n    // example2_3\n    class Program\n    {\n        private static int loopCount = 0;\n\n        private static long time;\n        private static Action action;\n        \n        static void Main(string[] args)\n        {\n            Console.WriteLine($"主线程: {Thread.CurrentThread.ManagedThreadId}");\n\n            Crontine();\n            \n            while (true)\n            {\n                Thread.Sleep(1);\n\n                CheckTimerOut();\n                \n                ++loopCount;\n                if (loopCount % 10000 == 0)\n                {\n                    Console.WriteLine($"loop count: {loopCount}");\n                }\n            }\n        }\n        \n        private static void Crontine()\n        {\n            WaitTimeAsync(5000, WaitTimeAsyncCallback1);\n        }\n\n        private static void WaitTimeAsyncCallback1()\n        {\n            Console.WriteLine($"当前线程: {Thread.CurrentThread.ManagedThreadId}, WaitTimeAsync finsih loopCount的值是: {loopCount}");\n            WaitTimeAsync(4000, WaitTimeAsyncCallback2);\n        }\n        \n        private static void WaitTimeAsyncCallback2()\n        {\n            Console.WriteLine($"当前线程: {Thread.CurrentThread.ManagedThreadId}, WaitTimeAsync finsih loopCount的值是: {loopCount}");\n            WaitTimeAsync(3000, WaitTimeAsyncCallback3);\n        }\n        \n        private static void WaitTimeAsyncCallback3()\n        {\n            Console.WriteLine($"当前线程: {Thread.CurrentThread.ManagedThreadId}, WaitTimeAsync finsih loopCount的值是: {loopCount}");\n        }\n\n        private static void CheckTimerOut()\n        {\n            if (time == 0)\n            {\n                return;\n            }\n            long nowTicks = DateTime.Now.Ticks / 10000;\n            if (time > nowTicks)\n            {\n                return;\n            }\n\n            time = 0;\n            action.Invoke();\n        }\n        \n        private static void WaitTimeAsync(int waitTime, Action a)\n        {\n            time = DateTime.Now.Ticks / 10000 + waitTime;\n            action = a;\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n\n\n这个例子同样实现了一个简单的计时方法，WaitTimeAsync调用时会将回调方法跟时间记录下来，主线程每帧都会调用CheckTimerOut，CheckTimerOut里面判断计时器是否过期，过期了则调用回调方法。整个逻辑都在主线程中完成，同样是异步方法。所以异步并非多线程，单线程同样可以异步。上面的例子同样可以改成await的形式。\n\n    // example2_3_2\n    class Program\n    {\n        private static int loopCount = 0;\n\n        private static long time;\n        private static TaskCompletionSource<bool> tcs;\n        \n        static void Main(string[] args)\n        {\n            Console.WriteLine($"主线程: {Thread.CurrentThread.ManagedThreadId}");\n\n            Crontine();\n            \n            while (true)\n            {\n                Thread.Sleep(1);\n\n                CheckTimerOut();\n                \n                ++loopCount;\n                if (loopCount % 10000 == 0)\n                {\n                    Console.WriteLine($"loop count: {loopCount}");\n                }\n            }\n        }\n        \n        private static async void Crontine()\n        {\n            await WaitTimeAsync(5000);\n            Console.WriteLine($"当前线程: {Thread.CurrentThread.ManagedThreadId}, WaitTimeAsync finsih loopCount的值是: {loopCount}");\n            await WaitTimeAsync(4000);\n            Console.WriteLine($"当前线程: {Thread.CurrentThread.ManagedThreadId}, WaitTimeAsync finsih loopCount的值是: {loopCount}");\n            await WaitTimeAsync(3000);\n            Console.WriteLine($"当前线程: {Thread.CurrentThread.ManagedThreadId}, WaitTimeAsync finsih loopCount的值是: {loopCount}");\n        }\n\n        private static void CheckTimerOut()\n        {\n            if (time == 0)\n            {\n                return;\n            }\n            long nowTicks = DateTime.Now.Ticks / 10000;\n            if (time > nowTicks)\n            {\n                return;\n            }\n\n            time = 0;\n            tcs.SetResult(true);\n        }\n        \n        private static Task WaitTimeAsync(int waitTime)\n        {\n            TaskCompletionSource<bool> t = new TaskCompletionSource<bool>();\n            time = DateTime.Now.Ticks / 10000 + waitTime;\n            tcs = t;\n            return t.Task;\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n\n\n上面这个例子所有调用全部在主线程中完成，并且使用了await，因此await并不会开启多线程，await具体用没用多线程完全取决于具体的实现',normalizedContent:'# 单线程异步\n\n前面几个例子都是多线程实现的异步，但是异步显然不仅仅是多线程的。我们在之前的例子中使用了sleep来实现时间的等待，每一个计时器都需要使用一个线程，会导致线程切换频繁，这个实现效率很低，平常是不会这样做的。一般游戏逻辑中会设计一个单线程的计时器，我们这里做一个简单的实现，用来讲解单线程异步。\n\n    // example2_3\n    class program\n    {\n        private static int loopcount = 0;\n\n        private static long time;\n        private static action action;\n        \n        static void main(string[] args)\n        {\n            console.writeline($"主线程: {thread.currentthread.managedthreadid}");\n\n            crontine();\n            \n            while (true)\n            {\n                thread.sleep(1);\n\n                checktimerout();\n                \n                ++loopcount;\n                if (loopcount % 10000 == 0)\n                {\n                    console.writeline($"loop count: {loopcount}");\n                }\n            }\n        }\n        \n        private static void crontine()\n        {\n            waittimeasync(5000, waittimeasynccallback1);\n        }\n\n        private static void waittimeasynccallback1()\n        {\n            console.writeline($"当前线程: {thread.currentthread.managedthreadid}, waittimeasync finsih loopcount的值是: {loopcount}");\n            waittimeasync(4000, waittimeasynccallback2);\n        }\n        \n        private static void waittimeasynccallback2()\n        {\n            console.writeline($"当前线程: {thread.currentthread.managedthreadid}, waittimeasync finsih loopcount的值是: {loopcount}");\n            waittimeasync(3000, waittimeasynccallback3);\n        }\n        \n        private static void waittimeasynccallback3()\n        {\n            console.writeline($"当前线程: {thread.currentthread.managedthreadid}, waittimeasync finsih loopcount的值是: {loopcount}");\n        }\n\n        private static void checktimerout()\n        {\n            if (time == 0)\n            {\n                return;\n            }\n            long nowticks = datetime.now.ticks / 10000;\n            if (time > nowticks)\n            {\n                return;\n            }\n\n            time = 0;\n            action.invoke();\n        }\n        \n        private static void waittimeasync(int waittime, action a)\n        {\n            time = datetime.now.ticks / 10000 + waittime;\n            action = a;\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n\n\n这个例子同样实现了一个简单的计时方法，waittimeasync调用时会将回调方法跟时间记录下来，主线程每帧都会调用checktimerout，checktimerout里面判断计时器是否过期，过期了则调用回调方法。整个逻辑都在主线程中完成，同样是异步方法。所以异步并非多线程，单线程同样可以异步。上面的例子同样可以改成await的形式。\n\n    // example2_3_2\n    class program\n    {\n        private static int loopcount = 0;\n\n        private static long time;\n        private static taskcompletionsource<bool> tcs;\n        \n        static void main(string[] args)\n        {\n            console.writeline($"主线程: {thread.currentthread.managedthreadid}");\n\n            crontine();\n            \n            while (true)\n            {\n                thread.sleep(1);\n\n                checktimerout();\n                \n                ++loopcount;\n                if (loopcount % 10000 == 0)\n                {\n                    console.writeline($"loop count: {loopcount}");\n                }\n            }\n        }\n        \n        private static async void crontine()\n        {\n            await waittimeasync(5000);\n            console.writeline($"当前线程: {thread.currentthread.managedthreadid}, waittimeasync finsih loopcount的值是: {loopcount}");\n            await waittimeasync(4000);\n            console.writeline($"当前线程: {thread.currentthread.managedthreadid}, waittimeasync finsih loopcount的值是: {loopcount}");\n            await waittimeasync(3000);\n            console.writeline($"当前线程: {thread.currentthread.managedthreadid}, waittimeasync finsih loopcount的值是: {loopcount}");\n        }\n\n        private static void checktimerout()\n        {\n            if (time == 0)\n            {\n                return;\n            }\n            long nowticks = datetime.now.ticks / 10000;\n            if (time > nowticks)\n            {\n                return;\n            }\n\n            time = 0;\n            tcs.setresult(true);\n        }\n        \n        private static task waittimeasync(int waittime)\n        {\n            taskcompletionsource<bool> t = new taskcompletionsource<bool>();\n            time = datetime.now.ticks / 10000 + waittime;\n            tcs = t;\n            return t.task;\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n\n\n上面这个例子所有调用全部在主线程中完成，并且使用了await，因此await并不会开启多线程，await具体用没用多线程完全取决于具体的实现',charsets:{cjk:!0},lastUpdated:"2022/07/25, 23:10:19",lastUpdatedTimestamp:1658761819e3},{title:"3.2强大的MongoBson库",frontmatter:{title:"3.2强大的MongoBson库",date:"2022-05-31T19:10:27.000Z",permalink:"/pages/037ea6/"},regularPath:"/01.%E6%8C%87%E5%8D%97/01.ETBbook_%E4%B8%AD%E6%96%87/32.3.2%E5%BC%BA%E5%A4%A7%E7%9A%84MongoBson%E5%BA%93.html",relativePath:"01.指南/01.ETBbook_中文/32.3.2强大的MongoBson库.md",key:"v-7d704a16",path:"/pages/037ea6/",headers:[{level:3,title:"1.支持序列化反序列化成json或者bson",slug:"_1-支持序列化反序列化成json或者bson",normalizedTitle:"1.支持序列化反序列化成json或者bson",charIndex:948},{level:3,title:"2.可以忽略某些字段",slug:"_2-可以忽略某些字段",normalizedTitle:"2.可以忽略某些字段",charIndex:2450},{level:3,title:"3.支持默认值以及取别名",slug:"_3-支持默认值以及取别名",normalizedTitle:"3.支持默认值以及取别名",charIndex:2872},{level:3,title:"4.升级版本支持",slug:"_4-升级版本支持",normalizedTitle:"4.升级版本支持",charIndex:3376},{level:3,title:"5.支持复杂的继承结构",slug:"_5-支持复杂的继承结构",normalizedTitle:"5.支持复杂的继承结构",charIndex:3719},{level:3,title:"6.ISupportInitialize接口",slug:"_6-isupportinitialize接口",normalizedTitle:"6.isupportinitialize接口",charIndex:4671}],headersStr:"1.支持序列化反序列化成json或者bson 2.可以忽略某些字段 3.支持默认值以及取别名 4.升级版本支持 5.支持复杂的继承结构 6.ISupportInitialize接口",content:'# 强大的MongoBson库\n\n后端开发，统计了一下大概有这些场景需要用到序列化：\n\n 1. 对象通过序列化反序列化clone\n 2. 服务端数据库存储数据，二进制\n 3. 分布式服务端，多进程间的消息，二进制\n 4. 后端日志，文本格式\n 5. 服务端的各种配置文件，文本格式\n\nC#序列化库有非常非常多了，protobuf，json等等。但是这些序列化库都无法应当所有场景，既要可读又要小。protobuf不支持复杂的对象结构（无法使用继承），做消息合适，做数据库存储和日志格式并不好用。json做日志格式合适，但是做网络消息和数据存储就太大。我们当然希望一个库能满足上面所有场景，理由如下：\n\n 1. 你想想某天你的配置文件需要放到数据库中保存，你不需要进行格式转换，后端直接把前端发过来的配置消息保存到数据库中，这是不是能减少非常多错误呢？\n 2. 某天有些服务端的配置文件不用文件格式了，需要放在数据库中，同样，只需要几行代码就可以完成迁移。\n 3. 某天后端服务器crash，你需要扫描日志进行数据恢复，把日志进行反序列化成C#对象，一条条进行处理，再转成对象保存到数据库就完成了。\n 4. 对象保存在数据库，直接就可以看到文本内容，可以做各种类sql的操作\n 5. 想像一个场景，一个配置文本对象，反序列化到内存，通过网络消息发送，存储到数据库中。整个过程一气呵成。\n\n简单来说就是减少各种数据转换，减少代码，提高开发效率，提高可维护性。当然，Mongo Bson就能够满足。MongoDB库既可以序列化成文本也可以序列化成BSON的二进制格式，并且MongoDB本身就是一个游戏中使用非常多的数据库。Mongo Bson非常完善，是我见过功能最全使用最强大的序列化库，有些功能十分贴心。其支持功能如下：\n\n 1. 支持复杂的继承结构\n 2. 支持忽略某些字段序列化\n 3. 支持字段默认值\n 4. 结构多出多余的字段照样可以反序列化，这对多版本协议非常有用\n 5. 支持ISupportInitialize接口使用，这个在反序列化的时候简直就是神器\n 6. 支持文本json和二进制bson序列化\n 7. MongoDB数据库支持\n\n简单的介绍下mongo bson库\n\n\n# 1.支持序列化反序列化成json或者bson\n\n    public sealed class Player\n    {\n        public long Id;\n\n        public string Account { get; private set; }\n\n        public long UnitId { get; set; }\n    }\n\n    Player player1 = new Player() { Id = 1 };\n    string json = player1.ToJson();\n    Console.WriteLine($"player1 to json: {json}");\n    Console.WriteLine($"player to bson: {player.ToBson().ToHex()}");\n    // output:\n    // player to json: { "_id" : NumberLong(1), "C" : [], "Account" : null, "UnitId" : NumberLong(0) }\n    // player to bson: B000000125F69640001000000000000000A4163636F756E740012556E6974496400000000000000000000\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n注意mongo的json跟标准的json有点区别，如果想用标准的json，可以传入一个JsonWriterSettings对象，限制使用JsonOutputMode.Strict模式\n\n    // 使用标准json\n    Player player2 = new Player() { Id = 1 };\n    Console.WriteLine($"player to json: {player2.ToJson(new JsonWriterSettings() {OutputMode = JsonOutputMode.Strict})}");\n    // player to json: { "_id" : 1, "C" : [], "Account" : null, "UnitId" : 0 }\n\n\n1\n2\n3\n4\n\n\n反序列化json:\n\n            // 反序列化json\n        Player player11 = BsonSerializer.Deserialize<Player>(json);\n        Console.WriteLine($"player11 to json: {player11.ToJson()}");\n\n\n1\n2\n3\n\n\n反序列化bson:\n\n    // 反序列化bson\n    using (MemoryStream memoryStream = new MemoryStream(bson))\n    {\n        Player player12 = (Player) BsonSerializer.Deserialize(memoryStream, typeof (Player));\n        Console.WriteLine($"player12 to json: {player12.ToJson()}");\n    }\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 2.可以忽略某些字段\n\n[BsonIgnore]该标签用来禁止字段序列化。\n\n\tpublic sealed class Player\n\t{\n        public long Id;\n\n\t\t[BsonIgnore]\n\t\tpublic string Account { get; private set; }\n\t\t\n\t\tpublic long UnitId { get; set; }\n    ｝\n\n    Player player = new Player() { Id = 2, UnitId = 3, Account = "panda"};\n\tConsole.WriteLine($"player to json: {player.ToJson()}");\n    // player to json: { "_id" : 2, "UnitId" : 3 }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 3.支持默认值以及取别名\n\n[BsonElement] 字段加上该标签，即使是private字段也会序列化(默认只序列化public字段)，该标签还可以带一个string参数，给字段序列化指定别名。\n\n\tpublic sealed class Player\n\t{\n        public long Id;\n\n\t\tpublic string Account { get; private set; }\n\n\t\t[BsonElement("UId")]\n\t\tpublic long UnitId { get; set; }\n    ｝\n    Player player = new Player() { Id = 2, UnitId = 3, Account = "panda"};\n\tConsole.WriteLine($"player to json: {player.ToJson()}");\n    // player to json: { "_id" : 2, "Account" : "panda", "UId" : 3 }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 4.升级版本支持\n\n[BsonIgnoreExtraElements] 该标签用在class上面，反序列化时用来忽略多余的字段，一般版本兼容需要考虑，低版本的协议需要能够反 序列化高版本的内容,否则新版本加了字段，旧版本结构反序列化会出错\n\n\t[BsonIgnoreExtraElements]\n\tpublic sealed class Player\n\t{\n        public long Id;\n\n\t\tpublic string Account { get; private set; }\n\n\t\t[BsonElement("UId")]\n\t\tpublic long UnitId { get; set; }\n    ｝\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 5.支持复杂的继承结构\n\nmongo bson库强大的地方在于完全支持序列化反序列化继承结构。需要注意的是，继承反序列化需要注册所有的父类，有两种方法： a. 你可以在父类上面使用[BsonKnownTypes]标签声明继承的子类，这样mongo会自动注册，例如:\n\n    [BsonKnownTypes(typeof(Entity))]\n    public class Component\n    {\n    }\n    [BsonKnownTypes(typeof(Player))]\n    public class Entity: Component\n    {\n    }\n    public sealed class Player: Entity\n    {\n        public long Id;\n        \n        public string Account { get; set; }\n\t\t\n        public long UnitId { get; set; }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n这样有缺陷，因为框架并不知道一个类会有哪些子类，这样做对框架代码有侵入性，我们希望能解除这个耦合 。可以扫描程序集中所有子类父类的类型，将他们注册到mongo驱动中\n\n\t\t\tType[] types = typeof(Game).Assembly.GetTypes();\n\t\t\tforeach (Type type in types)\n\t\t\t{\n\t\t\t\tif (!type.IsSubclassOf(typeof(Component)))\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tBsonClassMap.LookupClassMap(type);\n\t\t\t}\n\n\t\t\tBsonSerializer.RegisterSerializer(new EnumSerializer<NumericType>(BsonType.String));\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n这样完全的自动化注册，使用者也不需要关系类是否注册。\n\n\n# 6.ISupportInitialize接口\n\nmongo bson反序列化时支持一个ISupportInitialize接口，ISupportInitialize有两个方法\n\n    public interface ISupportInitialize\n    {\n        void BeginInit();\n        void EndInit();\n    }\n\n\n1\n2\n3\n4\n5\n\n\nBeginInit在反序列化前调用，EndInit在反序列化后调用。这个接口非常有用了，可以在反序列化后执行一些操作。例如\n\n\t[BsonIgnoreExtraElements]\n\tpublic class InnerConfig: AConfigComponent\n\t{\n\t\t[BsonIgnore]\n\t\tpublic IPEndPoint IPEndPoint { get; private set; }\n\t\t\n\t\tpublic string Address { get; set; }\n\n\t\tpublic override void EndInit()\n\t\t{\n\t\t\tthis.IPEndPoint = NetworkHelper.ToIPEndPoint(this.Address);\n\t\t}\n\t}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nInnerConfig是ET中进程内网地址的配置，由于IPEndPoint不太好配置，我们可以配置成string形式，然后反序列化的时候在EndInit中把string转换成IPEndPoint。 同样我给protobuf反序列化方法也加上了这个调用，参考ProtobufHelper.cs，ET的protobuf因为要支持ilruntime，所以去掉了map的支持，假如我们想要一个map怎么办呢？这里我给生成的代码都做了手脚，把proto消息都改成了partial class，这样我们可以自己扩展这个class，比如：\n\nmessage UnitInfo\n{\n\tint64 UnitId  = 1;\n\n\tfloat X = 2;\n\tfloat Y = 3;\n\tfloat Z = 4;\n}\n\n// protobuf\nmessage G2C_EnterMap // IResponse\n{\n\tint32 RpcId = 90;\n\tint32 Error = 91;\n\tstring Message = 92;\n\t// 自己的unit id\n\tint64 UnitId = 1;\n\t// 所有的unit\n\trepeated UnitInfo Units = 2;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n这个网络消息有个repeated UnitInfo字段，在protobuf中其实是个数组，使用起来不是很方便，我希望转成一个Dictionary<Int64, UnitInfo>的字段，我们可以做这样的操作：\n\n    public partial class G2C_EnterMap: ISupportInitialize\n    {\n        public Dictionary<Int64, UnitInfo> unitsDict = new Dictionary<long, UnitInfo>();\n        \n        public void BeginInit()\n        {\n        }\n\n        public void EndInit()\n        {\n            foreach (var unit in this.Units)\n            {\n                this.unitsDict.Add(unit.UnitId, unit);\n            }\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n通过这样一段代码把消息进行扩展一下，反序列化出来之后，自动转成了一个Dictionary。',normalizedContent:'# 强大的mongobson库\n\n后端开发，统计了一下大概有这些场景需要用到序列化：\n\n 1. 对象通过序列化反序列化clone\n 2. 服务端数据库存储数据，二进制\n 3. 分布式服务端，多进程间的消息，二进制\n 4. 后端日志，文本格式\n 5. 服务端的各种配置文件，文本格式\n\nc#序列化库有非常非常多了，protobuf，json等等。但是这些序列化库都无法应当所有场景，既要可读又要小。protobuf不支持复杂的对象结构（无法使用继承），做消息合适，做数据库存储和日志格式并不好用。json做日志格式合适，但是做网络消息和数据存储就太大。我们当然希望一个库能满足上面所有场景，理由如下：\n\n 1. 你想想某天你的配置文件需要放到数据库中保存，你不需要进行格式转换，后端直接把前端发过来的配置消息保存到数据库中，这是不是能减少非常多错误呢？\n 2. 某天有些服务端的配置文件不用文件格式了，需要放在数据库中，同样，只需要几行代码就可以完成迁移。\n 3. 某天后端服务器crash，你需要扫描日志进行数据恢复，把日志进行反序列化成c#对象，一条条进行处理，再转成对象保存到数据库就完成了。\n 4. 对象保存在数据库，直接就可以看到文本内容，可以做各种类sql的操作\n 5. 想像一个场景，一个配置文本对象，反序列化到内存，通过网络消息发送，存储到数据库中。整个过程一气呵成。\n\n简单来说就是减少各种数据转换，减少代码，提高开发效率，提高可维护性。当然，mongo bson就能够满足。mongodb库既可以序列化成文本也可以序列化成bson的二进制格式，并且mongodb本身就是一个游戏中使用非常多的数据库。mongo bson非常完善，是我见过功能最全使用最强大的序列化库，有些功能十分贴心。其支持功能如下：\n\n 1. 支持复杂的继承结构\n 2. 支持忽略某些字段序列化\n 3. 支持字段默认值\n 4. 结构多出多余的字段照样可以反序列化，这对多版本协议非常有用\n 5. 支持isupportinitialize接口使用，这个在反序列化的时候简直就是神器\n 6. 支持文本json和二进制bson序列化\n 7. mongodb数据库支持\n\n简单的介绍下mongo bson库\n\n\n# 1.支持序列化反序列化成json或者bson\n\n    public sealed class player\n    {\n        public long id;\n\n        public string account { get; private set; }\n\n        public long unitid { get; set; }\n    }\n\n    player player1 = new player() { id = 1 };\n    string json = player1.tojson();\n    console.writeline($"player1 to json: {json}");\n    console.writeline($"player to bson: {player.tobson().tohex()}");\n    // output:\n    // player to json: { "_id" : numberlong(1), "c" : [], "account" : null, "unitid" : numberlong(0) }\n    // player to bson: b000000125f69640001000000000000000a4163636f756e740012556e6974496400000000000000000000\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n注意mongo的json跟标准的json有点区别，如果想用标准的json，可以传入一个jsonwritersettings对象，限制使用jsonoutputmode.strict模式\n\n    // 使用标准json\n    player player2 = new player() { id = 1 };\n    console.writeline($"player to json: {player2.tojson(new jsonwritersettings() {outputmode = jsonoutputmode.strict})}");\n    // player to json: { "_id" : 1, "c" : [], "account" : null, "unitid" : 0 }\n\n\n1\n2\n3\n4\n\n\n反序列化json:\n\n            // 反序列化json\n        player player11 = bsonserializer.deserialize<player>(json);\n        console.writeline($"player11 to json: {player11.tojson()}");\n\n\n1\n2\n3\n\n\n反序列化bson:\n\n    // 反序列化bson\n    using (memorystream memorystream = new memorystream(bson))\n    {\n        player player12 = (player) bsonserializer.deserialize(memorystream, typeof (player));\n        console.writeline($"player12 to json: {player12.tojson()}");\n    }\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 2.可以忽略某些字段\n\n[bsonignore]该标签用来禁止字段序列化。\n\n\tpublic sealed class player\n\t{\n        public long id;\n\n\t\t[bsonignore]\n\t\tpublic string account { get; private set; }\n\t\t\n\t\tpublic long unitid { get; set; }\n    ｝\n\n    player player = new player() { id = 2, unitid = 3, account = "panda"};\n\tconsole.writeline($"player to json: {player.tojson()}");\n    // player to json: { "_id" : 2, "unitid" : 3 }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 3.支持默认值以及取别名\n\n[bsonelement] 字段加上该标签，即使是private字段也会序列化(默认只序列化public字段)，该标签还可以带一个string参数，给字段序列化指定别名。\n\n\tpublic sealed class player\n\t{\n        public long id;\n\n\t\tpublic string account { get; private set; }\n\n\t\t[bsonelement("uid")]\n\t\tpublic long unitid { get; set; }\n    ｝\n    player player = new player() { id = 2, unitid = 3, account = "panda"};\n\tconsole.writeline($"player to json: {player.tojson()}");\n    // player to json: { "_id" : 2, "account" : "panda", "uid" : 3 }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 4.升级版本支持\n\n[bsonignoreextraelements] 该标签用在class上面，反序列化时用来忽略多余的字段，一般版本兼容需要考虑，低版本的协议需要能够反 序列化高版本的内容,否则新版本加了字段，旧版本结构反序列化会出错\n\n\t[bsonignoreextraelements]\n\tpublic sealed class player\n\t{\n        public long id;\n\n\t\tpublic string account { get; private set; }\n\n\t\t[bsonelement("uid")]\n\t\tpublic long unitid { get; set; }\n    ｝\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 5.支持复杂的继承结构\n\nmongo bson库强大的地方在于完全支持序列化反序列化继承结构。需要注意的是，继承反序列化需要注册所有的父类，有两种方法： a. 你可以在父类上面使用[bsonknowntypes]标签声明继承的子类，这样mongo会自动注册，例如:\n\n    [bsonknowntypes(typeof(entity))]\n    public class component\n    {\n    }\n    [bsonknowntypes(typeof(player))]\n    public class entity: component\n    {\n    }\n    public sealed class player: entity\n    {\n        public long id;\n        \n        public string account { get; set; }\n\t\t\n        public long unitid { get; set; }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n这样有缺陷，因为框架并不知道一个类会有哪些子类，这样做对框架代码有侵入性，我们希望能解除这个耦合 。可以扫描程序集中所有子类父类的类型，将他们注册到mongo驱动中\n\n\t\t\ttype[] types = typeof(game).assembly.gettypes();\n\t\t\tforeach (type type in types)\n\t\t\t{\n\t\t\t\tif (!type.issubclassof(typeof(component)))\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tbsonclassmap.lookupclassmap(type);\n\t\t\t}\n\n\t\t\tbsonserializer.registerserializer(new enumserializer<numerictype>(bsontype.string));\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n这样完全的自动化注册，使用者也不需要关系类是否注册。\n\n\n# 6.isupportinitialize接口\n\nmongo bson反序列化时支持一个isupportinitialize接口，isupportinitialize有两个方法\n\n    public interface isupportinitialize\n    {\n        void begininit();\n        void endinit();\n    }\n\n\n1\n2\n3\n4\n5\n\n\nbegininit在反序列化前调用，endinit在反序列化后调用。这个接口非常有用了，可以在反序列化后执行一些操作。例如\n\n\t[bsonignoreextraelements]\n\tpublic class innerconfig: aconfigcomponent\n\t{\n\t\t[bsonignore]\n\t\tpublic ipendpoint ipendpoint { get; private set; }\n\t\t\n\t\tpublic string address { get; set; }\n\n\t\tpublic override void endinit()\n\t\t{\n\t\t\tthis.ipendpoint = networkhelper.toipendpoint(this.address);\n\t\t}\n\t}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\ninnerconfig是et中进程内网地址的配置，由于ipendpoint不太好配置，我们可以配置成string形式，然后反序列化的时候在endinit中把string转换成ipendpoint。 同样我给protobuf反序列化方法也加上了这个调用，参考protobufhelper.cs，et的protobuf因为要支持ilruntime，所以去掉了map的支持，假如我们想要一个map怎么办呢？这里我给生成的代码都做了手脚，把proto消息都改成了partial class，这样我们可以自己扩展这个class，比如：\n\nmessage unitinfo\n{\n\tint64 unitid  = 1;\n\n\tfloat x = 2;\n\tfloat y = 3;\n\tfloat z = 4;\n}\n\n// protobuf\nmessage g2c_entermap // iresponse\n{\n\tint32 rpcid = 90;\n\tint32 error = 91;\n\tstring message = 92;\n\t// 自己的unit id\n\tint64 unitid = 1;\n\t// 所有的unit\n\trepeated unitinfo units = 2;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n这个网络消息有个repeated unitinfo字段，在protobuf中其实是个数组，使用起来不是很方便，我希望转成一个dictionary<int64, unitinfo>的字段，我们可以做这样的操作：\n\n    public partial class g2c_entermap: isupportinitialize\n    {\n        public dictionary<int64, unitinfo> unitsdict = new dictionary<long, unitinfo>();\n        \n        public void begininit()\n        {\n        }\n\n        public void endinit()\n        {\n            foreach (var unit in this.units)\n            {\n                this.unitsdict.add(unit.unitid, unit);\n            }\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n通过这样一段代码把消息进行扩展一下，反序列化出来之后，自动转成了一个dictionary。',charsets:{cjk:!0},lastUpdated:"2022/07/25, 23:10:19",lastUpdatedTimestamp:1658761819e3},{title:"3.3一切皆组件",frontmatter:{title:"3.3一切皆组件",date:"2022-05-31T19:10:27.000Z",permalink:"/pages/81bdb3/"},regularPath:"/01.%E6%8C%87%E5%8D%97/01.ETBbook_%E4%B8%AD%E6%96%87/33.3.3%E4%B8%80%E5%88%87%E7%9A%86%E7%BB%84%E4%BB%B6.html",relativePath:"01.指南/01.ETBbook_中文/33.3.3一切皆组件.md",key:"v-18a6fca4",path:"/pages/81bdb3/",headers:[{level:3,title:"1.组件的创建",slug:"_1-组件的创建",normalizedTitle:"1.组件的创建",charIndex:1888},{level:3,title:"2.组件的释放",slug:"_2-组件的释放",normalizedTitle:"2.组件的释放",charIndex:2273},{level:3,title:"3.InstanceId的作用",slug:"_3-instanceid的作用",normalizedTitle:"3.instanceid的作用",charIndex:2529}],headersStr:"1.组件的创建 2.组件的释放 3.InstanceId的作用",content:"# 一切皆组件\n\n目前十分流行ECS设计，主要是守望先锋的成功，引爆了这种技术。守望先锋采用了状态帧这种网络技术，客户端会进行预测，预测不准需要进行回滚，由于组件式的设计，回滚可以只回滚某些组件即可。ECS最重要的设计是逻辑跟数据的完全分离。即EC是纯数据，System实际上就是逻辑，由数据驱动逻辑。数据驱动逻辑是什么意思呢？很简单通过Update检测数据变化，通过事件机制来订阅数据变化，这就是所谓的数据驱动了。其它的特点例如缓存命中，在编写逻辑上来说并不太重要，现代游戏都用脚本，连脚本的性能都能容忍怎么会在乎缓存命中那点性能提升？ET在设计的时候吸收了这些想法，但是并不完全照搬，目前的设计是我经过长期的思考跟重构得来的，还是有些自己特色。\n\n传统的ECS写逻辑作者看来存在不少缺陷，比如为了复用，数据必然要拆成非常小的颗粒，会导致组件非常非常多。但是游戏是多人合作开发的，每个人基本上只熟悉自己的模块，最后可能造成组件大量冗余。还有个问题，常见的ECS是扁平式的，Entity跟Component只有一层。组件一多，开发功能可能不知道该使用哪些Component。好比一家公司，最大的是老板，老板手下带几百个人，老板不可能认识所有的人，完成一项任务，老板没法挑出自己需要的人。合理的做法是老板手下应该有几个经理，每个经理手下应该有几个主管，每个主管管理几个工人，这样形成树状的管理结构才会容易管理。这类似ET的做法，Entity可以管理Component，Component管理Entity，甚至Component还可以挂载Component。例如：人由头，身体，手，脚组成，而头又由眼睛，耳朵，鼻子，嘴巴组成。\n\n    Head head = human.AddComponent<Head>();\n    head.AddComponent<Eye>();\n    head.AddComponent<Mouse>();\n    head.AddComponent<Nose>();\n    head.AddComponent<Ear>();\n    human.AddComponent<Body>();\n    human.AddComponent<Hand>();\n    human.AddComponent<Leg>();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nET中，所有数据都是Component，包括Entity，Entity继承于ComponentWithId，ComponentWithId继承于Component，所以Entity本质上也是一个Component，只不过它可以挂载其它的Component。实际使用中你可以继承Component，ComponentWithId，Entity三者之一，区别是如果该类需要挂载组件则继承Entity，如果不需要挂载组件但是需要带个逻辑Id则继承ComponentWithId，剩下的继承Component。ET的Entity是可以有数据成员的，通用的数据放在Entity身上作为成员，不太通用的数据可以作为组件挂在Entity身上。比如物品的设计，所有物品都有配置id，数量，等级的字段，这些字段没有必要做成组件，放在Entity身上使用会更加方便。\n\n    class Item: Entity\n    {\n        // 道具的配置Id\n        public int ConfigId { get; set; }\n        // 道具的数量\n        public int Count { get; set; }\n        // 道具的等级\n        public int Level { get; set; }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nET的这种设计数据是一种树状的结构，非常有层次，能够非常轻松的理解整个游戏的架构。顶层Game.Scene，不同模块的数据都挂载在Game.Scene上面，每个模块自身下面又可以挂载很多数据。每开发一个新功能不用思考太多，类该怎么设计，数据放在什么地方，挂载这里会不会导致冗余等等。比如我玩家需要做一个道具系统，设计一个ItemsComponent挂在Player身上即可，需要技能开发一个SpellComponent挂在Player身上。全服需要做一个活动，搞个活动组件挂在Game.Scene上面。这种设计任务分派会很简单，十分的模块化。\n\n\n# 组件的一些细节\n\n\n# 1.组件的创建\n\n组件的创建不要自己去new，应该统一使用ComponentFactory创建。ComponentFactory提供了三组方法用来创建组件Create，CreateWithParent，CreateWithId。Create是最简单的创建方式，它做了几个处理\na. 根据组件类型构造一个组件\nb. 将组件加入事件系统，并且抛出一个AwakeSystem\nc. 是否启用对象池\nCreateWithParent在Create的基础上提供了一个Parent对象，设置到Component.Parent字段上。CreateWithId是用来创建ComponentWithId或者其子类的，在Create的基础上可以自己设置一个Id, Component在创建的时候可以选择是否使用对象池。三类工厂方法都带有一个fromPool的参数，默认是true。\n\n\n# 2.组件的释放\n\nComponent都继承了一个IDisposable接口，需要注意，Component有非托管资源，删除一个Component必须调用该接口。该接口做了如下的操作\na. 抛出Destroy System\nb. 如果组件是使用对象池创建的，那么在这里会放回对象池\nc. 从全局事件系统(EventSystem)中删除该组件，并且将InstanceId设为0\n如果组件挂载Entity身上，那么Entity调用Dispose的时候会自动调用身上所有Component的Dispose方法。\n\n\n# 3.InstanceId的作用\n\n任何Component都带有一个InstanceId字段，这个字段会在组件构造，或者组件从对象池取出的时候重新设置，这个InstanceId标识这个组件的身份。为什么需要这么一个字段呢？有以下几个原因\n\n 1. 对象池的存在，组件未必会释放，而是回到对象池中。在异步调用中，很可能这个组件已经被释放了，然后又被重新利用了起来，这样我们需要一种方式能区分之前的组件对象是否已经被释放，例如下面这段代码：\n\n\t\tpublic static async ETVoid UpdateAsync(this ActorLocationSender self)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tlong instanceId = self.InstanceId;\n\t\t\t\twhile (true)\n\t\t\t\t{\n\t\t\t\t\tif (self.InstanceId != instanceId)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tActorTask actorTask = await self.GetAsync();\n\t\t\t\t\t\n\t\t\t\t\tif (self.InstanceId != instanceId)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif (actorTask.ActorRequest == null)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tawait self.RunTask(actorTask);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e)\n\t\t\t{\n\t\t\t\tLog.Error(e);\n\t\t\t}\n\t\t}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\nwhile (true)中是段异步方法，await self.GetAsync()之后很可能ActorLocationSender对象已经被释放了，甚至有可能这个对象又被其它逻辑从对象池中再次利用了起来。我们这时候可以通过InstanceId的变化来判断这个对象是否已经被释放掉。\n2. InstanceId是全局唯一的，并且带有位置信息，可以通过InstanceId来找到对象的位置，将消息发给对象。这个设计将会Actor消息中利用到。这里暂时就不讲了。",normalizedContent:"# 一切皆组件\n\n目前十分流行ecs设计，主要是守望先锋的成功，引爆了这种技术。守望先锋采用了状态帧这种网络技术，客户端会进行预测，预测不准需要进行回滚，由于组件式的设计，回滚可以只回滚某些组件即可。ecs最重要的设计是逻辑跟数据的完全分离。即ec是纯数据，system实际上就是逻辑，由数据驱动逻辑。数据驱动逻辑是什么意思呢？很简单通过update检测数据变化，通过事件机制来订阅数据变化，这就是所谓的数据驱动了。其它的特点例如缓存命中，在编写逻辑上来说并不太重要，现代游戏都用脚本，连脚本的性能都能容忍怎么会在乎缓存命中那点性能提升？et在设计的时候吸收了这些想法，但是并不完全照搬，目前的设计是我经过长期的思考跟重构得来的，还是有些自己特色。\n\n传统的ecs写逻辑作者看来存在不少缺陷，比如为了复用，数据必然要拆成非常小的颗粒，会导致组件非常非常多。但是游戏是多人合作开发的，每个人基本上只熟悉自己的模块，最后可能造成组件大量冗余。还有个问题，常见的ecs是扁平式的，entity跟component只有一层。组件一多，开发功能可能不知道该使用哪些component。好比一家公司，最大的是老板，老板手下带几百个人，老板不可能认识所有的人，完成一项任务，老板没法挑出自己需要的人。合理的做法是老板手下应该有几个经理，每个经理手下应该有几个主管，每个主管管理几个工人，这样形成树状的管理结构才会容易管理。这类似et的做法，entity可以管理component，component管理entity，甚至component还可以挂载component。例如：人由头，身体，手，脚组成，而头又由眼睛，耳朵，鼻子，嘴巴组成。\n\n    head head = human.addcomponent<head>();\n    head.addcomponent<eye>();\n    head.addcomponent<mouse>();\n    head.addcomponent<nose>();\n    head.addcomponent<ear>();\n    human.addcomponent<body>();\n    human.addcomponent<hand>();\n    human.addcomponent<leg>();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\net中，所有数据都是component，包括entity，entity继承于componentwithid，componentwithid继承于component，所以entity本质上也是一个component，只不过它可以挂载其它的component。实际使用中你可以继承component，componentwithid，entity三者之一，区别是如果该类需要挂载组件则继承entity，如果不需要挂载组件但是需要带个逻辑id则继承componentwithid，剩下的继承component。et的entity是可以有数据成员的，通用的数据放在entity身上作为成员，不太通用的数据可以作为组件挂在entity身上。比如物品的设计，所有物品都有配置id，数量，等级的字段，这些字段没有必要做成组件，放在entity身上使用会更加方便。\n\n    class item: entity\n    {\n        // 道具的配置id\n        public int configid { get; set; }\n        // 道具的数量\n        public int count { get; set; }\n        // 道具的等级\n        public int level { get; set; }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\net的这种设计数据是一种树状的结构，非常有层次，能够非常轻松的理解整个游戏的架构。顶层game.scene，不同模块的数据都挂载在game.scene上面，每个模块自身下面又可以挂载很多数据。每开发一个新功能不用思考太多，类该怎么设计，数据放在什么地方，挂载这里会不会导致冗余等等。比如我玩家需要做一个道具系统，设计一个itemscomponent挂在player身上即可，需要技能开发一个spellcomponent挂在player身上。全服需要做一个活动，搞个活动组件挂在game.scene上面。这种设计任务分派会很简单，十分的模块化。\n\n\n# 组件的一些细节\n\n\n# 1.组件的创建\n\n组件的创建不要自己去new，应该统一使用componentfactory创建。componentfactory提供了三组方法用来创建组件create，createwithparent，createwithid。create是最简单的创建方式，它做了几个处理\na. 根据组件类型构造一个组件\nb. 将组件加入事件系统，并且抛出一个awakesystem\nc. 是否启用对象池\ncreatewithparent在create的基础上提供了一个parent对象，设置到component.parent字段上。createwithid是用来创建componentwithid或者其子类的，在create的基础上可以自己设置一个id, component在创建的时候可以选择是否使用对象池。三类工厂方法都带有一个frompool的参数，默认是true。\n\n\n# 2.组件的释放\n\ncomponent都继承了一个idisposable接口，需要注意，component有非托管资源，删除一个component必须调用该接口。该接口做了如下的操作\na. 抛出destroy system\nb. 如果组件是使用对象池创建的，那么在这里会放回对象池\nc. 从全局事件系统(eventsystem)中删除该组件，并且将instanceid设为0\n如果组件挂载entity身上，那么entity调用dispose的时候会自动调用身上所有component的dispose方法。\n\n\n# 3.instanceid的作用\n\n任何component都带有一个instanceid字段，这个字段会在组件构造，或者组件从对象池取出的时候重新设置，这个instanceid标识这个组件的身份。为什么需要这么一个字段呢？有以下几个原因\n\n 1. 对象池的存在，组件未必会释放，而是回到对象池中。在异步调用中，很可能这个组件已经被释放了，然后又被重新利用了起来，这样我们需要一种方式能区分之前的组件对象是否已经被释放，例如下面这段代码：\n\n\t\tpublic static async etvoid updateasync(this actorlocationsender self)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tlong instanceid = self.instanceid;\n\t\t\t\twhile (true)\n\t\t\t\t{\n\t\t\t\t\tif (self.instanceid != instanceid)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tactortask actortask = await self.getasync();\n\t\t\t\t\t\n\t\t\t\t\tif (self.instanceid != instanceid)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif (actortask.actorrequest == null)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tawait self.runtask(actortask);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (exception e)\n\t\t\t{\n\t\t\t\tlog.error(e);\n\t\t\t}\n\t\t}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\nwhile (true)中是段异步方法，await self.getasync()之后很可能actorlocationsender对象已经被释放了，甚至有可能这个对象又被其它逻辑从对象池中再次利用了起来。我们这时候可以通过instanceid的变化来判断这个对象是否已经被释放掉。\n2. instanceid是全局唯一的，并且带有位置信息，可以通过instanceid来找到对象的位置，将消息发给对象。这个设计将会actor消息中利用到。这里暂时就不讲了。",charsets:{cjk:!0},lastUpdated:"2022/07/25, 23:10:19",lastUpdatedTimestamp:1658761819e3},{title:"3.3一切皆实体",frontmatter:{title:"3.3一切皆实体",date:"2022-05-31T19:10:27.000Z",permalink:"/pages/c77b6a/"},regularPath:"/01.%E6%8C%87%E5%8D%97/01.ETBbook_%E4%B8%AD%E6%96%87/34.3.3%E4%B8%80%E5%88%87%E7%9A%86%E5%AE%9E%E4%BD%93.html",relativePath:"01.指南/01.ETBbook_中文/34.3.3一切皆实体.md",key:"v-1dc56f77",path:"/pages/c77b6a/",headers:[{level:3,title:"1.组件的创建",slug:"_1-组件的创建",normalizedTitle:"1.组件的创建",charIndex:1677},{level:3,title:"2.组件的释放",slug:"_2-组件的释放",normalizedTitle:"2.组件的释放",charIndex:2062},{level:3,title:"3.InstanceId的作用",slug:"_3-instanceid的作用",normalizedTitle:"3.instanceid的作用",charIndex:2318}],headersStr:"1.组件的创建 2.组件的释放 3.InstanceId的作用",content:"# 一切皆实体\n\n目前十分流行ECS设计，主要是守望先锋的成功，引爆了这种技术。守望先锋采用了状态帧这种网络技术，客户端会进行预测，预测不准需要进行回滚，由于组件式的设计，回滚可以只回滚某些组件即可。ECS最重要的设计是逻辑跟数据的完全分离。即EC是纯数据，System实际上就是逻辑，由数据驱动逻辑。数据驱动逻辑是什么意思呢？很简单通过Update检测数据变化，通过事件机制来订阅数据变化，这就是所谓的数据驱动了。其它的特点例如缓存命中，在编写逻辑上来说并不太重要，现代游戏都用脚本，连脚本的性能都能容忍怎么会在乎缓存命中那点性能提升？ET在设计的时候吸收了这些想法，但是并不完全照搬，目前的设计是我经过长期的思考跟重构得来的，还是有些自己特色。\n\n传统的ECS写逻辑作者看来存在不少缺陷，比如为了复用，数据必然要拆成非常小的颗粒，会导致组件非常非常多。但是游戏是多人合作开发的，每个人基本上只熟悉自己的模块，最后可能造成组件大量冗余。还有个问题，常见的ECS是扁平式的，Entity跟Component只有一层。组件一多，开发功能可能不知道该使用哪些Component。好比一家公司，最大的是老板，老板手下带几百个人，老板不可能认识所有的人，完成一项任务，老板没法挑出自己需要的人。合理的做法是老板手下应该有几个经理，每个经理手下应该有几个主管，每个主管管理几个工人，这样形成树状的管理结构才会容易管理。这类似ET的做法，Entity可以管理Component，Component管理Entity，甚至Component还可以挂载Component。例如：人由头，身体，手，脚组成，而头又由眼睛，耳朵，鼻子，嘴巴组成。\n\n    Head head = human.AddComponent<Head>();\n    head.AddComponent<Eye>();\n    head.AddComponent<Mouse>();\n    head.AddComponent<Nose>();\n    head.AddComponent<Ear>();\n    human.AddComponent<Body>();\n    human.AddComponent<Hand>();\n    human.AddComponent<Leg>();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nET中，所有数据都是Entity，包括Entity，Entity既可以当成组件使用，也可以当做其它Entity的孩子。通用的数据放在Entity身上作为成员，不太通用的数据可以作为组件挂在Entity身上。比如物品的设计，所有物品都有配置id，数量，等级的字段，这些字段没有必要做成组件，放在Entity身上使用会更加方便。\n\n    class Item: Entity\n    {\n        // 道具的配置Id\n        public int ConfigId { get; set; }\n        // 道具的数量\n        public int Count { get; set; }\n        // 道具的等级\n        public int Level { get; set; }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nET的这种设计数据是一种树状的结构，非常有层次，能够非常轻松的理解整个游戏的架构。顶层Game.Scene，不同模块的数据都挂载在Game.Scene上面，每个模块自身下面又可以挂载很多数据。每开发一个新功能不用思考太多，类该怎么设计，数据放在什么地方，挂载这里会不会导致冗余等等。比如我玩家需要做一个道具系统，设计一个ItemsComponent挂在Player身上即可，需要技能开发一个SpellComponent挂在Player身上。全服需要做一个活动，搞个活动组件挂在Game.Scene上面。这种设计任务分派会很简单，十分的模块化。\n\n\n# 组件的一些细节\n\n\n# 1.组件的创建\n\n组件的创建不要自己去new，应该统一使用ComponentFactory创建。ComponentFactory提供了三组方法用来创建组件Create，CreateWithParent，CreateWithId。Create是最简单的创建方式，它做了几个处理\na. 根据组件类型构造一个组件\nb. 将组件加入事件系统，并且抛出一个AwakeSystem\nc. 是否启用对象池\nCreateWithParent在Create的基础上提供了一个Parent对象，设置到Component.Parent字段上。CreateWithId是用来创建ComponentWithId或者其子类的，在Create的基础上可以自己设置一个Id, Component在创建的时候可以选择是否使用对象池。三类工厂方法都带有一个fromPool的参数，默认是true。\n\n\n# 2.组件的释放\n\nComponent都继承了一个IDisposable接口，需要注意，Component有非托管资源，删除一个Component必须调用该接口。该接口做了如下的操作\na. 抛出Destroy System\nb. 如果组件是使用对象池创建的，那么在这里会放回对象池\nc. 从全局事件系统(EventSystem)中删除该组件，并且将InstanceId设为0\n如果组件挂载Entity身上，那么Entity调用Dispose的时候会自动调用身上所有Component的Dispose方法。\n\n\n# 3.InstanceId的作用\n\n任何Component都带有一个InstanceId字段，这个字段会在组件构造，或者组件从对象池取出的时候重新设置，这个InstanceId标识这个组件的身份。为什么需要这么一个字段呢？有以下几个原因\n\n 1. 对象池的存在，组件未必会释放，而是回到对象池中。在异步调用中，很可能这个组件已经被释放了，然后又被重新利用了起来，这样我们需要一种方式能区分之前的组件对象是否已经被释放，例如下面这段代码：\n\n\t\tpublic static async ETVoid UpdateAsync(this ActorLocationSender self)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tlong instanceId = self.InstanceId;\n\t\t\t\twhile (true)\n\t\t\t\t{\n\t\t\t\t\tif (self.InstanceId != instanceId)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tActorTask actorTask = await self.GetAsync();\n\t\t\t\t\t\n\t\t\t\t\tif (self.InstanceId != instanceId)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif (actorTask.ActorRequest == null)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tawait self.RunTask(actorTask);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e)\n\t\t\t{\n\t\t\t\tLog.Error(e);\n\t\t\t}\n\t\t}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\nwhile (true)中是段异步方法，await self.GetAsync()之后很可能ActorLocationSender对象已经被释放了，甚至有可能这个对象又被其它逻辑从对象池中再次利用了起来。我们这时候可以通过InstanceId的变化来判断这个对象是否已经被释放掉。\n2. InstanceId是全局唯一的，并且带有位置信息，可以通过InstanceId来找到对象的位置，将消息发给对象。这个设计将会Actor消息中利用到。这里暂时就不讲了。",normalizedContent:"# 一切皆实体\n\n目前十分流行ecs设计，主要是守望先锋的成功，引爆了这种技术。守望先锋采用了状态帧这种网络技术，客户端会进行预测，预测不准需要进行回滚，由于组件式的设计，回滚可以只回滚某些组件即可。ecs最重要的设计是逻辑跟数据的完全分离。即ec是纯数据，system实际上就是逻辑，由数据驱动逻辑。数据驱动逻辑是什么意思呢？很简单通过update检测数据变化，通过事件机制来订阅数据变化，这就是所谓的数据驱动了。其它的特点例如缓存命中，在编写逻辑上来说并不太重要，现代游戏都用脚本，连脚本的性能都能容忍怎么会在乎缓存命中那点性能提升？et在设计的时候吸收了这些想法，但是并不完全照搬，目前的设计是我经过长期的思考跟重构得来的，还是有些自己特色。\n\n传统的ecs写逻辑作者看来存在不少缺陷，比如为了复用，数据必然要拆成非常小的颗粒，会导致组件非常非常多。但是游戏是多人合作开发的，每个人基本上只熟悉自己的模块，最后可能造成组件大量冗余。还有个问题，常见的ecs是扁平式的，entity跟component只有一层。组件一多，开发功能可能不知道该使用哪些component。好比一家公司，最大的是老板，老板手下带几百个人，老板不可能认识所有的人，完成一项任务，老板没法挑出自己需要的人。合理的做法是老板手下应该有几个经理，每个经理手下应该有几个主管，每个主管管理几个工人，这样形成树状的管理结构才会容易管理。这类似et的做法，entity可以管理component，component管理entity，甚至component还可以挂载component。例如：人由头，身体，手，脚组成，而头又由眼睛，耳朵，鼻子，嘴巴组成。\n\n    head head = human.addcomponent<head>();\n    head.addcomponent<eye>();\n    head.addcomponent<mouse>();\n    head.addcomponent<nose>();\n    head.addcomponent<ear>();\n    human.addcomponent<body>();\n    human.addcomponent<hand>();\n    human.addcomponent<leg>();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\net中，所有数据都是entity，包括entity，entity既可以当成组件使用，也可以当做其它entity的孩子。通用的数据放在entity身上作为成员，不太通用的数据可以作为组件挂在entity身上。比如物品的设计，所有物品都有配置id，数量，等级的字段，这些字段没有必要做成组件，放在entity身上使用会更加方便。\n\n    class item: entity\n    {\n        // 道具的配置id\n        public int configid { get; set; }\n        // 道具的数量\n        public int count { get; set; }\n        // 道具的等级\n        public int level { get; set; }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\net的这种设计数据是一种树状的结构，非常有层次，能够非常轻松的理解整个游戏的架构。顶层game.scene，不同模块的数据都挂载在game.scene上面，每个模块自身下面又可以挂载很多数据。每开发一个新功能不用思考太多，类该怎么设计，数据放在什么地方，挂载这里会不会导致冗余等等。比如我玩家需要做一个道具系统，设计一个itemscomponent挂在player身上即可，需要技能开发一个spellcomponent挂在player身上。全服需要做一个活动，搞个活动组件挂在game.scene上面。这种设计任务分派会很简单，十分的模块化。\n\n\n# 组件的一些细节\n\n\n# 1.组件的创建\n\n组件的创建不要自己去new，应该统一使用componentfactory创建。componentfactory提供了三组方法用来创建组件create，createwithparent，createwithid。create是最简单的创建方式，它做了几个处理\na. 根据组件类型构造一个组件\nb. 将组件加入事件系统，并且抛出一个awakesystem\nc. 是否启用对象池\ncreatewithparent在create的基础上提供了一个parent对象，设置到component.parent字段上。createwithid是用来创建componentwithid或者其子类的，在create的基础上可以自己设置一个id, component在创建的时候可以选择是否使用对象池。三类工厂方法都带有一个frompool的参数，默认是true。\n\n\n# 2.组件的释放\n\ncomponent都继承了一个idisposable接口，需要注意，component有非托管资源，删除一个component必须调用该接口。该接口做了如下的操作\na. 抛出destroy system\nb. 如果组件是使用对象池创建的，那么在这里会放回对象池\nc. 从全局事件系统(eventsystem)中删除该组件，并且将instanceid设为0\n如果组件挂载entity身上，那么entity调用dispose的时候会自动调用身上所有component的dispose方法。\n\n\n# 3.instanceid的作用\n\n任何component都带有一个instanceid字段，这个字段会在组件构造，或者组件从对象池取出的时候重新设置，这个instanceid标识这个组件的身份。为什么需要这么一个字段呢？有以下几个原因\n\n 1. 对象池的存在，组件未必会释放，而是回到对象池中。在异步调用中，很可能这个组件已经被释放了，然后又被重新利用了起来，这样我们需要一种方式能区分之前的组件对象是否已经被释放，例如下面这段代码：\n\n\t\tpublic static async etvoid updateasync(this actorlocationsender self)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tlong instanceid = self.instanceid;\n\t\t\t\twhile (true)\n\t\t\t\t{\n\t\t\t\t\tif (self.instanceid != instanceid)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tactortask actortask = await self.getasync();\n\t\t\t\t\t\n\t\t\t\t\tif (self.instanceid != instanceid)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif (actortask.actorrequest == null)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tawait self.runtask(actortask);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (exception e)\n\t\t\t{\n\t\t\t\tlog.error(e);\n\t\t\t}\n\t\t}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\nwhile (true)中是段异步方法，await self.getasync()之后很可能actorlocationsender对象已经被释放了，甚至有可能这个对象又被其它逻辑从对象池中再次利用了起来。我们这时候可以通过instanceid的变化来判断这个对象是否已经被释放掉。\n2. instanceid是全局唯一的，并且带有位置信息，可以通过instanceid来找到对象的位置，将消息发给对象。这个设计将会actor消息中利用到。这里暂时就不讲了。",charsets:{cjk:!0},lastUpdated:"2022/07/25, 23:10:19",lastUpdatedTimestamp:1658761819e3},{title:"3.4事件机制EventSystem",frontmatter:{title:"3.4事件机制EventSystem",date:"2022-05-31T19:10:27.000Z",permalink:"/pages/e49330/"},regularPath:"/01.%E6%8C%87%E5%8D%97/01.ETBbook_%E4%B8%AD%E6%96%87/35.3.4%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6EventSystem.html",relativePath:"01.指南/01.ETBbook_中文/35.3.4事件机制EventSystem.md",key:"v-3ce102e1",path:"/pages/e49330/",headersStr:null,content:'# 事件机制EventSystem\n\nECS最重要的特性一是数据跟逻辑分离，二是数据驱动逻辑。什么是数据驱动逻辑呢？不太好理解，我们举个例子 一个moba游戏，英雄都有血条，血条会在人物头上显示，也会在左上方头像UI上显示。这时候服务端发来一个扣血消息。我们怎么处理这个消息？第一种方法，在消息处理函数中修改英雄的血数值，修改头像上血条显示，同时修改头像UI的血条。这种方式很明显造成了模块间的耦合。第二种方法，扣血消息处理函数中只是改变血值，血值的改变抛出一个hpchange的事件，人物头像模块跟UI模块都订阅血值改变事件，在订阅的方法中分别处理自己的逻辑，这样各个模块负责自己的逻辑，没有耦合。 ET提供了多种事件，事件都是可以多次订阅的:\n\n 1. AwakeSystem，组件工厂创建组件后抛出，只抛出一次，可以带参数\n\n    Player player = ComponentFactory.Create<Player>();\n\n    // 订阅Player的Awake事件\n    public class PlayerAwakeSystem: AwakeSystem<Player>\n    {\n        public override void Awake(Player self)\n        {\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n 2. StartSystem，组件UpdateSystem调用前抛出\n\n    // 订阅Player的Start事件\n    public class PlayerStartSystem: StartSystem<Player>\n    {\n        public override void Start(Player self)\n        {\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n\n 3. UpdateSystem，组件每帧抛出\n\n    // 订阅Player的Update事件\n    public class PlayerUpdateSystem: UpdateSystem<Player>\n    {\n        public override void Update(Player self)\n        {\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n\n 4. DestroySystem，组件删除时抛出\n\n    // 订阅Player的Destroy事件\n    public class PlayerDestroySystem: DestroySystem<Player>\n    {\n        public override void Destroy(Player self)\n        {\n        }\n    }\n\n    Player player = ComponentFactory.Create<Player>();\n    // 这里会触发Destroy事件\n    player.Dispose();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n 5. ChangeSystem，组件内容改变时抛出，需要开发者手动触发\n\n    // 订阅Player的Destroy事件\n    public class PlayerChangeSystem: ChangeSystem<Player>\n    {\n        public override void Change(Player self)\n        {\n        }\n    }\n\n    Player player = ComponentFactory.Create<Player>();\n    // 需要手动触发ChangeSystem\n    Game.EventSystem.Change(player);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n 6. DeserializeSystem，组件反序列化之后抛出\n\n    // 订阅Player的Deserialize事件\n    public class PlayerDeserializeSystem: DeserializeSystem<Player>\n    {\n        public override void Deserialize(Player self)\n        {\n        }\n    }\n\n    // 这里player2会触发Deserialize事件\n    Player player2 = MongoHelper.FromBson<Player>(player.ToBson());\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n 7. LoadSystem，EventSystem加载dll时抛出，用于服务端热更新，重新加载dll做一些处理，比如重新注册handler\n\n    // 订阅Player的Load事件\n    public class PlayerLoadSystem: LoadSystem<Player>\n    {\n        public override void Load(Player self)\n        {\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n\n 8. 普通的Event，由开发者自己抛出，可以最多带三个参数。另外客户端热更层也可以订阅mono层的Event事件\n\n    int oldhp = 10;\n    int newhp = 5;\n    // 抛出hp改变事件\n    Game.EventSystem.Run("HpChange", oldhp, newhp);\n\n    // UI订阅hp改变事件\n    [Event("HpChange")]\n    public class HpChange_ShowUI: AEvent<int, int>\n    {\n        public override void Run(int a, int b)\n        {\n            throw new NotImplementedException();\n        }\n    }\n\n    // 模型头顶血条模块也订阅hp改变事件\n    [Event("HpChange")]\n    public class HpChange_ModelHeadChange: AEvent<int, int>\n    {\n        public override void Run(int a, int b)\n        {\n            throw new NotImplementedException();\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n 9. 除此之外还有很多事件，例如消息事件。消息事件使用MessageHandler来声明，可以带参数指定哪种服务器需要订阅。\n\n\t[MessageHandler(AppType.Gate)]\n\tpublic class C2G_LoginGateHandler : AMRpcHandler<C2G_LoginGate, G2C_LoginGate>\n\t{\n\t\tprotected override void Run(Session session, C2G_LoginGate message, Action<G2C_LoginGate> reply)\n\t\t{\n\t\t\tG2C_LoginGate response = new G2C_LoginGate();\n\t\t\treply(response);\n\t\t}\n\t}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n更具体的消息事件等到讲消息的时候再细细讲解了\n10. 数值事件，数值模块再讲解\n......, 更多的事件由自己去开发。\n\nET框架的逻辑就是由以上各种事件来驱动的。',normalizedContent:'# 事件机制eventsystem\n\necs最重要的特性一是数据跟逻辑分离，二是数据驱动逻辑。什么是数据驱动逻辑呢？不太好理解，我们举个例子 一个moba游戏，英雄都有血条，血条会在人物头上显示，也会在左上方头像ui上显示。这时候服务端发来一个扣血消息。我们怎么处理这个消息？第一种方法，在消息处理函数中修改英雄的血数值，修改头像上血条显示，同时修改头像ui的血条。这种方式很明显造成了模块间的耦合。第二种方法，扣血消息处理函数中只是改变血值，血值的改变抛出一个hpchange的事件，人物头像模块跟ui模块都订阅血值改变事件，在订阅的方法中分别处理自己的逻辑，这样各个模块负责自己的逻辑，没有耦合。 et提供了多种事件，事件都是可以多次订阅的:\n\n 1. awakesystem，组件工厂创建组件后抛出，只抛出一次，可以带参数\n\n    player player = componentfactory.create<player>();\n\n    // 订阅player的awake事件\n    public class playerawakesystem: awakesystem<player>\n    {\n        public override void awake(player self)\n        {\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n 2. startsystem，组件updatesystem调用前抛出\n\n    // 订阅player的start事件\n    public class playerstartsystem: startsystem<player>\n    {\n        public override void start(player self)\n        {\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n\n 3. updatesystem，组件每帧抛出\n\n    // 订阅player的update事件\n    public class playerupdatesystem: updatesystem<player>\n    {\n        public override void update(player self)\n        {\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n\n 4. destroysystem，组件删除时抛出\n\n    // 订阅player的destroy事件\n    public class playerdestroysystem: destroysystem<player>\n    {\n        public override void destroy(player self)\n        {\n        }\n    }\n\n    player player = componentfactory.create<player>();\n    // 这里会触发destroy事件\n    player.dispose();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n 5. changesystem，组件内容改变时抛出，需要开发者手动触发\n\n    // 订阅player的destroy事件\n    public class playerchangesystem: changesystem<player>\n    {\n        public override void change(player self)\n        {\n        }\n    }\n\n    player player = componentfactory.create<player>();\n    // 需要手动触发changesystem\n    game.eventsystem.change(player);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n 6. deserializesystem，组件反序列化之后抛出\n\n    // 订阅player的deserialize事件\n    public class playerdeserializesystem: deserializesystem<player>\n    {\n        public override void deserialize(player self)\n        {\n        }\n    }\n\n    // 这里player2会触发deserialize事件\n    player player2 = mongohelper.frombson<player>(player.tobson());\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n 7. loadsystem，eventsystem加载dll时抛出，用于服务端热更新，重新加载dll做一些处理，比如重新注册handler\n\n    // 订阅player的load事件\n    public class playerloadsystem: loadsystem<player>\n    {\n        public override void load(player self)\n        {\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n\n 8. 普通的event，由开发者自己抛出，可以最多带三个参数。另外客户端热更层也可以订阅mono层的event事件\n\n    int oldhp = 10;\n    int newhp = 5;\n    // 抛出hp改变事件\n    game.eventsystem.run("hpchange", oldhp, newhp);\n\n    // ui订阅hp改变事件\n    [event("hpchange")]\n    public class hpchange_showui: aevent<int, int>\n    {\n        public override void run(int a, int b)\n        {\n            throw new notimplementedexception();\n        }\n    }\n\n    // 模型头顶血条模块也订阅hp改变事件\n    [event("hpchange")]\n    public class hpchange_modelheadchange: aevent<int, int>\n    {\n        public override void run(int a, int b)\n        {\n            throw new notimplementedexception();\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n 9. 除此之外还有很多事件，例如消息事件。消息事件使用messagehandler来声明，可以带参数指定哪种服务器需要订阅。\n\n\t[messagehandler(apptype.gate)]\n\tpublic class c2g_logingatehandler : amrpchandler<c2g_logingate, g2c_logingate>\n\t{\n\t\tprotected override void run(session session, c2g_logingate message, action<g2c_logingate> reply)\n\t\t{\n\t\t\tg2c_logingate response = new g2c_logingate();\n\t\t\treply(response);\n\t\t}\n\t}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n更具体的消息事件等到讲消息的时候再细细讲解了\n10. 数值事件，数值模块再讲解\n......, 更多的事件由自己去开发。\n\net框架的逻辑就是由以上各种事件来驱动的。',charsets:{cjk:!0},lastUpdated:"2022/07/25, 23:10:19",lastUpdatedTimestamp:1658761819e3},{title:"4.1组件式设计",frontmatter:{title:"4.1组件式设计",date:"2022-05-31T19:10:27.000Z",permalink:"/pages/002c9b/"},regularPath:"/01.%E6%8C%87%E5%8D%97/01.ETBbook_%E4%B8%AD%E6%96%87/41.4.1%E7%BB%84%E4%BB%B6%E5%BC%8F%E8%AE%BE%E8%AE%A1.html",relativePath:"01.指南/01.ETBbook_中文/41.4.1组件式设计.md",key:"v-3d087b67",path:"/pages/002c9b/",headers:[{level:2,title:"1. 数据结构耦合性极强",slug:"_1-数据结构耦合性极强",normalizedTitle:"1. 数据结构耦合性极强",charIndex:103},{level:2,title:"2. 难以热插拔",slug:"_2-难以热插拔",normalizedTitle:"2. 难以热插拔",charIndex:475},{level:2,title:"3. 方法与数据耦合",slug:"_3-方法与数据耦合",normalizedTitle:"3. 方法与数据耦合",charIndex:956}],headersStr:"1. 数据结构耦合性极强 2. 难以热插拔 3. 方法与数据耦合",content:"# 组件式设计\n\n在代码复用和组织数据方面，面向对象可能是大家第一反应。面向对象三大特性继承，封装，多态，在一定程度上能解决不少代码复用，数据复用的问题。不过面向对象不是万能的，它也有极大的缺陷：\n\n\n# 1. 数据结构耦合性极强\n\n一旦父类中增加或删除某个字段，可能要影响到所有子类，影响到所有子类相关的逻辑。这显得非常不灵活，在一套复杂的继承体系中，往父类中改变字段会变得越来越麻烦，比方说ABC是D的子类，某天发现需要增加一个AB都有的数据，但是C没有，那么这个数据肯定不好放到父类中，只能将AB抽象出来一个父类E，E继承于D，AB共有的字段加到E中，一旦继承结构发生了变化，可能接口也要改变，比方说之前有个接口传入参数类型是E，当AB不再需要共用的那个字段，那么需要调整继承关系，让AB重新继承D，那么这个接口的传入参数类型需要改成D，其中的逻辑代码很可能也要发生调整。更可怕的是游戏逻辑变化非常复杂，非常频繁，可能今天加了个字段，明天又删掉了，假如每次都要去调整继承结构，这简直就是噩梦。继承结构面对频繁的数据结构调整感觉很无力。\n\n\n# 2. 难以热插拔\n\n继承结构无法运行时增加删除字段，比如玩家Player平常是走路，使用坐骑后就骑马。问题是坐骑的相关信息就需要一直挂在Player对象上面。这就显得很不灵活，我不骑马的时候内存中为啥要有马的数据？接口也有同样的问题，一个类实现了一个接口，那么这个接口就永远粘在了这个类身上，你想甩掉她都不行，还是以骑马为例，玩家Player可以进行骑行，那么可能继承一个骑行的接口，问题是，当我这个Player从坐骑上下来时，玩家Player身上还是有骑行的接口，根本没法动态删掉这个接口！可能例子举得不是很对，但是道理表述的应该很清楚了。\n\n使用面向对象可能导致灾难性后果，游戏开发中有新人有老人，有技术好的，有技术差的。人都是喜欢偷懒的，当你发现调整继承关系麻烦的时候，有可能AB中增加一个字段为了省事直接就放到父类D中去了。导致C莫名奇妙的多了一个无用的字段。关键还没法发现，最后导致父类D越来越大，到最后有可能干脆就不用ABC了，直接让所有对象都变成D，方便嘛！是的，很多游戏就是这么干的，开发到最后根本就不管继承关系了，因为想管也管不了了。\n\n\n# 3. 方法与数据耦合\n\n传统面向对象都是class中带有方法，并且特别提倡虚函数多态。方法跟数据放在一起带来了特别多耦合的问题。为了解决这些耦合，大家想出了大量的设计模式，比如依赖接口，依赖转置。说实话，这就是脱裤子放屁，为了解耦合，把类做成接口，然后继承接口，难道这就不叫依赖了？这些做法导致，代码中到处是接口，代码阅读极其困难。写起代码来也没有个标准，高手跟菜鸡写出来的代码完全是两回事。大部分码农都是逻辑仔，谁有时间天天想这个类要怎么设计啊？随着逻辑越来越复杂类里面的方法将越来越庞大，可怕的是，这是这个类的方法，极其难以重构，很多项目中能看到类里面存在上万行代码的虚函数。天哪！\n\n面向对象在面对复杂的游戏逻辑时很无力，所以很多游戏开发者又倒退了回去，使用面向过程进行开发游戏，面向过程，简单粗暴，不考虑复杂的继承，不考虑抽象，不考虑多态，是开发届的freestyle，挽起袖子就开撸，但同时，代码逻辑的复用性，数据的复用性也大大降低。面向过程也不是一种好的游戏开发模式。\n\n组件模式很好的解决了面向对象以及面向过程的种种缺陷，在游戏客户端中使用非常广泛，Unity3d，虚幻4，等等都使用了组件模式。组件模式的特点： 1.高度模块化，一个组件就是一份数据加一段逻辑\n2.组件可热插拔，需要就加上，不需要就删除\n3.类型之间依赖极少，任何类型增加或删除组件不会影响到其它类型。\n\n但是目前只有极少有服务端使用了组件的设计，守望先锋服务端应该是使用了组件的设计，守望先锋的开发人员称之为ECS架构，其实就是组件模式的一个变种，E就是Entity，C就是Component，S是System，其实就是将组件Component的逻辑与数据剥离，逻辑部分叫System，话题扯远了，还是回到ET框架来把。\n\nET框架使用了组件的设计。一切都是Entity和Component，任何类继承于Entity都可以挂载组件，例如玩家类：\n\npublic sealed class Player : Entity\n{\n    public string Account { get; private set; }\n    public long UnitId { get; set; }\n\t\n    public void Awake(string account)\n    {\n        this.Account = account;\n    }\n\t\n    public override void Dispose()\n    {\n        if (this.Id == 0)\n        {\n            return;\n        }\n        base.Dispose();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n给玩家对象挂载个移动组件MoveComponent，这样玩家就可以移动了，给玩家挂上一个背包组件，玩家就可以管理物品了，给玩家挂上技能组件，那么玩家就可以施放技能了，加上Buff组件就可以管理buff了。\n\nplayer.AddComponent<MoveComponent>();\nplayer.AddComponent<ItemsComponent>();\nplayer.AddComponent<SpellComponent>();\nplayer.AddComponent<BuffComponent>();\n\n\n1\n2\n3\n4\n\n\n组件是高度可以复用的，比如一个NPC，他也可以移动，给NPC也挂上MoveComponent就行了，有的NPC也可以施放技能，那么给它挂上SpellComponent，NPC不需要背包，那么就不用挂ItemsComponent了\n\nET框架模块全部做成了组件的形式，一个进程也是由不同的组件拼接而成。比方说Loginserver需要对外连接也需要与服务器内部进行连接，那么login server挂上\n\n// 内网网络组件NetInnerComponent，处理对内网连接  \nGame.Scene.AddComponent<NetInnerComponent, string, int>(innerConfig.Host, innerConfig.Port);\n// 外网网络组件NetOuterComponent，处理与客户端连接\nGame.Scene.AddComponent<NetOuterComponent, string, int>(outerConfig.Host, outerConfig.Port);\n\n\n1\n2\n3\n4\n\n\n比如battle server就不需要对外网连接（外网消息由gateserver转发），那么很自然的只需要挂载一个内网组件即可。 类似Unity3d的组件，ET框架也提供了组件事件，例如Awake，Start，Update等。要给一个Component或者Entity加上这些事件，必须写一个辅助类。比如NetInnerComponent组件需要Awake跟Update方法，那么添加一个这样的类即可：\n\n[ObjectEvent]\npublic class NetInnerComponentEvent : ObjectEvent<NetInnerComponent>, IAwake, IUpdate\n{\n    public void Awake()\n    {\n        this.Get().Awake();\n    }\n\n    public void Update()\n    {\n        this.Get().Update();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n这样，NetInnerComponent在AddComponent之后会调用其Awake方法，并且每帧调用Update方法。 ET没有像Unity使用反射去实现这种功能，因为反射性能比较差，而且这样实现的好处是这个类可以放到热更dll中，这样组件的Awake Start，Update方法以及其它方法都可以放到热更层中。将Entity和Component做成没有方法的类，方法都放到热更层，方便热更修复逻辑bug。\n\n组件式开发最大的好处就是不管菜鸟还是高手，开发一个功能都能很快的知道怎么组织数据怎么组织逻辑。可以完全放弃面向对象。使用面向对象开发最头疼的就是我该继承哪个类呢？之前做过最恐怖的就是虚幻三，虚幻三的继承结构非常多层，完全不知道自己需要从哪里开始继承。最后可能导致一个非常小的功能，继承了一个及其巨大的类，这在虚幻三开发中屡见不鲜。所以虚幻4改用了组件模式。组件模式的模块隔离性非常好，技术菜鸟某个组件写得非常差，也不会影响到其它模块，大不了重写这个组件就好了。\n\nET的组件设计有所创新，方法跟数据分离，完全解除耦合，不用绞尽脑汁去想怎么解除耦合，随意写静态方法即可，根本不存在耦合，即使是菜鸟写的代码也很容易重构。\n\n正是因为ET使用了可拆卸的组件模式，ET可以将所有服务器组件都装到同一个进程上，那么这一个进程就可以当作一组分布式服务器使用。从此用vs调试分布式服务器成为了可能。正因为这样，平常开发只使用一个进程，发布的时候发布成多个进程就行了。说实在的，不是吹牛，这是一个伟大的发明，这一发明解决了分布式游戏服务器开发中的大大大难题，极大的提高了开发效率。",normalizedContent:"# 组件式设计\n\n在代码复用和组织数据方面，面向对象可能是大家第一反应。面向对象三大特性继承，封装，多态，在一定程度上能解决不少代码复用，数据复用的问题。不过面向对象不是万能的，它也有极大的缺陷：\n\n\n# 1. 数据结构耦合性极强\n\n一旦父类中增加或删除某个字段，可能要影响到所有子类，影响到所有子类相关的逻辑。这显得非常不灵活，在一套复杂的继承体系中，往父类中改变字段会变得越来越麻烦，比方说abc是d的子类，某天发现需要增加一个ab都有的数据，但是c没有，那么这个数据肯定不好放到父类中，只能将ab抽象出来一个父类e，e继承于d，ab共有的字段加到e中，一旦继承结构发生了变化，可能接口也要改变，比方说之前有个接口传入参数类型是e，当ab不再需要共用的那个字段，那么需要调整继承关系，让ab重新继承d，那么这个接口的传入参数类型需要改成d，其中的逻辑代码很可能也要发生调整。更可怕的是游戏逻辑变化非常复杂，非常频繁，可能今天加了个字段，明天又删掉了，假如每次都要去调整继承结构，这简直就是噩梦。继承结构面对频繁的数据结构调整感觉很无力。\n\n\n# 2. 难以热插拔\n\n继承结构无法运行时增加删除字段，比如玩家player平常是走路，使用坐骑后就骑马。问题是坐骑的相关信息就需要一直挂在player对象上面。这就显得很不灵活，我不骑马的时候内存中为啥要有马的数据？接口也有同样的问题，一个类实现了一个接口，那么这个接口就永远粘在了这个类身上，你想甩掉她都不行，还是以骑马为例，玩家player可以进行骑行，那么可能继承一个骑行的接口，问题是，当我这个player从坐骑上下来时，玩家player身上还是有骑行的接口，根本没法动态删掉这个接口！可能例子举得不是很对，但是道理表述的应该很清楚了。\n\n使用面向对象可能导致灾难性后果，游戏开发中有新人有老人，有技术好的，有技术差的。人都是喜欢偷懒的，当你发现调整继承关系麻烦的时候，有可能ab中增加一个字段为了省事直接就放到父类d中去了。导致c莫名奇妙的多了一个无用的字段。关键还没法发现，最后导致父类d越来越大，到最后有可能干脆就不用abc了，直接让所有对象都变成d，方便嘛！是的，很多游戏就是这么干的，开发到最后根本就不管继承关系了，因为想管也管不了了。\n\n\n# 3. 方法与数据耦合\n\n传统面向对象都是class中带有方法，并且特别提倡虚函数多态。方法跟数据放在一起带来了特别多耦合的问题。为了解决这些耦合，大家想出了大量的设计模式，比如依赖接口，依赖转置。说实话，这就是脱裤子放屁，为了解耦合，把类做成接口，然后继承接口，难道这就不叫依赖了？这些做法导致，代码中到处是接口，代码阅读极其困难。写起代码来也没有个标准，高手跟菜鸡写出来的代码完全是两回事。大部分码农都是逻辑仔，谁有时间天天想这个类要怎么设计啊？随着逻辑越来越复杂类里面的方法将越来越庞大，可怕的是，这是这个类的方法，极其难以重构，很多项目中能看到类里面存在上万行代码的虚函数。天哪！\n\n面向对象在面对复杂的游戏逻辑时很无力，所以很多游戏开发者又倒退了回去，使用面向过程进行开发游戏，面向过程，简单粗暴，不考虑复杂的继承，不考虑抽象，不考虑多态，是开发届的freestyle，挽起袖子就开撸，但同时，代码逻辑的复用性，数据的复用性也大大降低。面向过程也不是一种好的游戏开发模式。\n\n组件模式很好的解决了面向对象以及面向过程的种种缺陷，在游戏客户端中使用非常广泛，unity3d，虚幻4，等等都使用了组件模式。组件模式的特点： 1.高度模块化，一个组件就是一份数据加一段逻辑\n2.组件可热插拔，需要就加上，不需要就删除\n3.类型之间依赖极少，任何类型增加或删除组件不会影响到其它类型。\n\n但是目前只有极少有服务端使用了组件的设计，守望先锋服务端应该是使用了组件的设计，守望先锋的开发人员称之为ecs架构，其实就是组件模式的一个变种，e就是entity，c就是component，s是system，其实就是将组件component的逻辑与数据剥离，逻辑部分叫system，话题扯远了，还是回到et框架来把。\n\net框架使用了组件的设计。一切都是entity和component，任何类继承于entity都可以挂载组件，例如玩家类：\n\npublic sealed class player : entity\n{\n    public string account { get; private set; }\n    public long unitid { get; set; }\n\t\n    public void awake(string account)\n    {\n        this.account = account;\n    }\n\t\n    public override void dispose()\n    {\n        if (this.id == 0)\n        {\n            return;\n        }\n        base.dispose();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n给玩家对象挂载个移动组件movecomponent，这样玩家就可以移动了，给玩家挂上一个背包组件，玩家就可以管理物品了，给玩家挂上技能组件，那么玩家就可以施放技能了，加上buff组件就可以管理buff了。\n\nplayer.addcomponent<movecomponent>();\nplayer.addcomponent<itemscomponent>();\nplayer.addcomponent<spellcomponent>();\nplayer.addcomponent<buffcomponent>();\n\n\n1\n2\n3\n4\n\n\n组件是高度可以复用的，比如一个npc，他也可以移动，给npc也挂上movecomponent就行了，有的npc也可以施放技能，那么给它挂上spellcomponent，npc不需要背包，那么就不用挂itemscomponent了\n\net框架模块全部做成了组件的形式，一个进程也是由不同的组件拼接而成。比方说loginserver需要对外连接也需要与服务器内部进行连接，那么login server挂上\n\n// 内网网络组件netinnercomponent，处理对内网连接  \ngame.scene.addcomponent<netinnercomponent, string, int>(innerconfig.host, innerconfig.port);\n// 外网网络组件netoutercomponent，处理与客户端连接\ngame.scene.addcomponent<netoutercomponent, string, int>(outerconfig.host, outerconfig.port);\n\n\n1\n2\n3\n4\n\n\n比如battle server就不需要对外网连接（外网消息由gateserver转发），那么很自然的只需要挂载一个内网组件即可。 类似unity3d的组件，et框架也提供了组件事件，例如awake，start，update等。要给一个component或者entity加上这些事件，必须写一个辅助类。比如netinnercomponent组件需要awake跟update方法，那么添加一个这样的类即可：\n\n[objectevent]\npublic class netinnercomponentevent : objectevent<netinnercomponent>, iawake, iupdate\n{\n    public void awake()\n    {\n        this.get().awake();\n    }\n\n    public void update()\n    {\n        this.get().update();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n这样，netinnercomponent在addcomponent之后会调用其awake方法，并且每帧调用update方法。 et没有像unity使用反射去实现这种功能，因为反射性能比较差，而且这样实现的好处是这个类可以放到热更dll中，这样组件的awake start，update方法以及其它方法都可以放到热更层中。将entity和component做成没有方法的类，方法都放到热更层，方便热更修复逻辑bug。\n\n组件式开发最大的好处就是不管菜鸟还是高手，开发一个功能都能很快的知道怎么组织数据怎么组织逻辑。可以完全放弃面向对象。使用面向对象开发最头疼的就是我该继承哪个类呢？之前做过最恐怖的就是虚幻三，虚幻三的继承结构非常多层，完全不知道自己需要从哪里开始继承。最后可能导致一个非常小的功能，继承了一个及其巨大的类，这在虚幻三开发中屡见不鲜。所以虚幻4改用了组件模式。组件模式的模块隔离性非常好，技术菜鸟某个组件写得非常差，也不会影响到其它模块，大不了重写这个组件就好了。\n\net的组件设计有所创新，方法跟数据分离，完全解除耦合，不用绞尽脑汁去想怎么解除耦合，随意写静态方法即可，根本不存在耦合，即使是菜鸟写的代码也很容易重构。\n\n正是因为et使用了可拆卸的组件模式，et可以将所有服务器组件都装到同一个进程上，那么这一个进程就可以当作一组分布式服务器使用。从此用vs调试分布式服务器成为了可能。正因为这样，平常开发只使用一个进程，发布的时候发布成多个进程就行了。说实在的，不是吹牛，这是一个伟大的发明，这一发明解决了分布式游戏服务器开发中的大大大难题，极大的提高了开发效率。",charsets:{cjk:!0},lastUpdated:"2022/07/25, 23:10:19",lastUpdatedTimestamp:1658761819e3},{title:"5.4Actor模型",frontmatter:{title:"5.4Actor模型",date:"2022-05-31T19:10:27.000Z",permalink:"/pages/96869e/"},regularPath:"/01.%E6%8C%87%E5%8D%97/01.ETBbook_%E4%B8%AD%E6%96%87/54.5.4Actor%E6%A8%A1%E5%9E%8B.html",relativePath:"01.指南/01.ETBbook_中文/54.5.4Actor模型.md",key:"v-e0ad2bb2",path:"/pages/96869e/",headers:[{level:3,title:"Actor介绍",slug:"actor介绍",normalizedTitle:"actor介绍",charIndex:14},{level:3,title:"ET的Actor",slug:"et的actor",normalizedTitle:"et的actor",charIndex:1243},{level:3,title:"ET的Actor的使用",slug:"et的actor的使用",normalizedTitle:"et的actor的使用",charIndex:1784},{level:3,title:"Actor消息的处理",slug:"actor消息的处理",normalizedTitle:"actor消息的处理",charIndex:2913}],headersStr:"Actor介绍 ET的Actor ET的Actor的使用 Actor消息的处理",content:"# Actor模型\n\n\n# Actor介绍\n\n在讨论Actor模型之前先要讨论下ET的架构，游戏服务器为了利用多核一般有两种架构，单线程多进程跟单进程多线程架构。两种架构本质上其实区别不大，因为游戏逻辑开发都需要用单线程，即使是单进程多线程架构，也要用一定的方法保证单线程开发逻辑。ET采用的是单线程多进程的架构，而传统Actor模型一般是单进程多线程的架构，这点是比较大的区别，不能说谁更好，只能说各有优势。优劣如下：\n\n 1. 逻辑需要单线程这点都是一样的，erlang进程逻辑是单线程的，skynet lua虚拟机也是单线程的。ET中一个进程其实相当于一个erlang进程，一个skynet lua虚拟机。\n 2. 采用单线程多进程不需要自己再写一套profiler工具，可以利用很多现成的profiler工具，例如查看内存，cpu占用直接用top命令，这点erlang跟skynet都需要自己另外搞一套工具。\n 3. 多进程单线程架构还有个好处，单台物理机跟多台物理机是没有区别的，单进程多线程还需要考虑多台物理机的处理。\n 4. 多进程单线程架构一点缺陷是消息跨进程需要进行序列化反序列化，占用一点资源。另外发送网络消息会有几毫秒延时。一般这些影响可以忽略。\n\n最开始Actor模型是给单进程多线程架构使用的，这是有原因的，因为多线程架构开发者很容易随意的访问共享变量，比方说一个变量a, 线程1能访问，线程2也能访问，这样两个线程在访问变量a的时候都需要加锁，共享变量多了之后锁到处都是，会变得无法维护，框架肯定不能出现到处是线程共享变量的情况。为了保证多线程架构不出问题，必须提供一种开发模型保证多线程开发简单又安全。erlang语言的并发机制就是actor模型。erlang虚拟机使用多线程来利用多核。erlang设计了一种机制，它在虚拟机之上设计了自己的进程。最简单的，每个erlang进程都管理自己的变量，每个erlang进程的逻辑都跑在一个线程上，erlang进程跟进程之间逻辑完全隔离，这样就不存在两个线程访问同一变量的情况了也就不存在多线程竞争的问题。接下来问题又出现了，既然每个erlang进程都有自己的数据，逻辑完全是隔离的，两个erlang进程之间应该怎么进行通信呢？这时Actor模型就登场了。erlang设计了一种消息机制：一个进程可以向其它进程发送消息，erlang进程之间通过消息来进行通信，看到这会不会感觉很熟悉？这不就是操作系统进程间通信用的消息队列吗？没错，其实是类似的。erlang里面拿到进程的id就能给这个进程发送消息。\n\n如果消息只发给进程其实还是有点不方便。比如拿一个erlang进程做moba战队进程，战斗进程中有10个玩家，如果使用erlang的actor消息，消息只能发送给战斗进程，但是很多时候消息是需要发送给一个玩家的，这时erlang需要根据消息中的玩家Id，把消息再次分发给具体的玩家，这样其实多绕了一圈。\n\n\n# ET的Actor\n\nET根据自己架构得特点，没有完全照搬erlang的Actor模型，而是提供了Entity对象级别的Actor模型。这点跟erlang甚至传统的Actor机制不一样。ET中，Actor是Entity对象，Entity挂上一个MailboxComponent组件就是一个Actor了。只需要知道Entity的InstanceId就可以发消息给这个Entity了。其实erlang的Actor模型不过是ET中的一种特例，比如给ET服务端Game.Scene当做一个Actor，这样就可以变成进程级别的Actor。Actor本质就是一种消息机制，这种消息机制不用关心位置，只需要知道对方的InstanceId（ET）或者进程的Pid（erlang）就能发给对方。\n\n语言        ET                  ERLANG       SKYNET\n架构        单线程多进程              单进程多线程       单进程多线程\nActor     Entity              erlang进程     lua虚拟机\nActorId   Entity.InstanceId   erlang进程Id   服务地址\n\n\n# ET的Actor的使用\n\n普通的Actor，我们可以参照Gate Session。map中一个Unit，Unit身上保存了这个玩家对应的gate session。这样，map中的消息如果需要发给客户端，只需要把消息发送给gate session，gate session在收到消息的时候转发给客户端即可。map进程发送消息给gate session就是典型的actor模型。它不需要知道gate session的位置，只需要知道它的InstanceId即可。MessageHelper.cs中，通过GateSessionActorId获取一个ActorMessageSender，然后发送。\n\n// 从Game.Scene上获取ActorSenderComponent，然后通过InstanceId获取ActorMessageSender\nActorSenderComponent actorSenderComponent = Game.Scene.GetComponent<ActorSenderComponent>();\nActorMessageSender actorMessageSender = actorSenderComponent.Get(unitGateComponent.GateSessionActorId);\n// send\nactorMessageSender.Send(message);\n\n// rpc\nvar response = actorMessageSender.Call(message);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n问题是map中怎么才能知道gate session的InstanceId呢？这就是你需要想方设法传过去了，比如ET中，玩家在登录gate的时候，gate session挂上一个信箱MailBoxComponent，C2G_LoginGateHandler.cs中\n\nsession.AddComponent<MailBoxComponent, string>(MailboxType.GateSession);\n\n\n1\n\n\n玩家登录map进程的时候会把这个gate session的InstanceId带进map中去，C2G_EnterMapHandler.cs中\n\nM2G_CreateUnit createUnit = (M2G_CreateUnit)await mapSession.Call(new G2M_CreateUnit() { PlayerId = player.Id, GateSessionId = session.InstanceId });\n\n\n1\n\n\n\n# Actor消息的处理\n\n首先，消息到达MailboxComponent，MailboxComponent是有类型的，不同的类型邮箱可以做不同的处理。目前有两种邮箱类型GateSession跟MessageDispatcher。GateSession邮箱在收到消息的时候会立即转发给客户端，MessageDispatcher类型会再次对Actor消息进行分发到具体的Handler处理，默认的MailboxComponent类型是MessageDispatcher。自定义一个邮箱类型也很简单，继承IMailboxHandler接口，加上MailboxHandler标签即可。那么为什么需要加这么个功能呢，在其它的actor模型中是不存在这个特点的，一般是收到消息就进行分发处理了。原因是GateSession的设计，并不需要进行分发处理，因此我在这里加上了邮箱类型这种设计。MessageDispatcher的处理方式有两种一种是处理对方Send过来的消息，一种是rpc消息\n\n    // 处理Send的消息, 需要继承AMActorHandler抽象类，抽象类第一个泛型参数是Actor的类型，第二个参数是消息的类型\n\t[ActorMessageHandler(AppType.Map)]\n\tpublic class Actor_TestHandler : AMActorHandler<Unit, Actor_Test>\n\t{\n\t\tprotected override ETTask Run(Unit unit, Actor_Test message)\n\t\t{\n\t\t\tLog.Debug(message.Info);\n\t\t}\n\t}\n\n    // 处理Rpc消息, 需要继承AMActorRpcHandler抽象类，抽象类第一个泛型参数是Actor的类型，第二个参数是消息的类型，第三个参数是返回消息的类型\n    [ActorMessageHandler(AppType.Map)]\n\tpublic class Actor_TransferHandler : AMActorRpcHandler<Unit, Actor_TransferRequest, Actor_TransferResponse>\n\t{\n\t\tprotected override async ETTask Run(Unit unit, Actor_TransferRequest message, Action<Actor_TransferResponse> reply)\n\t\t{\n\t\t\tActor_TransferResponse response = new Actor_TransferResponse();\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\treply(response);\n\t\t\t}\n\t\t\tcatch (Exception e)\n\t\t\t{\n\t\t\t\tReplyError(response, e, reply);\n\t\t\t}\n\t\t}\n\t}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n我们需要注意一下，Actor消息有死锁的可能，比如A call消息给B，B call给C，C call给A。因为MailboxComponent本质上是一个消息队列，它开启了一个协程会一个一个消息处理，返回ETTask表示这个消息处理类会阻塞MailboxComponent队列的其它消息。所以如果出现死锁，我们就不希望某个消息处理阻塞掉MailboxComponent其它消息的处理，我们可以在消息处理类里面新开一个协程来处理就行了。例如:\n\n\t[ActorMessageHandler(AppType.Map)]\n\tpublic class Actor_TestHandler : AMActorHandler<Unit, Actor_Test>\n\t{\n\t\tprotected override ETTask Run(Unit unit, Actor_Test message)\n\t\t{\n\t\t\tRunAsync(unit, message).Coroutine();\n\t\t}\n\n        public ETVoid RunAsync(Unit unit, Actor_Test message)\n        {\n            Log.Debug(message.Info);\n        }\n\t}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n相关资料可以谷歌一下Actor死锁的问题。",normalizedContent:"# actor模型\n\n\n# actor介绍\n\n在讨论actor模型之前先要讨论下et的架构，游戏服务器为了利用多核一般有两种架构，单线程多进程跟单进程多线程架构。两种架构本质上其实区别不大，因为游戏逻辑开发都需要用单线程，即使是单进程多线程架构，也要用一定的方法保证单线程开发逻辑。et采用的是单线程多进程的架构，而传统actor模型一般是单进程多线程的架构，这点是比较大的区别，不能说谁更好，只能说各有优势。优劣如下：\n\n 1. 逻辑需要单线程这点都是一样的，erlang进程逻辑是单线程的，skynet lua虚拟机也是单线程的。et中一个进程其实相当于一个erlang进程，一个skynet lua虚拟机。\n 2. 采用单线程多进程不需要自己再写一套profiler工具，可以利用很多现成的profiler工具，例如查看内存，cpu占用直接用top命令，这点erlang跟skynet都需要自己另外搞一套工具。\n 3. 多进程单线程架构还有个好处，单台物理机跟多台物理机是没有区别的，单进程多线程还需要考虑多台物理机的处理。\n 4. 多进程单线程架构一点缺陷是消息跨进程需要进行序列化反序列化，占用一点资源。另外发送网络消息会有几毫秒延时。一般这些影响可以忽略。\n\n最开始actor模型是给单进程多线程架构使用的，这是有原因的，因为多线程架构开发者很容易随意的访问共享变量，比方说一个变量a, 线程1能访问，线程2也能访问，这样两个线程在访问变量a的时候都需要加锁，共享变量多了之后锁到处都是，会变得无法维护，框架肯定不能出现到处是线程共享变量的情况。为了保证多线程架构不出问题，必须提供一种开发模型保证多线程开发简单又安全。erlang语言的并发机制就是actor模型。erlang虚拟机使用多线程来利用多核。erlang设计了一种机制，它在虚拟机之上设计了自己的进程。最简单的，每个erlang进程都管理自己的变量，每个erlang进程的逻辑都跑在一个线程上，erlang进程跟进程之间逻辑完全隔离，这样就不存在两个线程访问同一变量的情况了也就不存在多线程竞争的问题。接下来问题又出现了，既然每个erlang进程都有自己的数据，逻辑完全是隔离的，两个erlang进程之间应该怎么进行通信呢？这时actor模型就登场了。erlang设计了一种消息机制：一个进程可以向其它进程发送消息，erlang进程之间通过消息来进行通信，看到这会不会感觉很熟悉？这不就是操作系统进程间通信用的消息队列吗？没错，其实是类似的。erlang里面拿到进程的id就能给这个进程发送消息。\n\n如果消息只发给进程其实还是有点不方便。比如拿一个erlang进程做moba战队进程，战斗进程中有10个玩家，如果使用erlang的actor消息，消息只能发送给战斗进程，但是很多时候消息是需要发送给一个玩家的，这时erlang需要根据消息中的玩家id，把消息再次分发给具体的玩家，这样其实多绕了一圈。\n\n\n# et的actor\n\net根据自己架构得特点，没有完全照搬erlang的actor模型，而是提供了entity对象级别的actor模型。这点跟erlang甚至传统的actor机制不一样。et中，actor是entity对象，entity挂上一个mailboxcomponent组件就是一个actor了。只需要知道entity的instanceid就可以发消息给这个entity了。其实erlang的actor模型不过是et中的一种特例，比如给et服务端game.scene当做一个actor，这样就可以变成进程级别的actor。actor本质就是一种消息机制，这种消息机制不用关心位置，只需要知道对方的instanceid（et）或者进程的pid（erlang）就能发给对方。\n\n语言        et                  erlang       skynet\n架构        单线程多进程              单进程多线程       单进程多线程\nactor     entity              erlang进程     lua虚拟机\nactorid   entity.instanceid   erlang进程id   服务地址\n\n\n# et的actor的使用\n\n普通的actor，我们可以参照gate session。map中一个unit，unit身上保存了这个玩家对应的gate session。这样，map中的消息如果需要发给客户端，只需要把消息发送给gate session，gate session在收到消息的时候转发给客户端即可。map进程发送消息给gate session就是典型的actor模型。它不需要知道gate session的位置，只需要知道它的instanceid即可。messagehelper.cs中，通过gatesessionactorid获取一个actormessagesender，然后发送。\n\n// 从game.scene上获取actorsendercomponent，然后通过instanceid获取actormessagesender\nactorsendercomponent actorsendercomponent = game.scene.getcomponent<actorsendercomponent>();\nactormessagesender actormessagesender = actorsendercomponent.get(unitgatecomponent.gatesessionactorid);\n// send\nactormessagesender.send(message);\n\n// rpc\nvar response = actormessagesender.call(message);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n问题是map中怎么才能知道gate session的instanceid呢？这就是你需要想方设法传过去了，比如et中，玩家在登录gate的时候，gate session挂上一个信箱mailboxcomponent，c2g_logingatehandler.cs中\n\nsession.addcomponent<mailboxcomponent, string>(mailboxtype.gatesession);\n\n\n1\n\n\n玩家登录map进程的时候会把这个gate session的instanceid带进map中去，c2g_entermaphandler.cs中\n\nm2g_createunit createunit = (m2g_createunit)await mapsession.call(new g2m_createunit() { playerid = player.id, gatesessionid = session.instanceid });\n\n\n1\n\n\n\n# actor消息的处理\n\n首先，消息到达mailboxcomponent，mailboxcomponent是有类型的，不同的类型邮箱可以做不同的处理。目前有两种邮箱类型gatesession跟messagedispatcher。gatesession邮箱在收到消息的时候会立即转发给客户端，messagedispatcher类型会再次对actor消息进行分发到具体的handler处理，默认的mailboxcomponent类型是messagedispatcher。自定义一个邮箱类型也很简单，继承imailboxhandler接口，加上mailboxhandler标签即可。那么为什么需要加这么个功能呢，在其它的actor模型中是不存在这个特点的，一般是收到消息就进行分发处理了。原因是gatesession的设计，并不需要进行分发处理，因此我在这里加上了邮箱类型这种设计。messagedispatcher的处理方式有两种一种是处理对方send过来的消息，一种是rpc消息\n\n    // 处理send的消息, 需要继承amactorhandler抽象类，抽象类第一个泛型参数是actor的类型，第二个参数是消息的类型\n\t[actormessagehandler(apptype.map)]\n\tpublic class actor_testhandler : amactorhandler<unit, actor_test>\n\t{\n\t\tprotected override ettask run(unit unit, actor_test message)\n\t\t{\n\t\t\tlog.debug(message.info);\n\t\t}\n\t}\n\n    // 处理rpc消息, 需要继承amactorrpchandler抽象类，抽象类第一个泛型参数是actor的类型，第二个参数是消息的类型，第三个参数是返回消息的类型\n    [actormessagehandler(apptype.map)]\n\tpublic class actor_transferhandler : amactorrpchandler<unit, actor_transferrequest, actor_transferresponse>\n\t{\n\t\tprotected override async ettask run(unit unit, actor_transferrequest message, action<actor_transferresponse> reply)\n\t\t{\n\t\t\tactor_transferresponse response = new actor_transferresponse();\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\treply(response);\n\t\t\t}\n\t\t\tcatch (exception e)\n\t\t\t{\n\t\t\t\treplyerror(response, e, reply);\n\t\t\t}\n\t\t}\n\t}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n我们需要注意一下，actor消息有死锁的可能，比如a call消息给b，b call给c，c call给a。因为mailboxcomponent本质上是一个消息队列，它开启了一个协程会一个一个消息处理，返回ettask表示这个消息处理类会阻塞mailboxcomponent队列的其它消息。所以如果出现死锁，我们就不希望某个消息处理阻塞掉mailboxcomponent其它消息的处理，我们可以在消息处理类里面新开一个协程来处理就行了。例如:\n\n\t[actormessagehandler(apptype.map)]\n\tpublic class actor_testhandler : amactorhandler<unit, actor_test>\n\t{\n\t\tprotected override ettask run(unit unit, actor_test message)\n\t\t{\n\t\t\trunasync(unit, message).coroutine();\n\t\t}\n\n        public etvoid runasync(unit unit, actor_test message)\n        {\n            log.debug(message.info);\n        }\n\t}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n相关资料可以谷歌一下actor死锁的问题。",charsets:{cjk:!0},lastUpdated:"2022/07/25, 23:10:19",lastUpdatedTimestamp:1658761819e3},{title:"5.5Actor Location-ZH",frontmatter:{title:"5.5Actor Location-ZH",date:"2022-05-31T19:10:27.000Z",permalink:"/pages/9f7296/"},regularPath:"/01.%E6%8C%87%E5%8D%97/01.ETBbook_%E4%B8%AD%E6%96%87/55.5.5Actor%20Location-ZH.html",relativePath:"01.指南/01.ETBbook_中文/55.5.5Actor Location-ZH.md",key:"v-973514f8",path:"/pages/9f7296/",headers:[{level:3,title:"Actor Location",slug:"actor-location-2",normalizedTitle:"actor location",charIndex:2},{level:3,title:"Actor Location消息的处理",slug:"actor-location消息的处理",normalizedTitle:"actor location消息的处理",charIndex:2139},{level:3,title:"ET的actor跟actor location的比喻",slug:"et的actor跟actor-location的比喻",normalizedTitle:"et的actor跟actor location的比喻",charIndex:3583}],headersStr:"Actor Location Actor Location消息的处理 ET的actor跟actor location的比喻",content:'# Actor Location\n\n\n# Actor Location\n\nActor模型只需要知道对方的InstanceId就能发送消息，十分方便，但是有时候我们可能无法知道对方的InstanceId，或者是一个Actor的InstanceId会发生变化。这种场景很常见，比如：很多游戏是分线的，一个玩家可能从1线换到2线，还有的游戏是分场景的，一个场景一个进程，玩家从场景1进入到场景2。因为做了进程迁移，玩家对象的InstanceId也就变化了。ET提供了给这类对象发送消息的机制，叫做Actor Location机制。其原理比较简单：\n\n 1.  因为InstanceId是变化的，对象的Entity.Id是不变的，所以我们首先可以想到使用Entity.Id来发送actor消息\n 2.  提供一个位置进程(Location Server)，Actor对象可以将自己的Entity.Id跟InstanceId作为kv存到位置进程中。发送Actor消息前先去位置进程查询到Actor对象的InstanceId再发送actor消息。\n 3.  Actor对象在一个进程创建时或者迁移到一个新的进程时，都需要把自己的Id跟InstanceId注册到Location Server上去\n 4.  因为Actor对象是可以迁移的，消息发过去有可能Actor已经迁移到其它进程上去了，所以发送Actor Location消息需要提供一种可靠机制\n 5.  ActorLocationSender提供两种方法，Send跟Call，Send一个消息也需要接受者返回一个消息，只有收到返回消息才会发送下一个消息。\n 6.  Actor对象如果迁移走了，这时会返回Actor不存在的错误，发送者收到这个错误会等待1秒，然后重新去获取Actor的InstanceId，然后重新发送，目前会尝试5次，5次过后，抛出异常，报告错误\n 7.  ActorLocationSender发送消息不会每次都去查询Location Server，因为对象迁移毕竟比较少见，只有第一次去查询，之后缓存InstanceId，以后发送失败再重新查询。\n 8.  Actor对象在迁移过程中，有可能其它进程发送过来消息，这时会发生错误，所以location server提供了一种Lock的机制。对象在传送前，删掉在本进程的信息，然后在location server上加上锁，一旦锁上后，其它的对该key的请求会进行队列。\n 9.  传送前因为对方删除了本进程的actor，所以其它进程会发送失败，这时候他们会进行重试。重试的时候会重新请求location server，这时候会发现被锁了，于是一直等待\n 10. 传送完成后，要unlock location server上的锁，并且更新新的地址，然后响应其它的location请求。其它发给这个actor的请求继续进行下去。\n\n注意，Actor模型是纯粹的服务端消息通信机制，跟客户端是没什么关系的，很多用ET的新人看到ET客户端消息也有Actor接口，以为这是客户端跟服务端通信的机制，其实不是的。ET客户端使用这个Actor完全是因为Gate需要对客户端消息进行转发，我们可以正好利用服务端actor模型来进行转发，所以客户端有些消息也是继承了actor的接口。假如我们客户端不使用actor接口会怎么样呢？比如，Frame_ClickMap这个消息\n\nmessage Frame_ClickMap // IActorLocationMessage\n{\n\tint64 ActorId = 93;\n\tint64 Id = 94;\n\t\n\tfloat X = 1;\n\tfloat Y = 2;\n\tfloat Z = 3;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n我们可能就不需要ActorId这个字段，消息发送到Gate，gate看到是Frame_ClickMap消息，它需要转发给Map上的Unit，转发还好办，gate可以从session中获取对应的map的unit的位置，然后转发，问题来了，Frame_ClickMap消息到了map，map怎么知道消息需要给哪个对象呢？这时候有几种设计：\n\n 1. 在转发的底层协议中带上unit的Id，需要比较复杂的底层协议支持。\n 2. 用一个消息对Frame_ClickMap消息包装一下，包装的消息带上Unit的Id，用消息包装意味着更大的消耗，增加GC。 个人感觉这两种都很差，不好用，而且就算分发给unit对象处理了，怎么解决消息重入的问题呢？unit对象仍然需要挂上一个消息处理队列，然后收到消息扔到队列里面。这不跟actor模型重复了吗？目前ET在客户端发给unit的消息做了个设计，消息做成actor消息，gate收到发现是actor消息，直接发到对应的actor上，解决的可以说很漂亮。其实客户端仍然是使用session.send跟call发送消息，发送的时候也不知道消息是actor消息，只有到了gate，gate才进行了判断，参考OuterMessageDispatcher.cs\n\n\n# Actor Location消息的处理\n\nActorLocation消息发送\n\n// 从Game.Scene上获取ActorLocationSenderComponent，然后通过Entity.Id获取ActorLocationSender\nActorLocationSender actorLocationSender = Game.Scene.GetComponent<ActorLocationSenderComponent>().Get(unitId);\n// 通过ActorLocationSender来发送消息\nactorLocationSender.Send(actorLocationMessage);\n// 发送Rpc消息\nIResponse response = await actorLocationSender.Call(actorLocationRequest);\n\n\n1\n2\n3\n4\n5\n6\n\n\nActorLocation消息的处理跟Actor消息几乎一样，不同的是继承的两个抽象类不同，注意actorlocation的抽象类多了个Location\n\n\t// 处理send过来的消息， 需要继承AMActorLocationHandler抽象类，抽象类第一个泛型参数是Actor的类型，第二个参数是消息的类型\n\t[ActorMessageHandler(AppType.Map)]\n\tpublic class Frame_ClickMapHandler : AMActorLocationHandler<Unit, Frame_ClickMap>\n\t{\n\t\tprotected override ETTask Run(Unit unit, Frame_ClickMap message)\n\t\t{\n\t\t\tVector3 target = new Vector3(message.X, message.Y, message.Z);\n\t\t\tunit.GetComponent<UnitPathComponent>().MoveTo(target).Coroutine();\n\t\t\t\n\t\t}\n\t}\n\n\t// 处理Rpc消息, 需要继承AMActorRpcHandler抽象类，抽象类第一个泛型参数是Actor的类型，第二个参数是消息的类型，第三个参数是返回消息的类型\n\t[ActorMessageHandler(AppType.Map)]\n\tpublic class C2M_TestActorRequestHandler : AMActorLocationRpcHandler<Unit, C2M_TestActorRequest, M2C_TestActorResponse>\n\t{\n\t\tprotected override async ETTask Run(Unit unit, C2M_TestActorRequest message, Action<M2C_TestActorResponse> reply)\n\t\t{\n\t\t\treply(new M2C_TestActorResponse(){Info = "actor rpc response"});\n\t\t\tawait ETTask.CompletedTask;\n\t\t}\n\t}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# ET的actor跟actor location的比喻\n\n中国有很多城市（进程），城市中有很多人（entity对象）居住，每个人都有身份证号码（Entity.Id）。一个人每到一个市都需要办理居住证，分配到唯一的居住证号码（InstanceId），居住证号码的格式是2个字节市编号+4个字节时间+2个字节递增。身份证号码是永远不会变化的，但是居住证号码每到一个城市都变化的。 现在有个中国邮政（actor）。假设小明要发信给女朋友小红\n\n 1. 小红为了收信，自己必须挂载一个邮箱（MailboxComponent），小红收到消息就会处理。注意这里处理是一个个进行处理的。有可能小红会同时收到很多人的信。但是她必须一封一封的信看，比方说小明跟小宝都发了信给小红，小红先收到小明的信，再收到了小宝的信。小红先读小明的信，小明信中让小红给外婆打个电话（产生协程）再给自己回信，注意这期间小红也不能读下一封信，必须打完电话后才能读小宝的信。当然小红自己可以选择不处理完成就开始读小宝的信，做法是小红开一个新的协程来处理小明的信。\n 2. 假设小明知道小红的居住证号码，那么邮政（actor）可以根据居住证号码头两位找到小红居住的城市（进程），然后再根据小红的居住证编号，找到小红，把消息投递到小红的邮箱（MailboxComponent）中。这种是最简单的原生的actor模型\n 3. ET还支持了一套actor location机制。假设小明不知道小红的居住证号码，但是他知道小红的身份证号码，怎么办呢？邮政开发了一套高级邮政（actor location）想了一个办法，如果一个人经常搬家，它还想收到信，那他到一个新的城市都必须把自己的居住证跟身份证上报到中央政府（location server），这样高级邮政能够通过身份证号码来发送邮件。方法就是去中央政府拿到小红的居住证号码，再利用actor机制发送。\n 4. 假设小红之前在广州市，小明用小红的身份证给小红发信件了。 高级邮政获取了小红的居住证号码，给小红发信。发信的这个过程中，小红搬家了，从广州搬到了深圳，这时小红在中央政府上报了自己新的居住证。 高级邮政的信送到到广州的时候发现，小红不在广州。那么高级邮政会再次去中央政府获取小红的居住证，重新发送，有可能成功有可能再次失败，这个过程会重复几次，如果一直不成功则告诉小明，信件发送失败了。\n 5. 高级邮政发信比较贵，而且人搬家的次数并不多，一般小明用高级邮政发信后会记住小红的居住证，下次再发的时候直接用居住证发信，发送失败了再使用高级邮政发信。\n 6. 高级邮政的信都是有回执的，有两种回执，一种回执没有内容，只表示小红收到了信，一种回执带了小红的回信。小明在发信的时候可以选择使用哪种回执形式。小明给小红不能同时发送两封信，必须等小红的回执到了，小明才能继续发信。',normalizedContent:'# actor location\n\n\n# actor location\n\nactor模型只需要知道对方的instanceid就能发送消息，十分方便，但是有时候我们可能无法知道对方的instanceid，或者是一个actor的instanceid会发生变化。这种场景很常见，比如：很多游戏是分线的，一个玩家可能从1线换到2线，还有的游戏是分场景的，一个场景一个进程，玩家从场景1进入到场景2。因为做了进程迁移，玩家对象的instanceid也就变化了。et提供了给这类对象发送消息的机制，叫做actor location机制。其原理比较简单：\n\n 1.  因为instanceid是变化的，对象的entity.id是不变的，所以我们首先可以想到使用entity.id来发送actor消息\n 2.  提供一个位置进程(location server)，actor对象可以将自己的entity.id跟instanceid作为kv存到位置进程中。发送actor消息前先去位置进程查询到actor对象的instanceid再发送actor消息。\n 3.  actor对象在一个进程创建时或者迁移到一个新的进程时，都需要把自己的id跟instanceid注册到location server上去\n 4.  因为actor对象是可以迁移的，消息发过去有可能actor已经迁移到其它进程上去了，所以发送actor location消息需要提供一种可靠机制\n 5.  actorlocationsender提供两种方法，send跟call，send一个消息也需要接受者返回一个消息，只有收到返回消息才会发送下一个消息。\n 6.  actor对象如果迁移走了，这时会返回actor不存在的错误，发送者收到这个错误会等待1秒，然后重新去获取actor的instanceid，然后重新发送，目前会尝试5次，5次过后，抛出异常，报告错误\n 7.  actorlocationsender发送消息不会每次都去查询location server，因为对象迁移毕竟比较少见，只有第一次去查询，之后缓存instanceid，以后发送失败再重新查询。\n 8.  actor对象在迁移过程中，有可能其它进程发送过来消息，这时会发生错误，所以location server提供了一种lock的机制。对象在传送前，删掉在本进程的信息，然后在location server上加上锁，一旦锁上后，其它的对该key的请求会进行队列。\n 9.  传送前因为对方删除了本进程的actor，所以其它进程会发送失败，这时候他们会进行重试。重试的时候会重新请求location server，这时候会发现被锁了，于是一直等待\n 10. 传送完成后，要unlock location server上的锁，并且更新新的地址，然后响应其它的location请求。其它发给这个actor的请求继续进行下去。\n\n注意，actor模型是纯粹的服务端消息通信机制，跟客户端是没什么关系的，很多用et的新人看到et客户端消息也有actor接口，以为这是客户端跟服务端通信的机制，其实不是的。et客户端使用这个actor完全是因为gate需要对客户端消息进行转发，我们可以正好利用服务端actor模型来进行转发，所以客户端有些消息也是继承了actor的接口。假如我们客户端不使用actor接口会怎么样呢？比如，frame_clickmap这个消息\n\nmessage frame_clickmap // iactorlocationmessage\n{\n\tint64 actorid = 93;\n\tint64 id = 94;\n\t\n\tfloat x = 1;\n\tfloat y = 2;\n\tfloat z = 3;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n我们可能就不需要actorid这个字段，消息发送到gate，gate看到是frame_clickmap消息，它需要转发给map上的unit，转发还好办，gate可以从session中获取对应的map的unit的位置，然后转发，问题来了，frame_clickmap消息到了map，map怎么知道消息需要给哪个对象呢？这时候有几种设计：\n\n 1. 在转发的底层协议中带上unit的id，需要比较复杂的底层协议支持。\n 2. 用一个消息对frame_clickmap消息包装一下，包装的消息带上unit的id，用消息包装意味着更大的消耗，增加gc。 个人感觉这两种都很差，不好用，而且就算分发给unit对象处理了，怎么解决消息重入的问题呢？unit对象仍然需要挂上一个消息处理队列，然后收到消息扔到队列里面。这不跟actor模型重复了吗？目前et在客户端发给unit的消息做了个设计，消息做成actor消息，gate收到发现是actor消息，直接发到对应的actor上，解决的可以说很漂亮。其实客户端仍然是使用session.send跟call发送消息，发送的时候也不知道消息是actor消息，只有到了gate，gate才进行了判断，参考outermessagedispatcher.cs\n\n\n# actor location消息的处理\n\nactorlocation消息发送\n\n// 从game.scene上获取actorlocationsendercomponent，然后通过entity.id获取actorlocationsender\nactorlocationsender actorlocationsender = game.scene.getcomponent<actorlocationsendercomponent>().get(unitid);\n// 通过actorlocationsender来发送消息\nactorlocationsender.send(actorlocationmessage);\n// 发送rpc消息\niresponse response = await actorlocationsender.call(actorlocationrequest);\n\n\n1\n2\n3\n4\n5\n6\n\n\nactorlocation消息的处理跟actor消息几乎一样，不同的是继承的两个抽象类不同，注意actorlocation的抽象类多了个location\n\n\t// 处理send过来的消息， 需要继承amactorlocationhandler抽象类，抽象类第一个泛型参数是actor的类型，第二个参数是消息的类型\n\t[actormessagehandler(apptype.map)]\n\tpublic class frame_clickmaphandler : amactorlocationhandler<unit, frame_clickmap>\n\t{\n\t\tprotected override ettask run(unit unit, frame_clickmap message)\n\t\t{\n\t\t\tvector3 target = new vector3(message.x, message.y, message.z);\n\t\t\tunit.getcomponent<unitpathcomponent>().moveto(target).coroutine();\n\t\t\t\n\t\t}\n\t}\n\n\t// 处理rpc消息, 需要继承amactorrpchandler抽象类，抽象类第一个泛型参数是actor的类型，第二个参数是消息的类型，第三个参数是返回消息的类型\n\t[actormessagehandler(apptype.map)]\n\tpublic class c2m_testactorrequesthandler : amactorlocationrpchandler<unit, c2m_testactorrequest, m2c_testactorresponse>\n\t{\n\t\tprotected override async ettask run(unit unit, c2m_testactorrequest message, action<m2c_testactorresponse> reply)\n\t\t{\n\t\t\treply(new m2c_testactorresponse(){info = "actor rpc response"});\n\t\t\tawait ettask.completedtask;\n\t\t}\n\t}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# et的actor跟actor location的比喻\n\n中国有很多城市（进程），城市中有很多人（entity对象）居住，每个人都有身份证号码（entity.id）。一个人每到一个市都需要办理居住证，分配到唯一的居住证号码（instanceid），居住证号码的格式是2个字节市编号+4个字节时间+2个字节递增。身份证号码是永远不会变化的，但是居住证号码每到一个城市都变化的。 现在有个中国邮政（actor）。假设小明要发信给女朋友小红\n\n 1. 小红为了收信，自己必须挂载一个邮箱（mailboxcomponent），小红收到消息就会处理。注意这里处理是一个个进行处理的。有可能小红会同时收到很多人的信。但是她必须一封一封的信看，比方说小明跟小宝都发了信给小红，小红先收到小明的信，再收到了小宝的信。小红先读小明的信，小明信中让小红给外婆打个电话（产生协程）再给自己回信，注意这期间小红也不能读下一封信，必须打完电话后才能读小宝的信。当然小红自己可以选择不处理完成就开始读小宝的信，做法是小红开一个新的协程来处理小明的信。\n 2. 假设小明知道小红的居住证号码，那么邮政（actor）可以根据居住证号码头两位找到小红居住的城市（进程），然后再根据小红的居住证编号，找到小红，把消息投递到小红的邮箱（mailboxcomponent）中。这种是最简单的原生的actor模型\n 3. et还支持了一套actor location机制。假设小明不知道小红的居住证号码，但是他知道小红的身份证号码，怎么办呢？邮政开发了一套高级邮政（actor location）想了一个办法，如果一个人经常搬家，它还想收到信，那他到一个新的城市都必须把自己的居住证跟身份证上报到中央政府（location server），这样高级邮政能够通过身份证号码来发送邮件。方法就是去中央政府拿到小红的居住证号码，再利用actor机制发送。\n 4. 假设小红之前在广州市，小明用小红的身份证给小红发信件了。 高级邮政获取了小红的居住证号码，给小红发信。发信的这个过程中，小红搬家了，从广州搬到了深圳，这时小红在中央政府上报了自己新的居住证。 高级邮政的信送到到广州的时候发现，小红不在广州。那么高级邮政会再次去中央政府获取小红的居住证，重新发送，有可能成功有可能再次失败，这个过程会重复几次，如果一直不成功则告诉小明，信件发送失败了。\n 5. 高级邮政发信比较贵，而且人搬家的次数并不多，一般小明用高级邮政发信后会记住小红的居住证，下次再发的时候直接用居住证发信，发送失败了再使用高级邮政发信。\n 6. 高级邮政的信都是有回执的，有两种回执，一种回执没有内容，只表示小红收到了信，一种回执带了小红的回信。小明在发信的时候可以选择使用哪种回执形式。小明给小红不能同时发送两封信，必须等小红的回执到了，小明才能继续发信。',charsets:{cjk:!0},lastUpdated:"2022/07/25, 23:10:19",lastUpdatedTimestamp:1658761819e3},{title:"5.6数值组件设计",frontmatter:{title:"5.6数值组件设计",date:"2022-05-31T19:10:27.000Z",permalink:"/pages/1dc51a/"},regularPath:"/01.%E6%8C%87%E5%8D%97/01.ETBbook_%E4%B8%AD%E6%96%87/56.5.6%E6%95%B0%E5%80%BC%E7%BB%84%E4%BB%B6%E8%AE%BE%E8%AE%A1.html",relativePath:"01.指南/01.ETBbook_中文/56.5.6数值组件设计.md",key:"v-2c9acafa",path:"/pages/1dc51a/",headers:[{level:2,title:"普通的做法:",slug:"普通的做法",normalizedTitle:"普通的做法:",charIndex:232},{level:2,title:"ET框架采用了Key Value形式保存数值属性",slug:"et框架采用了key-value形式保存数值属性",normalizedTitle:"et框架采用了key value形式保存数值属性",charIndex:1833}],headersStr:"普通的做法: ET框架采用了Key Value形式保存数值属性",content:"类似魔兽世界，moba这种技能极其复杂，灵活性要求极高的技能系统，必须需要一套及其灵活的数值结构来搭配。数值结构设计好了，实现技能系统就会非常简单，否则就是一场灾难。比如魔兽世界，一个人物的数值属性非常之多，移动速度，力量，怒气，能量，集中值，魔法值，血量，最大血量，物理攻击，物理防御，法术攻击，法术防御，等等多达几十种之多。属性跟属性之间又相互影响，buff又会给属性增加绝对值，增加百分比，或者某种buff又会在算完所有的增加值之后再来给你翻个倍。\n\n\n# 普通的做法:\n\n一般就是写个数值类：\n\nclass Numeric\n{\n    public int Hp;\n    public int MaxHp;\n    public int Speed;\n    // 能量\n    public int Energy;\n    public int MaxEnergy;\n    // 魔法\n    public int Mp;\n    public int MaxMp;\n    .....\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n仔细一想，我一个盗贼使用的是能量，为什么要有一个Mp的值？我一个法师使用的是魔法为什么要有能量的字段？纠结这个搞毛，当作没看见不就行了吗？实在不行，我来个继承？\n\n// 法师数值\ncalss MageNumeric: Numeric\n{\n    // 魔法\n    public int Mp;\n    public int MaxMp;\n}\n\n// 盗贼数值\ncalss RougeNumeric: Numeric\n{\n    // 能量\n    public int Energy;\n    public int MaxEnergy;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n10个种族，每个种族7，8种英雄，光这些数值类继承关系，你就得懵逼了吧。面向对象是难以适应这种灵活的复杂的需求的。\n\n再来看看Numeric类，每种数值可不能只设计一个字段，比如说，我有个buff会增加10点Speed，还有种buff增加50%的speed，那我至少还得加三个二级属性字段\n\nclass Numeric\n{\n    // 速度最终值\n    public int Speed;\n    // 速度初始值\n    public int SpeedInit;\n    // 速度增加值\n    public int SpeedAdd;\n    // 速度增加百分比值\n    public int SpeedPct;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nSpeedAdd跟SpeedPct改变后，进行一次计算，就可以算出最终的速度值。buff只需要去修改SpeedAdd跟SpeedPct就行了。\n\nSpeed = (SpeedInit + SpeedAdd) * (100 + SpeedPct) / 100\n\n\n1\n\n\n每种属性都可能有好几种间接影响值，可以想想这个类是多么庞大，初略估计得有100多个字段。麻烦的是计算公式基本一样，但是就是无法统一成一个函数，例如MaxHp，也有buff影响\n\nclass Numeric\n{\n    public int Speed;\n    public int SpeedInit;\n    public int SpeedAdd;\n    public int SpeedPct;\n    \n    public int MaxHp;\n    public int MaxHpInit;\n    public int MaxHpAdd;\n    public int MaxHpPct;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n也得写个Hp的计算公式\n\nMaxHp=(MaxHpInit + MaxHpAdd) * (100  + MaxHpPct) / 100\n\n\n1\n\n\n几十种属性，就要写几十遍，并且每个二级属性改变都要正确调用对应的公式计算. 非常麻烦！ 这样设计还有个很大的问题，buff配置表填对应的属性字段不是很好填，例如疾跑buff（增加速度50%），在buff表中怎么配置才能让程序简单的找到并操作SpeedPct字段呢？不好搞。\n\n\n# ET框架采用了Key Value形式保存数值属性\n\nusing System.Collections.Generic;\n\nnamespace Model\n{\n    public enum NumericType\n    {\n\t\tMax = 10000,\n\n\t\tSpeed = 1000,\n\t\tSpeedBase = Speed * 10 + 1,\n\t    SpeedAdd = Speed * 10 + 2,\n\t    SpeedPct = Speed * 10 + 3,\n\t    SpeedFinalAdd = Speed * 10 + 4,\n\t    SpeedFinalPct = Speed * 10 + 5,\n\n\t    Hp = 1001,\n\t    HpBase = Hp * 10 + 1,\n\n\t    MaxHp = 1002,\n\t    MaxHpBase = MaxHp * 10 + 1,\n\t    MaxHpAdd = MaxHp * 10 + 2,\n\t    MaxHpPct = MaxHp * 10 + 3,\n\t    MaxHpFinalAdd = MaxHp * 10 + 4,\n\t\tMaxHpFinalPct = MaxHp * 10 + 5,\n\t}\n\n\tpublic class NumericComponent: Component\n\t{\n\t\tpublic readonly Dictionary<int, int> NumericDic = new Dictionary<int, int>();\n\n\t\tpublic void Awake()\n\t\t{\n\t\t\t// 这里初始化base值\n\t\t}\n\n\t\tpublic float GetAsFloat(NumericType numericType)\n\t\t{\n\t\t\treturn (float)GetByKey((int)numericType) / 10000;\n\t\t}\n\n\t\tpublic int GetAsInt(NumericType numericType)\n\t\t{\n\t\t\treturn GetByKey((int)numericType);\n\t\t}\n\n\t\tpublic void Set(NumericType nt, float value)\n\t\t{\n\t\t\tthis[nt] = (int) (value * 10000);\n\t\t}\n\n\t\tpublic void Set(NumericType nt, int value)\n\t\t{\n\t\t\tthis[nt] = value;\n\t\t}\n\n\t\tpublic int this[NumericType numericType]\n\t\t{\n\t\t\tget\n\t\t\t{\n\t\t\t\treturn this.GetByKey((int) numericType);\n\t\t\t}\n\t\t\tset\n\t\t\t{\n\t\t\t\tint v = this.GetByKey((int) numericType);\n\t\t\t\tif (v == value)\n\t\t\t\t{\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tNumericDic[(int)numericType] = value;\n\n\t\t\t\tUpdate(numericType);\n\t\t\t}\n\t\t}\n\n\t\tprivate int GetByKey(int key)\n\t\t{\n\t\t\tint value = 0;\n\t\t\tthis.NumericDic.TryGetValue(key, out value);\n\t\t\treturn value;\n\t\t}\n\n\t\tpublic void Update(NumericType numericType)\n\t\t{\n\t\t\tif (numericType > NumericType.Max)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint final = (int) numericType / 10;\n\t\t\tint bas = final * 10 + 1; \n\t\t\tint add = final * 10 + 2;\n\t\t\tint pct = final * 10 + 3;\n\t\t\tint finalAdd = final * 10 + 4;\n\t\t\tint finalPct = final * 10 + 5;\n\n\t\t\t// 一个数值可能会多种情况影响，比如速度,加个buff可能增加速度绝对值100，也有些buff增加10%速度，所以一个值可以由5个值进行控制其最终结果\n\t\t\t// final = (((base + add) * (100 + pct) / 100) + finalAdd) * (100 + finalPct) / 100;\n\t\t\tthis.NumericDic[final] = ((this.GetByKey(bas) + this.GetByKey(add)) * (100 + this.GetByKey(pct)) / 100 + this.GetByKey(finalAdd)) * (100 + this.GetByKey(finalPct)) / 100;\n\t\t\tGame.EventSystem.Run(EventIdType.NumbericChange, this.Entity.Id, numericType, final);\n\t\t}\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n\n\n1.数值都用key value来保存，key是数值的类型，由NumericType来定义，value都是整数，float型也可以转成整数，例如乘以1000；key value保存属性会变得非常灵活，例如法师没有能量属性，那么初始化法师对象不加能量的key value就好了。盗贼没有法力值，没有法术伤害等等，初始化就不用加这些。\n\n2.魔兽世界中，一个数值由5个值来影响，可以统一使用一条公式：\n\nfinal = (((base + add) * (100 + pct) / 100) + finalAdd) * (100 + finalPct) / 100;\n\n\n1\n\n\n比如说速度值speed，有个初始值speedbase，有个buff1增加10点绝对速度，那么buff1创建的时候会给speedadd加10，buff1删除的时候给speedadd减10，buff2增加20%的速度，那么buff2创建的时候给speedpct加20，buff2删除的时候给speedpct减20.甚至可能有buff3，会在最终值上再加100%，那么buff3将影响speedfinalpct。这5个值发生改变，统一使用Update函数就可以重新计算对应的属性了。buff配置中对应数值字段相当简单，buff配置中填上相应的NumericType，程序很轻松就能操作对应的数值。\n\n3.属性的改变可以统一抛出事件给其它模块订阅，写一个属性变化监视器变得非常简单。例如成就模块需要开发一个成就生命值超过1000，会获得长寿大师的成就。那么开发成就模块的人将订阅HP的变化：\n\n\t/// 监视hp数值变化\n\t[NumericWatcher(NumericType.Hp)]\n\tpublic class NumericWatcher_Hp : INumericWatcher\n\t{\n\t\tpublic void Run(long id, int value)\n\t\t{\n\t\t    if (value > 1000)\n\t\t    {\n\t\t        //获得成就长寿大师成就\n\t\t    }\n\t\t}\n\t}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n同理，记录一次金币变化大于10000的异常日志等等都可以这样做。\n\n有了这个数值组件，一个moba技能系统可以说已经完成了一半。\n\n代码地址：https://github.com/egametang/Egametang",normalizedContent:"类似魔兽世界，moba这种技能极其复杂，灵活性要求极高的技能系统，必须需要一套及其灵活的数值结构来搭配。数值结构设计好了，实现技能系统就会非常简单，否则就是一场灾难。比如魔兽世界，一个人物的数值属性非常之多，移动速度，力量，怒气，能量，集中值，魔法值，血量，最大血量，物理攻击，物理防御，法术攻击，法术防御，等等多达几十种之多。属性跟属性之间又相互影响，buff又会给属性增加绝对值，增加百分比，或者某种buff又会在算完所有的增加值之后再来给你翻个倍。\n\n\n# 普通的做法:\n\n一般就是写个数值类：\n\nclass numeric\n{\n    public int hp;\n    public int maxhp;\n    public int speed;\n    // 能量\n    public int energy;\n    public int maxenergy;\n    // 魔法\n    public int mp;\n    public int maxmp;\n    .....\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n仔细一想，我一个盗贼使用的是能量，为什么要有一个mp的值？我一个法师使用的是魔法为什么要有能量的字段？纠结这个搞毛，当作没看见不就行了吗？实在不行，我来个继承？\n\n// 法师数值\ncalss magenumeric: numeric\n{\n    // 魔法\n    public int mp;\n    public int maxmp;\n}\n\n// 盗贼数值\ncalss rougenumeric: numeric\n{\n    // 能量\n    public int energy;\n    public int maxenergy;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n10个种族，每个种族7，8种英雄，光这些数值类继承关系，你就得懵逼了吧。面向对象是难以适应这种灵活的复杂的需求的。\n\n再来看看numeric类，每种数值可不能只设计一个字段，比如说，我有个buff会增加10点speed，还有种buff增加50%的speed，那我至少还得加三个二级属性字段\n\nclass numeric\n{\n    // 速度最终值\n    public int speed;\n    // 速度初始值\n    public int speedinit;\n    // 速度增加值\n    public int speedadd;\n    // 速度增加百分比值\n    public int speedpct;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nspeedadd跟speedpct改变后，进行一次计算，就可以算出最终的速度值。buff只需要去修改speedadd跟speedpct就行了。\n\nspeed = (speedinit + speedadd) * (100 + speedpct) / 100\n\n\n1\n\n\n每种属性都可能有好几种间接影响值，可以想想这个类是多么庞大，初略估计得有100多个字段。麻烦的是计算公式基本一样，但是就是无法统一成一个函数，例如maxhp，也有buff影响\n\nclass numeric\n{\n    public int speed;\n    public int speedinit;\n    public int speedadd;\n    public int speedpct;\n    \n    public int maxhp;\n    public int maxhpinit;\n    public int maxhpadd;\n    public int maxhppct;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n也得写个hp的计算公式\n\nmaxhp=(maxhpinit + maxhpadd) * (100  + maxhppct) / 100\n\n\n1\n\n\n几十种属性，就要写几十遍，并且每个二级属性改变都要正确调用对应的公式计算. 非常麻烦！ 这样设计还有个很大的问题，buff配置表填对应的属性字段不是很好填，例如疾跑buff（增加速度50%），在buff表中怎么配置才能让程序简单的找到并操作speedpct字段呢？不好搞。\n\n\n# et框架采用了key value形式保存数值属性\n\nusing system.collections.generic;\n\nnamespace model\n{\n    public enum numerictype\n    {\n\t\tmax = 10000,\n\n\t\tspeed = 1000,\n\t\tspeedbase = speed * 10 + 1,\n\t    speedadd = speed * 10 + 2,\n\t    speedpct = speed * 10 + 3,\n\t    speedfinaladd = speed * 10 + 4,\n\t    speedfinalpct = speed * 10 + 5,\n\n\t    hp = 1001,\n\t    hpbase = hp * 10 + 1,\n\n\t    maxhp = 1002,\n\t    maxhpbase = maxhp * 10 + 1,\n\t    maxhpadd = maxhp * 10 + 2,\n\t    maxhppct = maxhp * 10 + 3,\n\t    maxhpfinaladd = maxhp * 10 + 4,\n\t\tmaxhpfinalpct = maxhp * 10 + 5,\n\t}\n\n\tpublic class numericcomponent: component\n\t{\n\t\tpublic readonly dictionary<int, int> numericdic = new dictionary<int, int>();\n\n\t\tpublic void awake()\n\t\t{\n\t\t\t// 这里初始化base值\n\t\t}\n\n\t\tpublic float getasfloat(numerictype numerictype)\n\t\t{\n\t\t\treturn (float)getbykey((int)numerictype) / 10000;\n\t\t}\n\n\t\tpublic int getasint(numerictype numerictype)\n\t\t{\n\t\t\treturn getbykey((int)numerictype);\n\t\t}\n\n\t\tpublic void set(numerictype nt, float value)\n\t\t{\n\t\t\tthis[nt] = (int) (value * 10000);\n\t\t}\n\n\t\tpublic void set(numerictype nt, int value)\n\t\t{\n\t\t\tthis[nt] = value;\n\t\t}\n\n\t\tpublic int this[numerictype numerictype]\n\t\t{\n\t\t\tget\n\t\t\t{\n\t\t\t\treturn this.getbykey((int) numerictype);\n\t\t\t}\n\t\t\tset\n\t\t\t{\n\t\t\t\tint v = this.getbykey((int) numerictype);\n\t\t\t\tif (v == value)\n\t\t\t\t{\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tnumericdic[(int)numerictype] = value;\n\n\t\t\t\tupdate(numerictype);\n\t\t\t}\n\t\t}\n\n\t\tprivate int getbykey(int key)\n\t\t{\n\t\t\tint value = 0;\n\t\t\tthis.numericdic.trygetvalue(key, out value);\n\t\t\treturn value;\n\t\t}\n\n\t\tpublic void update(numerictype numerictype)\n\t\t{\n\t\t\tif (numerictype > numerictype.max)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint final = (int) numerictype / 10;\n\t\t\tint bas = final * 10 + 1; \n\t\t\tint add = final * 10 + 2;\n\t\t\tint pct = final * 10 + 3;\n\t\t\tint finaladd = final * 10 + 4;\n\t\t\tint finalpct = final * 10 + 5;\n\n\t\t\t// 一个数值可能会多种情况影响，比如速度,加个buff可能增加速度绝对值100，也有些buff增加10%速度，所以一个值可以由5个值进行控制其最终结果\n\t\t\t// final = (((base + add) * (100 + pct) / 100) + finaladd) * (100 + finalpct) / 100;\n\t\t\tthis.numericdic[final] = ((this.getbykey(bas) + this.getbykey(add)) * (100 + this.getbykey(pct)) / 100 + this.getbykey(finaladd)) * (100 + this.getbykey(finalpct)) / 100;\n\t\t\tgame.eventsystem.run(eventidtype.numbericchange, this.entity.id, numerictype, final);\n\t\t}\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n\n\n1.数值都用key value来保存，key是数值的类型，由numerictype来定义，value都是整数，float型也可以转成整数，例如乘以1000；key value保存属性会变得非常灵活，例如法师没有能量属性，那么初始化法师对象不加能量的key value就好了。盗贼没有法力值，没有法术伤害等等，初始化就不用加这些。\n\n2.魔兽世界中，一个数值由5个值来影响，可以统一使用一条公式：\n\nfinal = (((base + add) * (100 + pct) / 100) + finaladd) * (100 + finalpct) / 100;\n\n\n1\n\n\n比如说速度值speed，有个初始值speedbase，有个buff1增加10点绝对速度，那么buff1创建的时候会给speedadd加10，buff1删除的时候给speedadd减10，buff2增加20%的速度，那么buff2创建的时候给speedpct加20，buff2删除的时候给speedpct减20.甚至可能有buff3，会在最终值上再加100%，那么buff3将影响speedfinalpct。这5个值发生改变，统一使用update函数就可以重新计算对应的属性了。buff配置中对应数值字段相当简单，buff配置中填上相应的numerictype，程序很轻松就能操作对应的数值。\n\n3.属性的改变可以统一抛出事件给其它模块订阅，写一个属性变化监视器变得非常简单。例如成就模块需要开发一个成就生命值超过1000，会获得长寿大师的成就。那么开发成就模块的人将订阅hp的变化：\n\n\t/// 监视hp数值变化\n\t[numericwatcher(numerictype.hp)]\n\tpublic class numericwatcher_hp : inumericwatcher\n\t{\n\t\tpublic void run(long id, int value)\n\t\t{\n\t\t    if (value > 1000)\n\t\t    {\n\t\t        //获得成就长寿大师成就\n\t\t    }\n\t\t}\n\t}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n同理，记录一次金币变化大于10000的异常日志等等都可以这样做。\n\n有了这个数值组件，一个moba技能系统可以说已经完成了一半。\n\n代码地址：https://github.com/egametang/egametang",charsets:{cjk:!0},lastUpdated:"2022/07/25, 23:10:19",lastUpdatedTimestamp:1658761819e3},{title:"6.1AI框架",frontmatter:{title:"6.1AI框架",date:"2022-05-31T19:10:27.000Z",permalink:"/pages/d9bb29/"},regularPath:"/01.%E6%8C%87%E5%8D%97/01.ETBbook_%E4%B8%AD%E6%96%87/61.6.1AI%E6%A1%86%E6%9E%B6.html",relativePath:"01.指南/01.ETBbook_中文/61.6.1AI框架.md",key:"v-5d10c0ed",path:"/pages/d9bb29/",headers:[{level:2,title:"1. 几种AI的设计",slug:"_1-几种ai的设计",normalizedTitle:"1. 几种ai的设计",charIndex:11},{level:3,title:"a. 状态机",slug:"a-状态机",normalizedTitle:"a. 状态机",charIndex:97},{level:3,title:"b. 行为树",slug:"b-行为树",normalizedTitle:"b. 行为树",charIndex:529},{level:2,title:"2. 我的做法",slug:"_2-我的做法",normalizedTitle:"2. 我的做法",charIndex:908}],headersStr:"1. 几种AI的设计 a. 状态机 b. 行为树 2. 我的做法",content:"# AI框架\n\n\n# 1. 几种AI的设计\n\nAI在游戏中很多，但是为什么大家总是感觉ai编写起来十分困难，我后来思考了一番，主要原因是使用的方法不当。之前大家编写ai主要有几种方案：\n\n\n# a. 状态机\n\n我是不知道谁想出来这个做法的，真是无力吐槽。本来对象身上任何数据都是状态，这种方法又要把一些状态定义成一种新的节点，对象身上状态变化会引起节点之间的转换，执行对应的方法，比如OnEnter OnExit等等。这里以怪物来举例，怪物可以分为多种状态，巡逻，攻击，追逐，返回。怪物的状态变化有:\n\n巡逻->追逐 巡逻状态发现远处有敌人变追逐状态\n巡逻->攻击 巡逻发现可以攻击敌人变攻击状态\n攻击->追逐 攻击状态发现敌人有段距离于是去追逐\n攻击->返回 攻击状态发现距离敌人过远变返回状态\n追逐->返回 追逐状态发现距离敌人过远变返回状态\n\n太多状态转换了，这里有没有漏掉我已经难以发现了。一旦节点更多，任何两个节点都可能需要连接，将成为超级复杂的网状结构，复杂度是N的平方级，维护起来十分困难。为了解决网状结构变复杂的问题于是又升级为分层状态机等等。当然各种打补丁的方法还是没能解决本质的问题。用不好状态机不是你们的问题，是状态机的问题。\n\n\n# b. 行为树\n\n可能大家都觉得状态机解决复杂ai实在太困难了，于是有人想出了行为树来做ai。行为树的ai是响应式ai，这棵树从上往下（或者从左往右执行，这里以从上往下举例）实际上是把action节点排了个优先级，上面的action最先判断是否满足条件，满足则执行。这里就不详细讲了。行为树的复杂度是N，比状态机大大简化了，但是仍然存在不少缺陷，ai太复杂的时候，树会变得非常大，而且难以重构。比如我们自己项目，要做一个跟人差不多的机器人ai，自动做任务，打怪，玩游戏中的系统，跟人聊天，甚至攻击别人。想象一下，这颗树将变得多复杂！行为树的另外一个缺陷是某些action节点是个持久的过程，也就是说是个协程，行为树管理起协程起来不太好处理，比如上面的例子，需要移动到目标身边，这个移动究竟是做成协程呢，还是每帧move呢？这是个难题，怎么做都不舒服。\n\n\n# 2. 我的做法\n\nai是什么呢？很简单啊，ai就是不停的根据当前的状态，执行相应的行为。记住这两句话，很重要，这就是ai的本质！这两句话分成两部分，一是状态判断，二是执行行为。状态判断好理解，行为是啥？以上面状态机的怪物举例子，怪物的行为就是 巡逻，攻击敌人，返回巡逻点。比如：\n\n巡逻 （当怪物在巡逻范围内，周围没有敌人，选择下一个巡逻点，移动）\n攻击敌人 （当怪物发现警戒范围内有敌人，如果攻击距离够就攻击，不够就移动过去攻击）\n返回 （当怪物发现离出生点超过一定距离，加上无敌buff，往出生点移动,到了出生点，删除无敌buff）\n\n跟状态机不一样的是，这3个状态的变化完全不关心上一个状态是啥，只关心当前的条件是否满足，满足就执行行为。行为可能能瞬间执行，也可能是一段持续的过程，比如巡逻，选下一个巡逻点移动过去，走到了再选一个点，不停的循环。比如攻击敌人，可能需要移动到目标去攻击。\n\n怎么设计这个ai框架呢？到这里就十分简单了，抽象出ai节点，每个节点包含条件判断，跟执行行为。行为方法应该是一个协程\n\npublic class AINode\n{\n\tpublic virtual bool Check(Unit unit) // 检测条件是否满足\n\t{\t\t\n\t}\n\n\tpublic virtual ETTask Run(Unit unit)\n\t{\t\t\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n进一步思考，假如怪物在巡逻过程中，发现敌人，那么怪物应该要打断当前的巡逻，转而去执行攻击敌人的行为。因此我们行为应该需要支持被打断，也就是说行为协程应该支持取消，这点特别需要注意，行为Run方法中任何协程都要支持取消操作！\n\npublic class AINode\n{\n\tpublic virtual bool Check(Unit unit)\n\t{\t\t\n\t}\n\n\tpublic virtual ETVoid Run(Unit unit, ETCancelToken cancelToken)\n\t{\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n实现三个ai节点 XunLuoNode(巡逻) GongjiNode(攻击) FanHuiNode(返回)\n\npublic class XunLuoNode: AINode\n{\n\tpublic virtual bool Check(Unit unit)\n\t{\n\t\tif (不在巡逻范围)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (周围有敌人)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic virtual ETVoid Run(Unit unit, ETCancelToken cancelToken)\n\t{\n\t\twhile (true)\n\t\t{\n\t\t\tVector3 nextPoint = FindNextPoint();\n\t\t\tbool ret = await MoveToAsync(nextPoint, cancelToken); // 移动到目标点, 返回false表示协程取消\n\t\t\tif (!ret)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// 停留两秒, 注意这里要能取消，任何协程都要能取消\n\t\t\tbool ret = await TimeComponent.Instance.Wait(2000, cancelToken);\n\t\t\tif (!ret)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n同理可以实现另外两个节点。光设计出节点还不行，还需要把各个节点串起来，这样ai才能转动\n\nAINode[] aiNodes = {xunLuoNode, gongjiNode, fanHuiNode};\nAINode current;\nETCancelToken cancelToken;\nwhile(true)\n{\n\t// 每秒中需要重新判断是否满足新的行为了，这个时间可以自己定\n\tawait TimeComponent.Instance.Wait(1000);\n\n\tAINode next;\n\tforeach(var node in aiNodes)\n\t{\n\t\tif (node.Check())\n\t\t{\n\t\t\tnext = node;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (next == null)\n\t{\n\t\tcontinue;\n\t}\n\n\t// 如果下一个节点跟当前执行的节点一样，那么就不执行\n\tif (next == current)\n\t{\n\t\tcontinue;\n\t}\n\n\t// 停止当前协程\n\tcancelToken.Cancel();\n\n\t// 执行下一个协程\n\tcancelToken = new ETCancelToken();\n\tnext.Run(unit, cancelToken).Coroutine();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n这段代码十分简单，意思就是每秒钟遍历节点，直到找到一个满足条件的节点就执行，等下一秒再判断，执行下一个节点之前，先打断当前执行的协程。 几个使用误区:\n\n 1. 行为中如果有协程必须能够取消，并且传入cancelToken，否则会出大事，因为怪物一旦满足执行下个节点，需要取消当前协程。\n 2. 跟行为树与状态机不同，节点的作用只是一块逻辑，节点并不需要共享。共享的是协程方法，比如MoveToAsync，怪物巡逻节点可以使用，怪物攻击敌人节点中追击敌人也可以使用。\n 3. 节点可以做的非常庞大，比如自动做任务节点，移动到npc，接任务，根据任务的子任务做子任务，比如移动到怪点打怪，移动到采集物去采集等等，做完所有子任务，移动到交任务npc交任务。所有的一切都是写在一个while循环中，利用协程串起来。\n\n思考一个大问题，怎么设计一个压测机器人呢？压测机器人需要做到什么？自动做任务，自动玩各种系统，自动攻击敌人，会反击，会找人聊天等等。把上面说的每一条做成一个ai节点即可。兄弟们，AI简不简单?",normalizedContent:"# ai框架\n\n\n# 1. 几种ai的设计\n\nai在游戏中很多，但是为什么大家总是感觉ai编写起来十分困难，我后来思考了一番，主要原因是使用的方法不当。之前大家编写ai主要有几种方案：\n\n\n# a. 状态机\n\n我是不知道谁想出来这个做法的，真是无力吐槽。本来对象身上任何数据都是状态，这种方法又要把一些状态定义成一种新的节点，对象身上状态变化会引起节点之间的转换，执行对应的方法，比如onenter onexit等等。这里以怪物来举例，怪物可以分为多种状态，巡逻，攻击，追逐，返回。怪物的状态变化有:\n\n巡逻->追逐 巡逻状态发现远处有敌人变追逐状态\n巡逻->攻击 巡逻发现可以攻击敌人变攻击状态\n攻击->追逐 攻击状态发现敌人有段距离于是去追逐\n攻击->返回 攻击状态发现距离敌人过远变返回状态\n追逐->返回 追逐状态发现距离敌人过远变返回状态\n\n太多状态转换了，这里有没有漏掉我已经难以发现了。一旦节点更多，任何两个节点都可能需要连接，将成为超级复杂的网状结构，复杂度是n的平方级，维护起来十分困难。为了解决网状结构变复杂的问题于是又升级为分层状态机等等。当然各种打补丁的方法还是没能解决本质的问题。用不好状态机不是你们的问题，是状态机的问题。\n\n\n# b. 行为树\n\n可能大家都觉得状态机解决复杂ai实在太困难了，于是有人想出了行为树来做ai。行为树的ai是响应式ai，这棵树从上往下（或者从左往右执行，这里以从上往下举例）实际上是把action节点排了个优先级，上面的action最先判断是否满足条件，满足则执行。这里就不详细讲了。行为树的复杂度是n，比状态机大大简化了，但是仍然存在不少缺陷，ai太复杂的时候，树会变得非常大，而且难以重构。比如我们自己项目，要做一个跟人差不多的机器人ai，自动做任务，打怪，玩游戏中的系统，跟人聊天，甚至攻击别人。想象一下，这颗树将变得多复杂！行为树的另外一个缺陷是某些action节点是个持久的过程，也就是说是个协程，行为树管理起协程起来不太好处理，比如上面的例子，需要移动到目标身边，这个移动究竟是做成协程呢，还是每帧move呢？这是个难题，怎么做都不舒服。\n\n\n# 2. 我的做法\n\nai是什么呢？很简单啊，ai就是不停的根据当前的状态，执行相应的行为。记住这两句话，很重要，这就是ai的本质！这两句话分成两部分，一是状态判断，二是执行行为。状态判断好理解，行为是啥？以上面状态机的怪物举例子，怪物的行为就是 巡逻，攻击敌人，返回巡逻点。比如：\n\n巡逻 （当怪物在巡逻范围内，周围没有敌人，选择下一个巡逻点，移动）\n攻击敌人 （当怪物发现警戒范围内有敌人，如果攻击距离够就攻击，不够就移动过去攻击）\n返回 （当怪物发现离出生点超过一定距离，加上无敌buff，往出生点移动,到了出生点，删除无敌buff）\n\n跟状态机不一样的是，这3个状态的变化完全不关心上一个状态是啥，只关心当前的条件是否满足，满足就执行行为。行为可能能瞬间执行，也可能是一段持续的过程，比如巡逻，选下一个巡逻点移动过去，走到了再选一个点，不停的循环。比如攻击敌人，可能需要移动到目标去攻击。\n\n怎么设计这个ai框架呢？到这里就十分简单了，抽象出ai节点，每个节点包含条件判断，跟执行行为。行为方法应该是一个协程\n\npublic class ainode\n{\n\tpublic virtual bool check(unit unit) // 检测条件是否满足\n\t{\t\t\n\t}\n\n\tpublic virtual ettask run(unit unit)\n\t{\t\t\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n进一步思考，假如怪物在巡逻过程中，发现敌人，那么怪物应该要打断当前的巡逻，转而去执行攻击敌人的行为。因此我们行为应该需要支持被打断，也就是说行为协程应该支持取消，这点特别需要注意，行为run方法中任何协程都要支持取消操作！\n\npublic class ainode\n{\n\tpublic virtual bool check(unit unit)\n\t{\t\t\n\t}\n\n\tpublic virtual etvoid run(unit unit, etcanceltoken canceltoken)\n\t{\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n实现三个ai节点 xunluonode(巡逻) gongjinode(攻击) fanhuinode(返回)\n\npublic class xunluonode: ainode\n{\n\tpublic virtual bool check(unit unit)\n\t{\n\t\tif (不在巡逻范围)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (周围有敌人)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic virtual etvoid run(unit unit, etcanceltoken canceltoken)\n\t{\n\t\twhile (true)\n\t\t{\n\t\t\tvector3 nextpoint = findnextpoint();\n\t\t\tbool ret = await movetoasync(nextpoint, canceltoken); // 移动到目标点, 返回false表示协程取消\n\t\t\tif (!ret)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// 停留两秒, 注意这里要能取消，任何协程都要能取消\n\t\t\tbool ret = await timecomponent.instance.wait(2000, canceltoken);\n\t\t\tif (!ret)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n同理可以实现另外两个节点。光设计出节点还不行，还需要把各个节点串起来，这样ai才能转动\n\nainode[] ainodes = {xunluonode, gongjinode, fanhuinode};\nainode current;\netcanceltoken canceltoken;\nwhile(true)\n{\n\t// 每秒中需要重新判断是否满足新的行为了，这个时间可以自己定\n\tawait timecomponent.instance.wait(1000);\n\n\tainode next;\n\tforeach(var node in ainodes)\n\t{\n\t\tif (node.check())\n\t\t{\n\t\t\tnext = node;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (next == null)\n\t{\n\t\tcontinue;\n\t}\n\n\t// 如果下一个节点跟当前执行的节点一样，那么就不执行\n\tif (next == current)\n\t{\n\t\tcontinue;\n\t}\n\n\t// 停止当前协程\n\tcanceltoken.cancel();\n\n\t// 执行下一个协程\n\tcanceltoken = new etcanceltoken();\n\tnext.run(unit, canceltoken).coroutine();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n这段代码十分简单，意思就是每秒钟遍历节点，直到找到一个满足条件的节点就执行，等下一秒再判断，执行下一个节点之前，先打断当前执行的协程。 几个使用误区:\n\n 1. 行为中如果有协程必须能够取消，并且传入canceltoken，否则会出大事，因为怪物一旦满足执行下个节点，需要取消当前协程。\n 2. 跟行为树与状态机不同，节点的作用只是一块逻辑，节点并不需要共享。共享的是协程方法，比如movetoasync，怪物巡逻节点可以使用，怪物攻击敌人节点中追击敌人也可以使用。\n 3. 节点可以做的非常庞大，比如自动做任务节点，移动到npc，接任务，根据任务的子任务做子任务，比如移动到怪点打怪，移动到采集物去采集等等，做完所有子任务，移动到交任务npc交任务。所有的一切都是写在一个while循环中，利用协程串起来。\n\n思考一个大问题，怎么设计一个压测机器人呢？压测机器人需要做到什么？自动做任务，自动玩各种系统，自动攻击敌人，会反击，会找人聊天等等。把上面说的每一条做成一个ai节点即可。兄弟们，ai简不简单?",charsets:{cjk:!0},lastUpdated:"2022/07/25, 23:10:19",lastUpdatedTimestamp:1658761819e3},{title:"RunGuide",frontmatter:{title:"RunGuide",date:"2022-05-31T19:10:27.000Z",permalink:"/pages/1e1b9a/"},regularPath:"/02.Guide/01.ETBook_English/02.1.1RunGuide.html",relativePath:"02.Guide/01.ETBook_English/02.1.1RunGuide.md",key:"v-50562bab",path:"/pages/1e1b9a/",headersStr:null,content:'# Run steps\n\n 1. visual studio user instructions.\n    \n    * Versions.\n      * Win10 and above users, use .net6, VS version, must use 2022 and above. Note that VS 2019 does not support .net6 and cannot be used.\n      * Win7 users, can not install VS 2022, need to use .net 5 and VS 2019, but note that additional settings are required to support ET compilation.\n    * Dependencies.\n      * The "Game Development with Unity" extension needs to be installed.\n      * In "Tools-Options-Tools for Unity-General", you need to change the disable full project generation to False in the Miscellaneous section, otherwise it will cause an error in your Codes directory. 2.\n\n 2. To use Rider 2021.2.2 (updated to the latest version), you need to install the following:\n    \n    * Rider\'s Unity plugin\n    * Install .net6\n    * NET SDK 6.0.101 is not fully supported in Rider", but it does not actually affect the compilation (2021.12.21)\n    * 2021.3.x fully supports .net6\n\n 3. master branch requires unity 2020.3 (C#8 syntax is used)\n\n 4. start Unity, menu File -> Open Project... -> Open Select the ET/Unity folder and click on the Select Folder button. 5.\n\n 5. Click on the Unity menu Assets -> Open C# Project to start vs\n\n 6. Run Tools->BuildCode on the Unity menu, this step will compile the client code\n\n 7. Open ET/Client-Server.sln compile with Rider (must compile all project, right click VS solution, compile all) The red reference error is reported here because the Unity library has not been compiled into the Unity/Temp/Debug directory, which is generally ignored, you must ensure that Unity is open, and then just compile the Client-Server directly.Unity.Mono will copy the Unity libraries it depends on into Unity/Temp/Debug. Unity.ModelView UnityHotfix.View will all depend on the libraries under Unity/Temp/Debug. If you still burst red, close vs or rider, open unity first, then Client-Server.sln, then Compile Client-Server\n\nTranslated with www.DeepL.com/Translator (free version)\n\n 1. export table tools, compile the command line into the Bin directory after completion, execute dotnet Tools.dll --AppType=ExcelExporter\n\n 2. export protocol tool, compile and enter Bin directory, execute dotnet Tools.dll --AppType=Proto2CS\n\n 3. start server: dotnet Server.dll --Process=1 --Console=1\n\n 4. Double-click the Init scene in the Scenes directory in Unity and click Play to run it.\n\n\n# Test state synchronization demo\n\n 1. If you want to modify the configuration, go to the Excel directory and modify the corresponding table, do step 6 of the running steps, and then re-run the Server.App project to start the server.\n\n 2. Unity->tools menu->Package Tools, select PC, check whether to package exe, click Start Package, and type a PC package in Release directory.\n\n 3. Run Unity Login Enter the lobby Enter the scene\n\n 4. Run the PC package, log in and enter the lobby\n\n 5. Click the right mouse button to move the character\n\n\n# Cautions.\n\nI. Error causes are.\n\n 1.  Chinese directory.\n 2.  low version of VS\n 3.  Rider does not have the relevant components installed\n 4.  not installed .net6\n 5.  not compile all projects on the server side\n 6.  Rider should be updated to the latest version\n 7.  Unity version is too low\n 8.  Win7 users, no special settings\n 9.  *If there is a dependency problem during the compilation process, it may be due to Unity - External Tools - Generate .csproj files for: When the\n     1. Registry packages\n     2. Build-in packages\n 10. *If the package is missing "StreamingAsset", you can create a new StreamingAsset folder under ET\\Unity\\Assets.',normalizedContent:'# run steps\n\n 1. visual studio user instructions.\n    \n    * versions.\n      * win10 and above users, use .net6, vs version, must use 2022 and above. note that vs 2019 does not support .net6 and cannot be used.\n      * win7 users, can not install vs 2022, need to use .net 5 and vs 2019, but note that additional settings are required to support et compilation.\n    * dependencies.\n      * the "game development with unity" extension needs to be installed.\n      * in "tools-options-tools for unity-general", you need to change the disable full project generation to false in the miscellaneous section, otherwise it will cause an error in your codes directory. 2.\n\n 2. to use rider 2021.2.2 (updated to the latest version), you need to install the following:\n    \n    * rider\'s unity plugin\n    * install .net6\n    * net sdk 6.0.101 is not fully supported in rider", but it does not actually affect the compilation (2021.12.21)\n    * 2021.3.x fully supports .net6\n\n 3. master branch requires unity 2020.3 (c#8 syntax is used)\n\n 4. start unity, menu file -> open project... -> open select the et/unity folder and click on the select folder button. 5.\n\n 5. click on the unity menu assets -> open c# project to start vs\n\n 6. run tools->buildcode on the unity menu, this step will compile the client code\n\n 7. open et/client-server.sln compile with rider (must compile all project, right click vs solution, compile all) the red reference error is reported here because the unity library has not been compiled into the unity/temp/debug directory, which is generally ignored, you must ensure that unity is open, and then just compile the client-server directly.unity.mono will copy the unity libraries it depends on into unity/temp/debug. unity.modelview unityhotfix.view will all depend on the libraries under unity/temp/debug. if you still burst red, close vs or rider, open unity first, then client-server.sln, then compile client-server\n\ntranslated with www.deepl.com/translator (free version)\n\n 1. export table tools, compile the command line into the bin directory after completion, execute dotnet tools.dll --apptype=excelexporter\n\n 2. export protocol tool, compile and enter bin directory, execute dotnet tools.dll --apptype=proto2cs\n\n 3. start server: dotnet server.dll --process=1 --console=1\n\n 4. double-click the init scene in the scenes directory in unity and click play to run it.\n\n\n# test state synchronization demo\n\n 1. if you want to modify the configuration, go to the excel directory and modify the corresponding table, do step 6 of the running steps, and then re-run the server.app project to start the server.\n\n 2. unity->tools menu->package tools, select pc, check whether to package exe, click start package, and type a pc package in release directory.\n\n 3. run unity login enter the lobby enter the scene\n\n 4. run the pc package, log in and enter the lobby\n\n 5. click the right mouse button to move the character\n\n\n# cautions.\n\ni. error causes are.\n\n 1.  chinese directory.\n 2.  low version of vs\n 3.  rider does not have the relevant components installed\n 4.  not installed .net6\n 5.  not compile all projects on the server side\n 6.  rider should be updated to the latest version\n 7.  unity version is too low\n 8.  win7 users, no special settings\n 9.  *if there is a dependency problem during the compilation process, it may be due to unity - external tools - generate .csproj files for: when the\n     1. registry packages\n     2. build-in packages\n 10. *if the package is missing "streamingasset", you can create a new streamingasset folder under et\\unity\\assets.',charsets:{},lastUpdated:"2022/07/25, 23:10:19",lastUpdatedTimestamp:1658761819e3},{title:"Why use .net core",frontmatter:{title:"Why use .net core",date:"2022-05-31T19:10:27.000Z",permalink:"/pages/f9f601/"},regularPath:"/02.Guide/01.ETBook_English/12.1.2Why%20use%20.net%20core.html",relativePath:"02.Guide/01.ETBook_English/12.1.2Why use .net core.md",key:"v-640dd7dc",path:"/pages/f9f601/",headers:[{level:6,title:"1. Stability of the language (fatal)",slug:"_1-stability-of-the-language-fatal",normalizedTitle:"1. stability of the language (fatal)",charIndex:681},{level:6,title:"2. Runtime hot more (fatal)",slug:"_2-runtime-hot-more-fatal",normalizedTitle:"2. runtime hot more (fatal)",charIndex:885},{level:6,title:"3. Availability of concurrent process support (5 stars importance)",slug:"_3-availability-of-concurrent-process-support-5-stars-importance",normalizedTitle:"3. availability of concurrent process support (5 stars importance)",charIndex:1186},{level:6,title:"4. Compilation speed (5 stars in importance)",slug:"_4-compilation-speed-5-stars-in-importance",normalizedTitle:"4. compilation speed (5 stars in importance)",charIndex:1602},{level:6,title:"5. Cross-platform (4 stars)",slug:"_5-cross-platform-4-stars",normalizedTitle:"5. cross-platform (4 stars)",charIndex:1799},{level:6,title:"6. Readability, refactorability (3 stars)",slug:"_6-readability-refactorability-3-stars",normalizedTitle:"6. readability, refactorability (3 stars)",charIndex:2133},{level:6,title:"7. Whether the library is complete, whether the ecology is perfect (3 stars)",slug:"_7-whether-the-library-is-complete-whether-the-ecology-is-perfect-3-stars",normalizedTitle:"7. whether the library is complete, whether the ecology is perfect (3 stars)",charIndex:2258},{level:6,title:"8. Unified language with the client (3 stars)",slug:"_8-unified-language-with-the-client-3-stars",normalizedTitle:"8. unified language with the client (3 stars)",charIndex:2419},{level:6,title:"9. IDE support (3 stars)",slug:"_9-ide-support-3-stars",normalizedTitle:"9. ide support (3 stars)",charIndex:2743},{level:6,title:"10. Language performance (1 star)",slug:"_10-language-performance-1-star",normalizedTitle:"10. language performance (1 star)",charIndex:2886}],headersStr:"1. Stability of the language (fatal) 2. Runtime hot more (fatal) 3. Availability of concurrent process support (5 stars importance) 4. Compilation speed (5 stars in importance) 5. Cross-platform (4 stars) 6. Readability, refactorability (3 stars) 7. Whether the library is complete, whether the ecology is perfect (3 stars) 8. Unified language with the client (3 stars) 9. IDE support (3 stars) 10. Language performance (1 star)",content:"# Why use C# .net core for server-side?\n\nGame server side from the early single service to distributed, the development is more and more complex, the stability, development efficiency requirements are more and more high. The choice of development language has also gradually changed, from C to C++ to C++ + PYTHON or C++ + LUA, and now many companies are using erlang, go, java, c#. At present, it is a blossoming situation.\n\nBut if you were to redo an online game server, without considering the compatibility with the company or what is already there, how would you choose? I thought carefully about this issue, there are probably several aspects of this need to consider: 1.\n\n# 1. Stability of the language (fatal)\n\nThe game server is characterized by high load and low latency. So generally the server-side process is with state, once hung means data loss, this is intolerable.\n\n# 2. Runtime hot more (fatal)\n\nThe game server logic is extremely complex and prone to bugs, but it can't be stopped often, so hot shifts to fix bugs are necessary. If a bug occurs, the developer can write code immediately and then fix it with a hot-change, which is not felt by online users at all.\n\n# 3. Availability of concurrent process support (5 stars importance)\n\nWith distributed server architecture, there is bound to be a lot of interaction between processes. Since it is difficult to split the game logic into multiple threads, it is generally single-threaded logic. If there is no concurrent support, a large number of callbacks are bound to be generated and code maintenance will become very difficult.\n\n# 4. Compilation speed (5 stars in importance)\n\nIn c++ development, 30% of the time is wasted on compilation. If compilation is fast or not needed, it will greatly improve development efficiency.\n\n# 5. Cross-platform (4 stars)\n\nGenerally the game server is set up on linux. But the usual development, the use of windows will be more convenient, if cross-platform, development and testing efficiency will be greatly improved, and do not need to get a separate development machine, the local computer can meet the usual development\n\n# 6. Readability, refactorability (3 stars)\n\nThe code can be reconstructed to greatly reduce the difficulty of writing code\n\n# 7. Whether the library is complete, whether the ecology is perfect (3 stars)\n\nLibrary is complete, ecological good, you need to build their own wheel is less\n\n# 8. Unified language with the client (3 stars)\n\nClient-server shared language, the advantages are very obvious, many codes can be reused, logic programmers no longer need to distinguish between the front and back end, both ends can write, a person can complete a function, greatly reducing the time cost of communication.\n\n# 9. IDE support (3 stars)\n\nCode hints, refactoring and other support, excellent IDE can improve the development efficiency by several times.\n\n# 10. Language performance (1 star)\n\nCurrently server performance is not too much of a problem, but good performance is better than poor performance.\n\nLANGUAGES                  C#                  C/C++               JAVA            GO                  LUA              PYTHON           ERLANG\nStability                  Stability           Easy to hang        Stability       Stability           Stability        Stability        Stability\nSupport                    Harder to support   Support             Not support     Support             Support          Support          Support\nCross-Platform             Support             Harder to Support   Support         Harder to Support   Support          Support          Support\nSupport                    Support             Support             Support         Support             Support          Support          Support\nCompilation speed          fast                slow                fast            fast                no compilation   no compilation   no compilation\nGood                       Fair                Good                Fair            Poor                Poor             Poor             \nGame Library and Ecology   Good                Good                Average         Average             Poor             Good             Average\nUnity                      Unity, UE4          Not available       Not available   Unity, UE4          UE4              Not available    Unity, UE4\nIDE Support                Good                Good                Average         Poor                Poor             Poor             \nLanguage performance       Good                Very good           Good            Good                Poor             Very poor        Poor\n\nAs you can see from the table. 1:\n\n 1. C/C++ has poor stability, slow compilation speed, and fatal flaws\n 2. Go does not support hot changes, does not support generics, poor reconfigurability, can not share code with the client, a fatal flaw\n 3. poor support for Java concurrency, unable to share code with the client\n 4. Lua has few libraries, poor performance, poor code readability and reconfigurability, cross-platform dependence on C/C++, troublesome to handle, and poor ide support\n 5. Python poor performance, poor code readability and reconfigurability, unable to share code with clients, poor ide support\n 6. Erlang performance is poor, functional style is not easy to get started, ide support is poor\n 7. C# .net core is very good in every convenience, but can't share code with UE4\n\nCurrently Unity is the hottest game engine, C# server with Unity is a perfect match, basically can not find defects.",normalizedContent:"# why use c# .net core for server-side?\n\ngame server side from the early single service to distributed, the development is more and more complex, the stability, development efficiency requirements are more and more high. the choice of development language has also gradually changed, from c to c++ to c++ + python or c++ + lua, and now many companies are using erlang, go, java, c#. at present, it is a blossoming situation.\n\nbut if you were to redo an online game server, without considering the compatibility with the company or what is already there, how would you choose? i thought carefully about this issue, there are probably several aspects of this need to consider: 1.\n\n# 1. stability of the language (fatal)\n\nthe game server is characterized by high load and low latency. so generally the server-side process is with state, once hung means data loss, this is intolerable.\n\n# 2. runtime hot more (fatal)\n\nthe game server logic is extremely complex and prone to bugs, but it can't be stopped often, so hot shifts to fix bugs are necessary. if a bug occurs, the developer can write code immediately and then fix it with a hot-change, which is not felt by online users at all.\n\n# 3. availability of concurrent process support (5 stars importance)\n\nwith distributed server architecture, there is bound to be a lot of interaction between processes. since it is difficult to split the game logic into multiple threads, it is generally single-threaded logic. if there is no concurrent support, a large number of callbacks are bound to be generated and code maintenance will become very difficult.\n\n# 4. compilation speed (5 stars in importance)\n\nin c++ development, 30% of the time is wasted on compilation. if compilation is fast or not needed, it will greatly improve development efficiency.\n\n# 5. cross-platform (4 stars)\n\ngenerally the game server is set up on linux. but the usual development, the use of windows will be more convenient, if cross-platform, development and testing efficiency will be greatly improved, and do not need to get a separate development machine, the local computer can meet the usual development\n\n# 6. readability, refactorability (3 stars)\n\nthe code can be reconstructed to greatly reduce the difficulty of writing code\n\n# 7. whether the library is complete, whether the ecology is perfect (3 stars)\n\nlibrary is complete, ecological good, you need to build their own wheel is less\n\n# 8. unified language with the client (3 stars)\n\nclient-server shared language, the advantages are very obvious, many codes can be reused, logic programmers no longer need to distinguish between the front and back end, both ends can write, a person can complete a function, greatly reducing the time cost of communication.\n\n# 9. ide support (3 stars)\n\ncode hints, refactoring and other support, excellent ide can improve the development efficiency by several times.\n\n# 10. language performance (1 star)\n\ncurrently server performance is not too much of a problem, but good performance is better than poor performance.\n\nlanguages                  c#                  c/c++               java            go                  lua              python           erlang\nstability                  stability           easy to hang        stability       stability           stability        stability        stability\nsupport                    harder to support   support             not support     support             support          support          support\ncross-platform             support             harder to support   support         harder to support   support          support          support\nsupport                    support             support             support         support             support          support          support\ncompilation speed          fast                slow                fast            fast                no compilation   no compilation   no compilation\ngood                       fair                good                fair            poor                poor             poor             \ngame library and ecology   good                good                average         average             poor             good             average\nunity                      unity, ue4          not available       not available   unity, ue4          ue4              not available    unity, ue4\nide support                good                good                average         poor                poor             poor             \nlanguage performance       good                very good           good            good                poor             very poor        poor\n\nas you can see from the table. 1:\n\n 1. c/c++ has poor stability, slow compilation speed, and fatal flaws\n 2. go does not support hot changes, does not support generics, poor reconfigurability, can not share code with the client, a fatal flaw\n 3. poor support for java concurrency, unable to share code with the client\n 4. lua has few libraries, poor performance, poor code readability and reconfigurability, cross-platform dependence on c/c++, troublesome to handle, and poor ide support\n 5. python poor performance, poor code readability and reconfigurability, unable to share code with clients, poor ide support\n 6. erlang performance is poor, functional style is not easy to get started, ide support is poor\n 7. c# .net core is very good in every convenience, but can't share code with ue4\n\ncurrently unity is the hottest game engine, c# server with unity is a perfect match, basically can not find defects.",charsets:{},lastUpdated:"2022/07/25, 23:10:19",lastUpdatedTimestamp:1658761819e3},{title:"CSharp Coroutine",frontmatter:{title:"CSharp Coroutine",date:"2022-05-31T19:10:27.000Z",permalink:"/pages/97d2cf/"},regularPath:"/02.Guide/01.ETBook_English/21.2.1CSharp%20Coroutine.html",relativePath:"02.Guide/01.ETBook_English/21.2.1CSharp Coroutine.md",key:"v-17cedb24",path:"/pages/97d2cf/",headersStr:null,content:'# What is a concurrent thread\n\nSpeaking of concurrency, let\'s first understand what is asynchronous. Asynchronous simply means that I want to initiate a call, but the called party (may be other threads, or may be IO) will take some time to produce the result, and I don\'t want the call to block the entire thread of the caller, so I pass a callback function to the called party, and the called party will call back this callback function after it finishes running to notify the caller to continue The callback function will notify the caller to continue execution. As an example:\nIn the following code, the main thread keeps looping, sleep 1 millisecond per loop, add one to the count, and print once every 10,000 times.\n\n        private static void Main()\n        {\n            int loopCount = 0;\n            while (true)\n            {\n                int temp = watcherValue;\n                \n                Thread.Sleep(1);\n                \n                ++loopCount;\n                if (loopCount % 10000 == 0)\n                {\n                    Console.WriteLine($"loop count: {loopCount}");\n                }\n            }\n        }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nAt this point I need to add a function, at the beginning of the program, I want to print the value of loopCount after 5 seconds. Seeing that after 5 seconds we can think of the Sleep method, which will block the thread for a certain amount of time and then continue execution. We obviously can\'t Sleep in the main thread because it would break the logic of printing once every 10000 counts.\n\n    // example2_1\n    class Program\n    {\n        private static int loopCount = 0;\n\n        private static void Main()\n        {\n            OneThreadSynchronizationContext _ = OneThreadSynchronizationContext.Instance;\n            \n            WaitTimeAsync(5000, WaitTimeFinishCallback);\n            \n            while (true)\n            {\n                OneThreadSynchronizationContext.Instance.Update();\n                \n                Thread.Sleep(1);\n                \n                ++loopCount;\n                if (loopCount % 10000 == 0)\n                {\n                    Console.WriteLine($"loop count: {loopCount}");\n                }\n            }\n        }\n\n        private static void WaitTimeAsync(int waitTime, Action action)\n        {\n            Thread thread = new Thread(()=>WaitTime(waitTime, action));\n            thread.Start();\n        }\n        \n        private static void WaitTimeFinishCallback()\n        {\n            Console.WriteLine($"WaitTimeAsync finsih loopCount value is: {loopCount}");\n        }\n\n        /// <summary>\n        /// Waiting in another thread\n        /// </summary>\n        private static void WaitTime(int waitTime, Action action)\n        {\n            Thread.Sleep(waitTime);\n            \n            // Throw the action back to the main thread for execution\n            OneThreadSynchronizationContext.Instance.Post((o)=>action(), null);\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\nWe have designed a WaitTimeAsync method here. WaitTimeAsync is actually a typical asynchronous method that initiates a call from the main thread, passes in a WaitTimeFinishCallback method as an argument, opens a thread, and after the thread Sleeps for a certain amount of time, throws the passed callback back to the main thread for execution. OneThreadSynchronizationContext is a cross-thread queue, any thread can throw delegates into it, the Update method of OneThreadSynchronizationContext is called in the main thread and will take out these delegates and put them into the main thread for execution. Why does the callback method need to be thrown back to the main thread for execution? Because the loopCount is read in the callback method, and the loopCount is also read and written in the main thread, so either add a lock or always ensure that it is only read and written in the main thread. It is a bad practice to add locks, and having locks all over the code makes it difficult to read and maintain, and it is easy to create multi-threaded bugs. this is a common technique in multi-threaded development to package the logic into a delegate and throw it back to another thread.\n\nWe may have a new requirement, after the execution of WaitTimeFinishCallback is finished, we want to wait for 3 seconds and print the loopCount again.\n\n        private static void WaitTimeAsync(int waitTime, Action action)\n        {\n            Thread thread = new Thread(()=>WaitTime(waitTime, action));\n            thread.Start();\n        }\n        private static void WaitTimeFinishCallback()\n        {\n            Console.WriteLine($"WaitTimeAsync finsih loopCount value is: {loopCount}");\n            WaitTimeAsync(3000, WaitTimeFinishCallback2);\n        }\n        \n        private static void WaitTimeFinishCallback2()\n        {\n            Console.WriteLine($"WaitTimeAsync finsih loopCount value is: {loopCount}");\n        }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nWe may also change the requirement at this point, we need to print the loopCount 5 seconds after the program starts, then 4 seconds after, then 3 seconds after, that is, insert another 3 seconds wait in the middle of the above logic.\n\n        private static void WaitTimeAsync(int waitTime, Action action)\n        {\n            Thread thread = new Thread(()=>WaitTime(waitTime, action));\n            thread.Start();\n        }\n        \n        private static void WaitTimeFinishCallback()\n        {\n            Console.WriteLine($"WaitTimeAsync finsih loopCount value is: {loopCount}");\n            WaitTimeAsync(4000, WaitTimeFinishCallback3);\n        }\n        \n        private static void WaitTimeFinishCallback3()\n        {\n            Console.WriteLine($"WaitTimeAsync finsih loopCount value is: {loopCount}");\n            WaitTimeAsync(3000, WaitTimeFinishCallback2);\n        }\n        \n        private static void WaitTimeFinishCallback2()\n        {\n            Console.WriteLine($"WaitTimeAsync finsih loopCount value is: {loopCount}");\n        }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\nThis inserts a piece of code in the middle, which seems very cumbersome. Here you can answer what is a concurrent process, in fact this string of callbacks is a concurrent process.',normalizedContent:'# what is a concurrent thread\n\nspeaking of concurrency, let\'s first understand what is asynchronous. asynchronous simply means that i want to initiate a call, but the called party (may be other threads, or may be io) will take some time to produce the result, and i don\'t want the call to block the entire thread of the caller, so i pass a callback function to the called party, and the called party will call back this callback function after it finishes running to notify the caller to continue the callback function will notify the caller to continue execution. as an example:\nin the following code, the main thread keeps looping, sleep 1 millisecond per loop, add one to the count, and print once every 10,000 times.\n\n        private static void main()\n        {\n            int loopcount = 0;\n            while (true)\n            {\n                int temp = watchervalue;\n                \n                thread.sleep(1);\n                \n                ++loopcount;\n                if (loopcount % 10000 == 0)\n                {\n                    console.writeline($"loop count: {loopcount}");\n                }\n            }\n        }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nat this point i need to add a function, at the beginning of the program, i want to print the value of loopcount after 5 seconds. seeing that after 5 seconds we can think of the sleep method, which will block the thread for a certain amount of time and then continue execution. we obviously can\'t sleep in the main thread because it would break the logic of printing once every 10000 counts.\n\n    // example2_1\n    class program\n    {\n        private static int loopcount = 0;\n\n        private static void main()\n        {\n            onethreadsynchronizationcontext _ = onethreadsynchronizationcontext.instance;\n            \n            waittimeasync(5000, waittimefinishcallback);\n            \n            while (true)\n            {\n                onethreadsynchronizationcontext.instance.update();\n                \n                thread.sleep(1);\n                \n                ++loopcount;\n                if (loopcount % 10000 == 0)\n                {\n                    console.writeline($"loop count: {loopcount}");\n                }\n            }\n        }\n\n        private static void waittimeasync(int waittime, action action)\n        {\n            thread thread = new thread(()=>waittime(waittime, action));\n            thread.start();\n        }\n        \n        private static void waittimefinishcallback()\n        {\n            console.writeline($"waittimeasync finsih loopcount value is: {loopcount}");\n        }\n\n        /// <summary>\n        /// waiting in another thread\n        /// </summary>\n        private static void waittime(int waittime, action action)\n        {\n            thread.sleep(waittime);\n            \n            // throw the action back to the main thread for execution\n            onethreadsynchronizationcontext.instance.post((o)=>action(), null);\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\nwe have designed a waittimeasync method here. waittimeasync is actually a typical asynchronous method that initiates a call from the main thread, passes in a waittimefinishcallback method as an argument, opens a thread, and after the thread sleeps for a certain amount of time, throws the passed callback back to the main thread for execution. onethreadsynchronizationcontext is a cross-thread queue, any thread can throw delegates into it, the update method of onethreadsynchronizationcontext is called in the main thread and will take out these delegates and put them into the main thread for execution. why does the callback method need to be thrown back to the main thread for execution? because the loopcount is read in the callback method, and the loopcount is also read and written in the main thread, so either add a lock or always ensure that it is only read and written in the main thread. it is a bad practice to add locks, and having locks all over the code makes it difficult to read and maintain, and it is easy to create multi-threaded bugs. this is a common technique in multi-threaded development to package the logic into a delegate and throw it back to another thread.\n\nwe may have a new requirement, after the execution of waittimefinishcallback is finished, we want to wait for 3 seconds and print the loopcount again.\n\n        private static void waittimeasync(int waittime, action action)\n        {\n            thread thread = new thread(()=>waittime(waittime, action));\n            thread.start();\n        }\n        private static void waittimefinishcallback()\n        {\n            console.writeline($"waittimeasync finsih loopcount value is: {loopcount}");\n            waittimeasync(3000, waittimefinishcallback2);\n        }\n        \n        private static void waittimefinishcallback2()\n        {\n            console.writeline($"waittimeasync finsih loopcount value is: {loopcount}");\n        }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nwe may also change the requirement at this point, we need to print the loopcount 5 seconds after the program starts, then 4 seconds after, then 3 seconds after, that is, insert another 3 seconds wait in the middle of the above logic.\n\n        private static void waittimeasync(int waittime, action action)\n        {\n            thread thread = new thread(()=>waittime(waittime, action));\n            thread.start();\n        }\n        \n        private static void waittimefinishcallback()\n        {\n            console.writeline($"waittimeasync finsih loopcount value is: {loopcount}");\n            waittimeasync(4000, waittimefinishcallback3);\n        }\n        \n        private static void waittimefinishcallback3()\n        {\n            console.writeline($"waittimeasync finsih loopcount value is: {loopcount}");\n            waittimeasync(3000, waittimefinishcallback2);\n        }\n        \n        private static void waittimefinishcallback2()\n        {\n            console.writeline($"waittimeasync finsih loopcount value is: {loopcount}");\n        }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\nthis inserts a piece of code in the middle, which seems very cumbersome. here you can answer what is a concurrent process, in fact this string of callbacks is a concurrent process.',charsets:{},lastUpdated:"2022/07/25, 23:10:19",lastUpdatedTimestamp:1658761819e3},{title:"Better Coroutine",frontmatter:{title:"Better Coroutine",date:"2022-05-31T19:10:27.000Z",permalink:"/pages/e03bce/"},regularPath:"/02.Guide/01.ETBook_English/22.2.2Better%20Coroutine.html",relativePath:"02.Guide/01.ETBook_English/22.2.2Better Coroutine.md",key:"v-58f5998e",path:"/pages/e03bce/",headersStr:null,content:'# Better Coroutine\n\nThe above article talks about how a string of callbacks is a concurrent process, and obviously writing code this way, adding logic and inserting logic is very error prone. We need to use asynchronous syntax to change the form of this asynchronous callback to a synchronous form, fortunately C# has been designed for us, see the code\n\n    // example2_2\n    class Program\n    {\n        private static int loopCount = 0;\n        \n        static void Main(string[] args)\n        {\n            OneThreadSynchronizationContext _ = OneThreadSynchronizationContext.Instance;\n\n            Console.WriteLine($"Main Thread: {Thread.CurrentThread.ManagedThreadId}");\n            \n            Crontine();\n            \n            while (true)\n            {\n                OneThreadSynchronizationContext.Instance.Update();\n                \n                Thread.Sleep(1);\n                \n                ++loopCount;\n                if (loopCount % 10000 == 0)\n                {\n                    Console.WriteLine($"loop count: {loopCount}");\n                }\n            }\n        }\n\n        private static async void Crontine()\n        {\n            await WaitTimeAsync(5000);\n            Console.WriteLine($"Current thread: {Thread.CurrentThread.ManagedThreadId}, WaitTimeAsync finsih loopCount\'s value is: {loopCount}");\n            await WaitTimeAsync(4000);\n            Console.WriteLine($"Current Thread: {Thread.CurrentThread.ManagedThreadId}, WaitTimeAsync finsih The value of loopCount is: {loopCount}");\n            await WaitTimeAsync(3000);\n            Console.WriteLine($"Current Thread: {Thread.CurrentThread.ManagedThreadId}, WaitTimeAsync finsih The value of loopCount is: {loopCount}");\n        }\n        \n        private static Task WaitTimeAsync(int waitTime)\n        {\n            TaskCompletionSource<bool> tcs = new TaskCompletionSource<bool>();\n            Thread thread = new Thread(()=>WaitTime(waitTime, tcs));\n            thread.Start();\n            return tcs.Task;\n        }\n        \n        /// <summary>\n        /// Waiting in another thread\n        /// </summary>\n        private static void WaitTime(int waitTime, TaskCompletionSource<bool> tcs)\n        {\n            Thread.Sleep(waitTime);\n            \n            // throw tcs back to the main thread for execution\n            OneThreadSynchronizationContext.Instance.Post(o=>tcs.SetResult(true), null);\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n\n\nIn this code, in the WaitTimeAsync method, we use the TaskCompletionSource class instead of the previously passed Action parameter, and the WaitTimeAsync method returns a Task type result. waitTime we replace action() with tcs. SetResult(true), and the WaitTimeAsync method uses the await keyword in front of it, so that the sequence of callbacks can be changed to a synchronized form. This makes the code look very simple and much easier to develop.\n\nHere is another trick, we found that WaitTime needs to throw tcs.SetResult back to the main thread for execution, Microsoft gives us a simple way to set up the synchronization context in the main thread by referring to example2_2_2\n\n// example2_2_2\nSynchronizationContext.SetSynchronizationContext(OneThreadSynchronizationContext.Instance);\n\n\n1\n2\n\n\nSetResult(true) will be called directly in WaitTime, the callback will be automatically thrown to the synchronization context, and the synchronization context we can take out in the main thread to execute the callback, so automatically able to complete the operation back to the main thread\n\n        private static void WaitTime(int waitTime, TaskCompletionSource<bool> tcs)\n        {\n            Thread.Sleep(waitTime);\n\n            tcs.SetResult(true);\n        }\n\n\n1\n2\n3\n4\n5\n6\n\n\nIf you do not set the synchronization context, you will find that the printout of the current thread is not the main thread, which is also the use of many third-party libraries and . In fact, I think this design is not necessary, to the library developers to achieve better, especially in the game development, logic is all single-threaded, callback every time you go through the synchronization context is redundant, so the ET framework provides the implementation of ETTask does not use the synchronization context, the code is more concise and efficient, which will be discussed later.',normalizedContent:'# better coroutine\n\nthe above article talks about how a string of callbacks is a concurrent process, and obviously writing code this way, adding logic and inserting logic is very error prone. we need to use asynchronous syntax to change the form of this asynchronous callback to a synchronous form, fortunately c# has been designed for us, see the code\n\n    // example2_2\n    class program\n    {\n        private static int loopcount = 0;\n        \n        static void main(string[] args)\n        {\n            onethreadsynchronizationcontext _ = onethreadsynchronizationcontext.instance;\n\n            console.writeline($"main thread: {thread.currentthread.managedthreadid}");\n            \n            crontine();\n            \n            while (true)\n            {\n                onethreadsynchronizationcontext.instance.update();\n                \n                thread.sleep(1);\n                \n                ++loopcount;\n                if (loopcount % 10000 == 0)\n                {\n                    console.writeline($"loop count: {loopcount}");\n                }\n            }\n        }\n\n        private static async void crontine()\n        {\n            await waittimeasync(5000);\n            console.writeline($"current thread: {thread.currentthread.managedthreadid}, waittimeasync finsih loopcount\'s value is: {loopcount}");\n            await waittimeasync(4000);\n            console.writeline($"current thread: {thread.currentthread.managedthreadid}, waittimeasync finsih the value of loopcount is: {loopcount}");\n            await waittimeasync(3000);\n            console.writeline($"current thread: {thread.currentthread.managedthreadid}, waittimeasync finsih the value of loopcount is: {loopcount}");\n        }\n        \n        private static task waittimeasync(int waittime)\n        {\n            taskcompletionsource<bool> tcs = new taskcompletionsource<bool>();\n            thread thread = new thread(()=>waittime(waittime, tcs));\n            thread.start();\n            return tcs.task;\n        }\n        \n        /// <summary>\n        /// waiting in another thread\n        /// </summary>\n        private static void waittime(int waittime, taskcompletionsource<bool> tcs)\n        {\n            thread.sleep(waittime);\n            \n            // throw tcs back to the main thread for execution\n            onethreadsynchronizationcontext.instance.post(o=>tcs.setresult(true), null);\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n\n\nin this code, in the waittimeasync method, we use the taskcompletionsource class instead of the previously passed action parameter, and the waittimeasync method returns a task type result. waittime we replace action() with tcs. setresult(true), and the waittimeasync method uses the await keyword in front of it, so that the sequence of callbacks can be changed to a synchronized form. this makes the code look very simple and much easier to develop.\n\nhere is another trick, we found that waittime needs to throw tcs.setresult back to the main thread for execution, microsoft gives us a simple way to set up the synchronization context in the main thread by referring to example2_2_2\n\n// example2_2_2\nsynchronizationcontext.setsynchronizationcontext(onethreadsynchronizationcontext.instance);\n\n\n1\n2\n\n\nsetresult(true) will be called directly in waittime, the callback will be automatically thrown to the synchronization context, and the synchronization context we can take out in the main thread to execute the callback, so automatically able to complete the operation back to the main thread\n\n        private static void waittime(int waittime, taskcompletionsource<bool> tcs)\n        {\n            thread.sleep(waittime);\n\n            tcs.setresult(true);\n        }\n\n\n1\n2\n3\n4\n5\n6\n\n\nif you do not set the synchronization context, you will find that the printout of the current thread is not the main thread, which is also the use of many third-party libraries and . in fact, i think this design is not necessary, to the library developers to achieve better, especially in the game development, logic is all single-threaded, callback every time you go through the synchronization context is redundant, so the et framework provides the implementation of ettask does not use the synchronization context, the code is more concise and efficient, which will be discussed later.',charsets:{},lastUpdated:"2022/07/25, 23:10:19",lastUpdatedTimestamp:1658761819e3},{title:"Single-threaded asynchronous",frontmatter:{title:"Single-threaded asynchronous",date:"2022-05-31T19:10:27.000Z",permalink:"/pages/735741/"},regularPath:"/02.Guide/01.ETBook_English/23.2.3Single-threaded%20asynchronous.html",relativePath:"02.Guide/01.ETBook_English/23.2.3Single-threaded asynchronous.md",key:"v-4ed835a8",path:"/pages/735741/",headersStr:null,content:'# Single-threaded asynchronous\n\nThe previous examples are multi-threaded implementations of asynchrony, but asynchrony is obviously not just multi-threaded. We used Sleep in the previous examples to achieve time waiting, each timer needs to use a thread, which will lead to frequent thread switching, this implementation is very inefficient, usually will not do so. General game logic will design a single-threaded timer, we do a simple implementation here, used to explain single-threaded asynchronous.\n\n    // example2_3\n    class Program\n    {\n        private static int loopCount = 0;\n\n        private static long time;\n        private static Action action;\n        \n        static void Main(string[] args)\n        {\n            Console.WriteLine($"Main thread: {Thread.CurrentThread.ManagedThreadId}");\n\n            Crontine();\n            \n            while (true)\n            {\n                Thread.Sleep(1);\n\n                CheckTimerOut();\n                \n                ++loopCount;\n                if (loopCount % 10000 == 0)\n                {\n                    Console.WriteLine($"loop count: {loopCount}");\n                }\n            }\n        }\n        \n        private static void Crontine()\n        {\n            WaitTimeAsync(5000, WaitTimeAsyncCallback1);\n        }\n\n        private static void WaitTimeAsyncCallback1()\n        {\n            Console.WriteLine($"Current thread: {Thread.CurrentThread.ManagedThreadId}, WaitTimeAsync finsih loopCount\'s value is: {loopCount}");\n            WaitTimeAsync(4000, WaitTimeAsyncCallback2);\n        }\n        \n        private static void WaitTimeAsyncCallback2()\n        {\n            Console.WriteLine($"Current thread: {Thread.CurrentThread.ManagedThreadId}, WaitTimeAsync finsih loopCount\'s value is: {loopCount}");\n            WaitTimeAsync(3000, WaitTimeAsyncCallback3);\n        }\n        \n        private static void WaitTimeAsyncCallback3()\n        {\n            Console.WriteLine($"Current thread: {Thread.CurrentThread.ManagedThreadId}, WaitTimeAsync finsih loopCount\'s value is: {loopCount}");\n        }\n\n        private static void CheckTimerOut()\n        {\n            if (time == 0)\n            {\n                return;\n            }\n            long nowTicks = DateTime.Now.Ticks / 10000;\n            if (time > nowTicks)\n            { return; }\n                return;\n            }\n\n            time = 0;\n            action.Invoke();\n        }\n        \n        private static void WaitTimeAsync(int waitTime, Action a)\n        {\n            Ticks / 10000 + waitTime;\n            action = a;\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n\n\nThis example also implements a simple timing method, WaitTimeAsync will be called to record the callback method and time, the main thread will call CheckTimerOut every frame, CheckTimerOut inside to determine whether the timer is expired, expired then callback method is called. The whole logic is done in the main thread, also asynchronously. So asynchronous is not multi-threaded, single-threaded can also be asynchronous. The above example can be changed to await as well.\n\n    // example2_3_2\n    class Program\n    {\n        private static int loopCount = 0;\n\n        private static long time;\n        private static TaskCompletionSource<bool> tcs;\n        \n        static void Main(string[] args)\n        {\n            Console.WriteLine($"Main thread: {Thread.CurrentThread.ManagedThreadId}");\n\n            Crontine();\n            \n            while (true)\n            {\n                Thread.Sleep(1);\n\n                CheckTimerOut();\n                \n                ++loopCount;\n                if (loopCount % 10000 == 0)\n                {\n                    Console.WriteLine($"loop count: {loopCount}");\n                }\n            }\n        }\n        \n        private static async void Crontine()\n        {\n            await WaitTimeAsync(5000);\n            Console.WriteLine($"Current thread: {Thread.CurrentThread.ManagedThreadId}, WaitTimeAsync finsih loopCount\'s value is: {loopCount}");\n            await WaitTimeAsync(4000);\n            Console.WriteLine($"Current Thread: {Thread.CurrentThread.ManagedThreadId}, WaitTimeAsync finsih The value of loopCount is: {loopCount}");\n            await WaitTimeAsync(3000);\n            Console.WriteLine($"Current Thread: {Thread.CurrentThread.ManagedThreadId}, WaitTimeAsync finsih The value of loopCount is: {loopCount}");\n        }\n\n        private static void CheckTimerOut()\n        {\n            if (time == 0)\n            {\n                return;\n            }\n            long nowTicks = DateTime.Now.Ticks / 10000;\n            if (time > nowTicks)\n            { return; }\n                return;\n            }\n\n            time = 0;\n            tcs.SetResult(true);\n        }\n        \n        private static Task WaitTimeAsync(int waitTime)\n        {\n            TaskCompletionSource<bool> t = new TaskCompletionSource<bool>();\n            Time = DateTime.Now.Ticks / 10000 + waitTime;\n            tcs = t;\n            return t.Task;\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n\n\nThe above example all calls are done in the main thread and use await, so await does not open multithreading, await specific use of multithreading depends entirely on the specific implementation',normalizedContent:'# single-threaded asynchronous\n\nthe previous examples are multi-threaded implementations of asynchrony, but asynchrony is obviously not just multi-threaded. we used sleep in the previous examples to achieve time waiting, each timer needs to use a thread, which will lead to frequent thread switching, this implementation is very inefficient, usually will not do so. general game logic will design a single-threaded timer, we do a simple implementation here, used to explain single-threaded asynchronous.\n\n    // example2_3\n    class program\n    {\n        private static int loopcount = 0;\n\n        private static long time;\n        private static action action;\n        \n        static void main(string[] args)\n        {\n            console.writeline($"main thread: {thread.currentthread.managedthreadid}");\n\n            crontine();\n            \n            while (true)\n            {\n                thread.sleep(1);\n\n                checktimerout();\n                \n                ++loopcount;\n                if (loopcount % 10000 == 0)\n                {\n                    console.writeline($"loop count: {loopcount}");\n                }\n            }\n        }\n        \n        private static void crontine()\n        {\n            waittimeasync(5000, waittimeasynccallback1);\n        }\n\n        private static void waittimeasynccallback1()\n        {\n            console.writeline($"current thread: {thread.currentthread.managedthreadid}, waittimeasync finsih loopcount\'s value is: {loopcount}");\n            waittimeasync(4000, waittimeasynccallback2);\n        }\n        \n        private static void waittimeasynccallback2()\n        {\n            console.writeline($"current thread: {thread.currentthread.managedthreadid}, waittimeasync finsih loopcount\'s value is: {loopcount}");\n            waittimeasync(3000, waittimeasynccallback3);\n        }\n        \n        private static void waittimeasynccallback3()\n        {\n            console.writeline($"current thread: {thread.currentthread.managedthreadid}, waittimeasync finsih loopcount\'s value is: {loopcount}");\n        }\n\n        private static void checktimerout()\n        {\n            if (time == 0)\n            {\n                return;\n            }\n            long nowticks = datetime.now.ticks / 10000;\n            if (time > nowticks)\n            { return; }\n                return;\n            }\n\n            time = 0;\n            action.invoke();\n        }\n        \n        private static void waittimeasync(int waittime, action a)\n        {\n            ticks / 10000 + waittime;\n            action = a;\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n\n\nthis example also implements a simple timing method, waittimeasync will be called to record the callback method and time, the main thread will call checktimerout every frame, checktimerout inside to determine whether the timer is expired, expired then callback method is called. the whole logic is done in the main thread, also asynchronously. so asynchronous is not multi-threaded, single-threaded can also be asynchronous. the above example can be changed to await as well.\n\n    // example2_3_2\n    class program\n    {\n        private static int loopcount = 0;\n\n        private static long time;\n        private static taskcompletionsource<bool> tcs;\n        \n        static void main(string[] args)\n        {\n            console.writeline($"main thread: {thread.currentthread.managedthreadid}");\n\n            crontine();\n            \n            while (true)\n            {\n                thread.sleep(1);\n\n                checktimerout();\n                \n                ++loopcount;\n                if (loopcount % 10000 == 0)\n                {\n                    console.writeline($"loop count: {loopcount}");\n                }\n            }\n        }\n        \n        private static async void crontine()\n        {\n            await waittimeasync(5000);\n            console.writeline($"current thread: {thread.currentthread.managedthreadid}, waittimeasync finsih loopcount\'s value is: {loopcount}");\n            await waittimeasync(4000);\n            console.writeline($"current thread: {thread.currentthread.managedthreadid}, waittimeasync finsih the value of loopcount is: {loopcount}");\n            await waittimeasync(3000);\n            console.writeline($"current thread: {thread.currentthread.managedthreadid}, waittimeasync finsih the value of loopcount is: {loopcount}");\n        }\n\n        private static void checktimerout()\n        {\n            if (time == 0)\n            {\n                return;\n            }\n            long nowticks = datetime.now.ticks / 10000;\n            if (time > nowticks)\n            { return; }\n                return;\n            }\n\n            time = 0;\n            tcs.setresult(true);\n        }\n        \n        private static task waittimeasync(int waittime)\n        {\n            taskcompletionsource<bool> t = new taskcompletionsource<bool>();\n            time = datetime.now.ticks / 10000 + waittime;\n            tcs = t;\n            return t.task;\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n\n\nthe above example all calls are done in the main thread and use await, so await does not open multithreading, await specific use of multithreading depends entirely on the specific implementation',charsets:{},lastUpdated:"2022/07/25, 23:10:19",lastUpdatedTimestamp:1658761819e3},{title:"The powerful MongoBson library",frontmatter:{title:"The powerful MongoBson library",date:"2022-05-31T19:10:27.000Z",permalink:"/pages/947d76/"},regularPath:"/02.Guide/01.ETBook_English/32.3.2The%20powerful%20MongoBson%20library.html",relativePath:"02.Guide/01.ETBook_English/32.3.2The powerful MongoBson library.md",key:"v-3bf5446e",path:"/pages/947d76/",headers:[{level:3,title:"1. Support serialization deserialization into json or bson",slug:"_1-support-serialization-deserialization-into-json-or-bson",normalizedTitle:"1. support serialization deserialization into json or bson",charIndex:2566},{level:3,title:"2. Some fields can be ignored",slug:"_2-some-fields-can-be-ignored",normalizedTitle:"2. some fields can be ignored",charIndex:4256},{level:3,title:"3. Support for default values and taking aliases",slug:"_3-support-for-default-values-and-taking-aliases",normalizedTitle:"3. support for default values and taking aliases",charIndex:4733},{level:3,title:"4. Upgrade version support",slug:"_4-upgrade-version-support",normalizedTitle:"4. upgrade version support",charIndex:5395},{level:3,title:"5. Support for complex inheritance structures",slug:"_5-support-for-complex-inheritance-structures",normalizedTitle:"5. support for complex inheritance structures",charIndex:5967},{level:3,title:"6. ISupportInitialize interface",slug:"_6-isupportinitialize-interface",normalizedTitle:"6. isupportinitialize interface",charIndex:7499}],headersStr:"1. Support serialization deserialization into json or bson 2. Some fields can be ignored 3. Support for default values and taking aliases 4. Upgrade version support 5. Support for complex inheritance structures 6. ISupportInitialize interface",content:'# The powerful MongoBson library\n\nBack-end development, statistics about these scenarios need to use serialization: 1.\n\n 1. object clone by serialization deserialization\n 2. server-side database storage data, binary\n 3. distributed server-side, multi-process messages, binary\n 4. back-end logs, text format\n 5. various server-side configuration files, text format\n\nThere are very, very many C# serialization libraries, protobuf, json and so on. But these serialization libraries should not be readable and small for all scenarios. protobuf does not support complex object structures (cannot use inheritance) and is suitable for messages, but not for database storage and log formats. json is suitable for log formats, but is too big for network messages and data storage. We certainly want a library that can satisfy all the above scenarios for the following reasons.\n\n 1. you think about one day your configuration file needs to be saved in the database, you do not need to do the format conversion, the back-end directly to the configuration message sent by the front-end to save to the database, which can not reduce very many errors?\n 2. one day some server-side configuration files do not use the file format, need to be placed in the database, again, only a few lines of code to complete the migration.\n 3. one day the back-end server crash, you need to scan the logs for data recovery, the logs for deserialization into C# objects, one by one for processing, and then into objects saved to the database is complete.\n 4. objects saved in the database, you can directly see the text content, you can do a variety of SQL-like operations\n 5. Imagine a scenario where a configuration text object, deserialized into memory, sent via network messages, and stored in the database. The whole process is done in one go.\n\nSimply put, it reduces various data conversions, reduces code, improves development efficiency, and improves maintainability. MongoDB library can serialize both text and BSON binary format, and MongoDB itself is a very much used database in the game. Its support features are as follows.\n\n 1. support complex inheritance structure\n 2. support for ignoring certain fields serialization\n 3. support field default values\n 4. structure with extra fields can still be deserialized, which is very useful for multi-version protocols\n 5. support for ISupportInitialize interface, this is a godsend when deserialization\n 6. support for text json and binary bson serialization\n 7. MongoDB database support\n\nA brief introduction to the mongo bson library\n\n\n# 1. Support serialization deserialization into json or bson\n\n    public sealed class Player\n    {\n        public long Id;\n\n        public string Account { get; private set; }\n\n        public long UnitId { get; set; }\n    }\n\n    Player player1 = new Player() { Id = 1 };\n    string json = player1.ToJson();\n    Console.WriteLine($"player1 to json: {json}");\n    Console.WriteLine($"player to bson: {player.ToBson().ToHex()}");\n    // output:\n    // player to json: { "_id" : NumberLong(1), "C" : [], "Account" : null, "UnitId" : NumberLong(0) }\n    // player to bson: B000000125F69640001000000000000000A4163636F756E740012556E69744964000000000000000000000000\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\nNote that mongo\'s json is a bit different from the standard json, if you want to use the standard json, you can pass in a JsonWriterSettings object and restrict the use of JsonOutputMode.Strict mode\n\n    // use standard json\n    Player player2 = new Player() { Id = 1 };\n    Console.WriteLine($"player to json: {player2.ToJson(new JsonWriterSettings() {OutputMode = JsonOutputMode.Strict})}");\n    // player to json: { "_id" : 1, "C" : [], "Account" : null, "UnitId" : 0 }\n\n\n1\n2\n3\n4\n\n\nDeserialize json:\n\n            // deserialize json\n        Player player11 = BsonSerializer.Deserialize<Player>(json);\n        Console.WriteLine($"player11 to json: {player11.ToJson()}");\n\n\n1\n2\n3\n\n\nDeserialize bson:\n\n    // deserialize bson\n    using (MemoryStream memoryStream = new MemoryStream(bson))\n    {\n        Player player12 = (Player) BsonSerializer.Deserialize(memoryStream, typeof (Player));\n        Console.WriteLine($"player12 to json: {player12.ToJson()}");\n    }\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 2. Some fields can be ignored\n\n[BsonIgnore] This tag is used to disable field serialization.\n\n\tpublic sealed class Player\n\t{\n        public long Id;\n\n\t\t[BsonIgnore]\n\t\tpublic string Account { get; private set; }\n\t\t\n\t\tpublic long UnitId { get; set; }\n    }\n\n    Player player = new Player() { Id = 2, UnitId = 3, Account = "panda"};\n\tConsole.WriteLine($"player to json: {player.ToJson()}");\n    // player to json: { "_id" : 2, "UnitId" : 3 }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 3. Support for default values and taking aliases\n\nThe [BsonElement] field with this tag will serialize even private fields (only public fields are serialized by default), and the tag can take a string parameter to assign an alias to the field serialization.\n\n\tpublic sealed class Player\n\t{\n        public long Id;\n\n\t\tpublic string Account { get; private set; }\n\n\t\t[BsonElement("UId")]\n\t\tpublic long UnitId { get; set; }\n    }\n    Player player = new Player() { Id = 2, UnitId = 3, Account = "panda"};\n\tConsole.WriteLine($"player to json: {player.ToJson()}");\n    // player to json: { "_id" : 2, "Account" : "panda", "UId" : 3 }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 4. Upgrade version support\n\n[BsonIgnoreExtraElements] This tag is used on top of class, used to ignore extra fields when deserializing, general version compatibility needs to be considered, low version of the protocol needs to be able to deserialize otherwise the new version adds fields, the old version structure deserialization will be wrong\n\n\t[BsonIgnoreExtraElements]\n\tpublic sealed class Player\n\tpublic\n        public long Id;\n\n\t\tpublic string Account { get; private set; }\n\n\t\t[BsonElement("UId")\n\t\tpublic long UnitId { get; set; }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 5. Support for complex inheritance structures\n\nThe power of the mongo bson library is that it fully supports serialization deserialization inheritance structures. Note that inheritance deserialization requires registration of all parent classes, and there are two ways to do this. a. You can declare the inherited subclasses on top of the parent class using the [BsonKnownTypes] tag, so that mongo will automatically register them, e.g.:\n\n    [BsonKnownTypes(typeof(Entity))]\n    public class Component\n    {\n    }\n    [BsonKnownTypes(typeof(Player))]\n    public class Entity: Component\n    {\n    }\n    public sealed class Player: Entity\n    {\n        public long Id;\n        \n        public string Account { get; set; }\n\t\t\n        public long UnitId { get; set; }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nThis is flawed because the framework doesn\'t know what subclasses a class will have, and this is invasive to the framework code, and we want to uncouple this . You can scan the assembly for the types of all subclass parents and register them with the mongo driver\n\n\t\t\tType[] types = typeof(Game).Assembly.GetTypes();\n\t\t\tforeach (Type type in types)\n\t\t\t{\n\t\t\t\tif (!type.IsSubclassOf(typeof(Component))))\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tBsonClassMap.LookupClassMap(type);\n\t\t\t}\n\n\t\t\tBsonSerializer.RegisterSerializer(new EnumSerializer<NumericType>(BsonType.String));\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nThis completely automates the registration and the user does not need to relate whether the class is registered or not.\n\n\n# 6. ISupportInitialize interface\n\nmongo bson deserialization supports an ISupportInitialize interface, ISupportInitialize has two methods\n\n    public interface ISupportInitialize\n    {\n        void BeginInit();\n        void EndInit();\n    }\n\n\n1\n2\n3\n4\n5\n\n\nBeginInit is called before deserialization and EndInit is called after deserialization. This interface is very useful now to perform some operations after deserialization. For example\n\n\t[BsonIgnoreExtraElements]\n\tpublic class InnerConfig: AConfigComponent\n\t{\n\t\t[BsonIgnore]\n\t\tpublic IPEndPoint IPEndPoint { get; private set; }\n\t\t\n\t\tpublic string Address { get; set; }\n\n\t\tpublic override void EndInit()\n\t\t{\n\t\t\tthis.IPEndPoint = NetworkHelper.ToIPEndPoint(this.Address);\n\t\t}\n\t}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nInnerConfig is the configuration of the process inner network address in ET. Since IPEndPoint is not very configurable, we can configure it as a string and then convert the string to IPEndPoint in EndInit when deserializing. I also added this call to the protobuf deserialization method, refer to ProtobufHelper.cs, ET\'s protobuf because to support ilruntime, so remove the map support, if we want a map how to do? Here I gave the generated code are done, the proto messages are changed to a partial class, so that we can extend the class themselves, for example.\n\nmessage UnitInfo\n{\n\tint64 UnitId = 1;\n\n\tfloat X = 2;\n\tfloat Y = 3;\n\tfloat Z = 4;\n}\n\n// protobuf\nmessage G2C_EnterMap // IResponse\n{\n\tint32 RpcId = 90;\n\tint32 Error = 91;\n\tstring Message = 92;\n\t// own unit id\n\tint64 UnitId = 1;\n\t// all the units\n\trepeated UnitInfo Units = 2;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\nThis network message has a repeated UnitInfo field, which is actually an array in protobuf, which is not very convenient to use, I want to convert it to a Dictionary<Int64, UnitInfo> field, we can do something like this\n\n    public partial class G2C_EnterMap: ISupportInitialize\n    {\n        public Dictionary<Int64, UnitInfo> unitsDict = new Dictionary<long, UnitInfo>();\n        \n        public void BeginInit()\n        {\n        }\n\n        public void EndInit()\n        {\n            foreach (var unit in this.Units)\n            {\n                this.unitsDict.Add(unit.UnitId, unit);\n            }\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nThe message is extended by such a piece of code, and after deserialization, it is automatically converted into a Dictionary.',normalizedContent:'# the powerful mongobson library\n\nback-end development, statistics about these scenarios need to use serialization: 1.\n\n 1. object clone by serialization deserialization\n 2. server-side database storage data, binary\n 3. distributed server-side, multi-process messages, binary\n 4. back-end logs, text format\n 5. various server-side configuration files, text format\n\nthere are very, very many c# serialization libraries, protobuf, json and so on. but these serialization libraries should not be readable and small for all scenarios. protobuf does not support complex object structures (cannot use inheritance) and is suitable for messages, but not for database storage and log formats. json is suitable for log formats, but is too big for network messages and data storage. we certainly want a library that can satisfy all the above scenarios for the following reasons.\n\n 1. you think about one day your configuration file needs to be saved in the database, you do not need to do the format conversion, the back-end directly to the configuration message sent by the front-end to save to the database, which can not reduce very many errors?\n 2. one day some server-side configuration files do not use the file format, need to be placed in the database, again, only a few lines of code to complete the migration.\n 3. one day the back-end server crash, you need to scan the logs for data recovery, the logs for deserialization into c# objects, one by one for processing, and then into objects saved to the database is complete.\n 4. objects saved in the database, you can directly see the text content, you can do a variety of sql-like operations\n 5. imagine a scenario where a configuration text object, deserialized into memory, sent via network messages, and stored in the database. the whole process is done in one go.\n\nsimply put, it reduces various data conversions, reduces code, improves development efficiency, and improves maintainability. mongodb library can serialize both text and bson binary format, and mongodb itself is a very much used database in the game. its support features are as follows.\n\n 1. support complex inheritance structure\n 2. support for ignoring certain fields serialization\n 3. support field default values\n 4. structure with extra fields can still be deserialized, which is very useful for multi-version protocols\n 5. support for isupportinitialize interface, this is a godsend when deserialization\n 6. support for text json and binary bson serialization\n 7. mongodb database support\n\na brief introduction to the mongo bson library\n\n\n# 1. support serialization deserialization into json or bson\n\n    public sealed class player\n    {\n        public long id;\n\n        public string account { get; private set; }\n\n        public long unitid { get; set; }\n    }\n\n    player player1 = new player() { id = 1 };\n    string json = player1.tojson();\n    console.writeline($"player1 to json: {json}");\n    console.writeline($"player to bson: {player.tobson().tohex()}");\n    // output:\n    // player to json: { "_id" : numberlong(1), "c" : [], "account" : null, "unitid" : numberlong(0) }\n    // player to bson: b000000125f69640001000000000000000a4163636f756e740012556e69744964000000000000000000000000\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\nnote that mongo\'s json is a bit different from the standard json, if you want to use the standard json, you can pass in a jsonwritersettings object and restrict the use of jsonoutputmode.strict mode\n\n    // use standard json\n    player player2 = new player() { id = 1 };\n    console.writeline($"player to json: {player2.tojson(new jsonwritersettings() {outputmode = jsonoutputmode.strict})}");\n    // player to json: { "_id" : 1, "c" : [], "account" : null, "unitid" : 0 }\n\n\n1\n2\n3\n4\n\n\ndeserialize json:\n\n            // deserialize json\n        player player11 = bsonserializer.deserialize<player>(json);\n        console.writeline($"player11 to json: {player11.tojson()}");\n\n\n1\n2\n3\n\n\ndeserialize bson:\n\n    // deserialize bson\n    using (memorystream memorystream = new memorystream(bson))\n    {\n        player player12 = (player) bsonserializer.deserialize(memorystream, typeof (player));\n        console.writeline($"player12 to json: {player12.tojson()}");\n    }\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 2. some fields can be ignored\n\n[bsonignore] this tag is used to disable field serialization.\n\n\tpublic sealed class player\n\t{\n        public long id;\n\n\t\t[bsonignore]\n\t\tpublic string account { get; private set; }\n\t\t\n\t\tpublic long unitid { get; set; }\n    }\n\n    player player = new player() { id = 2, unitid = 3, account = "panda"};\n\tconsole.writeline($"player to json: {player.tojson()}");\n    // player to json: { "_id" : 2, "unitid" : 3 }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 3. support for default values and taking aliases\n\nthe [bsonelement] field with this tag will serialize even private fields (only public fields are serialized by default), and the tag can take a string parameter to assign an alias to the field serialization.\n\n\tpublic sealed class player\n\t{\n        public long id;\n\n\t\tpublic string account { get; private set; }\n\n\t\t[bsonelement("uid")]\n\t\tpublic long unitid { get; set; }\n    }\n    player player = new player() { id = 2, unitid = 3, account = "panda"};\n\tconsole.writeline($"player to json: {player.tojson()}");\n    // player to json: { "_id" : 2, "account" : "panda", "uid" : 3 }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 4. upgrade version support\n\n[bsonignoreextraelements] this tag is used on top of class, used to ignore extra fields when deserializing, general version compatibility needs to be considered, low version of the protocol needs to be able to deserialize otherwise the new version adds fields, the old version structure deserialization will be wrong\n\n\t[bsonignoreextraelements]\n\tpublic sealed class player\n\tpublic\n        public long id;\n\n\t\tpublic string account { get; private set; }\n\n\t\t[bsonelement("uid")\n\t\tpublic long unitid { get; set; }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 5. support for complex inheritance structures\n\nthe power of the mongo bson library is that it fully supports serialization deserialization inheritance structures. note that inheritance deserialization requires registration of all parent classes, and there are two ways to do this. a. you can declare the inherited subclasses on top of the parent class using the [bsonknowntypes] tag, so that mongo will automatically register them, e.g.:\n\n    [bsonknowntypes(typeof(entity))]\n    public class component\n    {\n    }\n    [bsonknowntypes(typeof(player))]\n    public class entity: component\n    {\n    }\n    public sealed class player: entity\n    {\n        public long id;\n        \n        public string account { get; set; }\n\t\t\n        public long unitid { get; set; }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nthis is flawed because the framework doesn\'t know what subclasses a class will have, and this is invasive to the framework code, and we want to uncouple this . you can scan the assembly for the types of all subclass parents and register them with the mongo driver\n\n\t\t\ttype[] types = typeof(game).assembly.gettypes();\n\t\t\tforeach (type type in types)\n\t\t\t{\n\t\t\t\tif (!type.issubclassof(typeof(component))))\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tbsonclassmap.lookupclassmap(type);\n\t\t\t}\n\n\t\t\tbsonserializer.registerserializer(new enumserializer<numerictype>(bsontype.string));\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nthis completely automates the registration and the user does not need to relate whether the class is registered or not.\n\n\n# 6. isupportinitialize interface\n\nmongo bson deserialization supports an isupportinitialize interface, isupportinitialize has two methods\n\n    public interface isupportinitialize\n    {\n        void begininit();\n        void endinit();\n    }\n\n\n1\n2\n3\n4\n5\n\n\nbegininit is called before deserialization and endinit is called after deserialization. this interface is very useful now to perform some operations after deserialization. for example\n\n\t[bsonignoreextraelements]\n\tpublic class innerconfig: aconfigcomponent\n\t{\n\t\t[bsonignore]\n\t\tpublic ipendpoint ipendpoint { get; private set; }\n\t\t\n\t\tpublic string address { get; set; }\n\n\t\tpublic override void endinit()\n\t\t{\n\t\t\tthis.ipendpoint = networkhelper.toipendpoint(this.address);\n\t\t}\n\t}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\ninnerconfig is the configuration of the process inner network address in et. since ipendpoint is not very configurable, we can configure it as a string and then convert the string to ipendpoint in endinit when deserializing. i also added this call to the protobuf deserialization method, refer to protobufhelper.cs, et\'s protobuf because to support ilruntime, so remove the map support, if we want a map how to do? here i gave the generated code are done, the proto messages are changed to a partial class, so that we can extend the class themselves, for example.\n\nmessage unitinfo\n{\n\tint64 unitid = 1;\n\n\tfloat x = 2;\n\tfloat y = 3;\n\tfloat z = 4;\n}\n\n// protobuf\nmessage g2c_entermap // iresponse\n{\n\tint32 rpcid = 90;\n\tint32 error = 91;\n\tstring message = 92;\n\t// own unit id\n\tint64 unitid = 1;\n\t// all the units\n\trepeated unitinfo units = 2;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\nthis network message has a repeated unitinfo field, which is actually an array in protobuf, which is not very convenient to use, i want to convert it to a dictionary<int64, unitinfo> field, we can do something like this\n\n    public partial class g2c_entermap: isupportinitialize\n    {\n        public dictionary<int64, unitinfo> unitsdict = new dictionary<long, unitinfo>();\n        \n        public void begininit()\n        {\n        }\n\n        public void endinit()\n        {\n            foreach (var unit in this.units)\n            {\n                this.unitsdict.add(unit.unitid, unit);\n            }\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nthe message is extended by such a piece of code, and after deserialization, it is automatically converted into a dictionary.',charsets:{},lastUpdated:"2022/07/25, 23:10:19",lastUpdatedTimestamp:1658761819e3},{title:"Everything is Entity",frontmatter:{title:"Everything is Entity",date:"2022-05-31T19:10:27.000Z",permalink:"/pages/b631b2/"},regularPath:"/02.Guide/01.ETBook_English/33.3.3Everything%20is%20Entity.html",relativePath:"02.Guide/01.ETBook_English/33.3.3Everything is Entity.md",key:"v-49b0f2aa",path:"/pages/b631b2/",headers:[{level:3,title:"1. Component creation",slug:"_1-component-creation",normalizedTitle:"1. component creation",charIndex:3569},{level:3,title:"2. Release of components",slug:"_2-release-of-components",normalizedTitle:"2. release of components",charIndex:4295},{level:3,title:"3. Role of InstanceId",slug:"_3-role-of-instanceid",normalizedTitle:"3. role of instanceid",charIndex:4850}],headersStr:"1. Component creation 2. Release of components 3. Role of InstanceId",content:"# Everything is Entity\n\nThe ECS design is very popular right now, mainly because of the success of Watchtower, which has led to the explosion of this technology. The most important design of ECS is the complete separation of logic and data. That is, EC is pure data, System is actually logic, by data-driven logic. What does data-driven logic mean? It is very simple to detect data changes through Update and subscribe to data changes through the event mechanism, which is called data-driven. Other features such as cache hits are not too important in writing logic, modern games are scripted, even the performance of the script can tolerate how will care about cache hits that performance improvement?\n\nFor example, in order to reuse, the data must be split into very small particles, which will lead to a very large number of components. But the game is developed cooperatively by multiple people, each person is basically only familiar with their own modules, which may end up causing a large number of redundant components. Another problem is that the common ECS is flat, with only one layer of Entity and Component. It is like a company, the biggest is the boss, the boss with hundreds of people under him, the boss can not know all the people, to complete a task, the boss can not pick out the people they need. A reasonable approach is to have several managers under the boss, several supervisors under each manager, and several workers under each supervisor, so as to form a tree-like management structure that is easy to manage. This is similar to the ET approach, where Entity can manage Component, Component can manage Entity, and even Component can mount Component. e.g. a person is composed of head, body, hands, feet, and the head is composed of eyes, ears, nose, mouth.\n\n    Head head = human.AddComponent<Head>();\n    head.AddComponent<Eye>();\n    head.AddComponent<Mouse>();\n    AddComponent<Nose>();\n    AddComponent<Ear>();\n    human.AddComponent<Body>();\n    AddComponent<Hand>();\n    human.AddComponent<Leg>();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nIn ET, all data is Entity, including Entity, and Entity can be used either as a component or as a child of other Entity. Generic data is placed on Entity as a member, and less generic data can be hung on Entity as a component. For example, the design of items, all items have fields configured id, quantity, level, these fields are not necessary to make components, put on Entity will be more convenient to use.\n\n    class Item: Entity\n    {\n        // The configuration Id of the props\n        public int ConfigId { get; set; }\n        // The number of props\n        public int Count { get; set; }\n        // The level of the props\n        public int Level { get; set; }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nThis design data of ET is a kind of tree structure, very hierarchical and can understand the whole game architecture very easily. Scene, and the data of different modules are mounted on top of Game. Scene, and each module can mount a lot of data under itself. You don't have to think too much about how to design the classes, where to put the data, whether mounting here will lead to redundancy, etc. for each new feature. For example, if my player needs to do a prop system, I can design an ItemsComponent to be mounted on the Player, and I need to develop a SpellComponent to be mounted on the Player for skills. If the whole service needs to do an activity, get an activity component to hang on top of the Game. This design will be very easy to assign tasks and very modular.\n\n\n# Some details of the component\n\n\n# 1. Component creation\n\nComponentFactory provides three methods to create components Create, CreateWithParent, CreateWithId. Create is the simplest way to create components, it does several things\na. Construct a component based on the component type\nb. Add the component to the event system and throw an AwakeSystem\nc. Enables object pooling or not\nCreateWithParent provides a Parent object on top of Create, which is set to the Component.Parent field. createWithId is used to create ComponentWithId or its subclasses, and you can set an Id on top of Create itself, Component can choose whether to use a pool of objects when it is created. All three types of factory methods have a fromPool parameter, the default is true.\n\n\n# 2. Release of components\n\nComponent inherits an IDisposable interface. It should be noted that Component has unmanaged resources and must be called to delete a Component. This interface does the following\na. Throw Destroy System\nb. If the component was created using an object pool, then it is put back into the object pool here\nc. Remove the component from the global EventSystem and set the InstanceId to 0\nIf the component is mounted on Entity, then when Entity calls Dispose, it will automatically call the Dispose method of all components on it.\n\n\n# 3. Role of InstanceId\n\nAny Component comes with an InstanceId field, which is reset when the component is constructed, or when the component is removed from the object pool, and which identifies the identity of the component. Why is such a field needed? There are several reasons\n\n 1. the existence of the object pool, the component may not be released, but returned to the object pool. In an asynchronous call, it is likely that the component has already been released and then reused, so that we need a way to be able to distinguish whether the previous component object has been released, such as the following code.\n\n\t\tpublic static async ETVoid UpdateAsync(this ActorLocationSender self)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tlong instanceId = self.InstanceId;\n\t\t\t\twhile (true)\n\t\t\t\t{\n\t\t\t\t\tif (self.InstanceId ! = instanceId)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tActorTask actorTask = await self.GetAsync();\n\t\t\t\t\t\n\t\t\t\t\tif (self.InstanceId ! = instanceId)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif (actorTask.ActorRequest == null)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tawait self.RunTask(actorTask);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e)\n\t\t\t{\n\t\t\t\tLog.Error(e);\n\t\t\t}\n\t\t}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\nWhile (true) is an asynchronous method, after await self.GetAsync() it is likely that the ActorLocationSender object has been released, and it is even possible that the object has been utilized again by other logic from the object pool. We can determine whether the object has been released by the change of InstanceId. 2.\n2. InstanceId is globally unique and has location information, so you can find the location of the object by InstanceId and send the message to the object. This design will be utilized in the Actor message. Here for the time being will not talk about it.",normalizedContent:"# everything is entity\n\nthe ecs design is very popular right now, mainly because of the success of watchtower, which has led to the explosion of this technology. the most important design of ecs is the complete separation of logic and data. that is, ec is pure data, system is actually logic, by data-driven logic. what does data-driven logic mean? it is very simple to detect data changes through update and subscribe to data changes through the event mechanism, which is called data-driven. other features such as cache hits are not too important in writing logic, modern games are scripted, even the performance of the script can tolerate how will care about cache hits that performance improvement?\n\nfor example, in order to reuse, the data must be split into very small particles, which will lead to a very large number of components. but the game is developed cooperatively by multiple people, each person is basically only familiar with their own modules, which may end up causing a large number of redundant components. another problem is that the common ecs is flat, with only one layer of entity and component. it is like a company, the biggest is the boss, the boss with hundreds of people under him, the boss can not know all the people, to complete a task, the boss can not pick out the people they need. a reasonable approach is to have several managers under the boss, several supervisors under each manager, and several workers under each supervisor, so as to form a tree-like management structure that is easy to manage. this is similar to the et approach, where entity can manage component, component can manage entity, and even component can mount component. e.g. a person is composed of head, body, hands, feet, and the head is composed of eyes, ears, nose, mouth.\n\n    head head = human.addcomponent<head>();\n    head.addcomponent<eye>();\n    head.addcomponent<mouse>();\n    addcomponent<nose>();\n    addcomponent<ear>();\n    human.addcomponent<body>();\n    addcomponent<hand>();\n    human.addcomponent<leg>();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nin et, all data is entity, including entity, and entity can be used either as a component or as a child of other entity. generic data is placed on entity as a member, and less generic data can be hung on entity as a component. for example, the design of items, all items have fields configured id, quantity, level, these fields are not necessary to make components, put on entity will be more convenient to use.\n\n    class item: entity\n    {\n        // the configuration id of the props\n        public int configid { get; set; }\n        // the number of props\n        public int count { get; set; }\n        // the level of the props\n        public int level { get; set; }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nthis design data of et is a kind of tree structure, very hierarchical and can understand the whole game architecture very easily. scene, and the data of different modules are mounted on top of game. scene, and each module can mount a lot of data under itself. you don't have to think too much about how to design the classes, where to put the data, whether mounting here will lead to redundancy, etc. for each new feature. for example, if my player needs to do a prop system, i can design an itemscomponent to be mounted on the player, and i need to develop a spellcomponent to be mounted on the player for skills. if the whole service needs to do an activity, get an activity component to hang on top of the game. this design will be very easy to assign tasks and very modular.\n\n\n# some details of the component\n\n\n# 1. component creation\n\ncomponentfactory provides three methods to create components create, createwithparent, createwithid. create is the simplest way to create components, it does several things\na. construct a component based on the component type\nb. add the component to the event system and throw an awakesystem\nc. enables object pooling or not\ncreatewithparent provides a parent object on top of create, which is set to the component.parent field. createwithid is used to create componentwithid or its subclasses, and you can set an id on top of create itself, component can choose whether to use a pool of objects when it is created. all three types of factory methods have a frompool parameter, the default is true.\n\n\n# 2. release of components\n\ncomponent inherits an idisposable interface. it should be noted that component has unmanaged resources and must be called to delete a component. this interface does the following\na. throw destroy system\nb. if the component was created using an object pool, then it is put back into the object pool here\nc. remove the component from the global eventsystem and set the instanceid to 0\nif the component is mounted on entity, then when entity calls dispose, it will automatically call the dispose method of all components on it.\n\n\n# 3. role of instanceid\n\nany component comes with an instanceid field, which is reset when the component is constructed, or when the component is removed from the object pool, and which identifies the identity of the component. why is such a field needed? there are several reasons\n\n 1. the existence of the object pool, the component may not be released, but returned to the object pool. in an asynchronous call, it is likely that the component has already been released and then reused, so that we need a way to be able to distinguish whether the previous component object has been released, such as the following code.\n\n\t\tpublic static async etvoid updateasync(this actorlocationsender self)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tlong instanceid = self.instanceid;\n\t\t\t\twhile (true)\n\t\t\t\t{\n\t\t\t\t\tif (self.instanceid ! = instanceid)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tactortask actortask = await self.getasync();\n\t\t\t\t\t\n\t\t\t\t\tif (self.instanceid ! = instanceid)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif (actortask.actorrequest == null)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tawait self.runtask(actortask);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (exception e)\n\t\t\t{\n\t\t\t\tlog.error(e);\n\t\t\t}\n\t\t}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\nwhile (true) is an asynchronous method, after await self.getasync() it is likely that the actorlocationsender object has been released, and it is even possible that the object has been utilized again by other logic from the object pool. we can determine whether the object has been released by the change of instanceid. 2.\n2. instanceid is globally unique and has location information, so you can find the location of the object by instanceid and send the message to the object. this design will be utilized in the actor message. here for the time being will not talk about it.",charsets:{},lastUpdated:"2022/07/25, 23:10:19",lastUpdatedTimestamp:1658761819e3},{title:"EventSystem",frontmatter:{title:"EventSystem",date:"2022-05-31T19:10:27.000Z",permalink:"/pages/53296b/"},regularPath:"/02.Guide/01.ETBook_English/35.3.4EventSystem.html",relativePath:"02.Guide/01.ETBook_English/35.3.4EventSystem.md",key:"v-3bddb7a2",path:"/pages/53296b/",headersStr:null,content:"# EventSystem\n\nOne of the most important features of ECS is the separation of data and logic, and the second is data-driven logic. What is data-driven logic? Not very well understood, let's take an example A moba game, the heroes have blood bars, which are displayed on the character's head, and also on the top left avatar UI. This time the server sends a blood deduction message. How do we handle this message? In the first way, we modify the hero's blood value in the message handling function, modify the blood bar display on the avatar, and modify the blood bar on the avatar UI at the same time. This approach obviously causes coupling between modules. In the second method, the blood value is only changed in the blood deduction message processing function, and the change of blood value throws an hpchange event, and both the avatar module and the UI module subscribe to the blood value change event and handle their own logic in the subscribed method, so that each module is responsible for its own logic without coupling. ET provides a variety of events, all of which can be subscribed multiple times:\n\n 1. AwakeSystem, which is thrown after the component factory creates a component, and is thrown only once, with parameters\n\n    Player player = ComponentFactory.Create<Player>();\n\n    // Subscribe to Player's Awake event\n    public class PlayerAwakeSystem: AwakeSystem<Player>\n    {\n        public override void Awake(Player self)\n        {\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n 2. StartSystem, component UpdateSystem call before throwing\n\n    // Subscribe to Player's Start event\n    public class PlayerStartSystem: StartSystem<Player>\n    {\n        public override void Start(Player self)\n        {\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n\n 3. UpdateSystem, component thrown every frame\n\n    // Subscribe to Player's Update event\n    public class PlayerUpdateSystem: UpdateSystem<Player>\n    {\n        public override void Update(Player self)\n        {\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n\n 4. DestroySystem, thrown when the component is deleted\n\n    // Subscribe to Player's Destroy event\n    public class PlayerDestroySystem: DestroySystem<Player>\n    {\n        public override void Destroy(Player self)\n        {\n        }\n    }\n\n    Player player = ComponentFactory.Create<Player>();\n    // The Destroy event will be fired here\n    player.Dispose();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n 5. ChangeSystem, thrown when the content of the component changes, needs to be triggered manually by the developer\n\n    // Subscribe to Player's Destroy event\n    public class PlayerChangeSystem: ChangeSystem<Player>\n    {\n        public override void Change(Player self)\n        {\n        }\n    }\n\n    Player player = ComponentFactory.Create<Player>();\n    // need to trigger ChangeSystem manually\n    Game.EventSystem.Change(player);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n 6. DeserializeSystem, thrown after component deserialization\n\n    // Subscribe to Player's Deserialize event\n    public class PlayerDeserializeSystem: DeserializeSystem<Player>\n    {\n        public override void Deserialize(Player self)\n        {\n        }\n    }\n\n    // Here player2 will trigger the Deserialize event\n    Player player2 = MongoHelper.FromBson<Player>(player.ToBson());\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n 7. LoadSystem, EventSystem thrown when loading dll, used for server-side hot update, reload dll to do some processing, such as re-register handler\n\n    // Subscribe to Player's Load event\n    public class PlayerLoadSystem: LoadSystem<Player>\n    {\n        public override void Load(Player self)\n        {\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n\n 8. normal Event, thrown by the developer himself, can take up to three parameters. Also the client hot change layer can subscribe to the mono layer Event events\n\n    int oldhp = 10;\n    int newhp = 5;\n    // Throw hp change event\n    Game.EventSystem.Run(\"HpChange\", oldhp, newhp);\n\n    // UI subscribe to the hp change event\n    [Event(\"HpChange\")]\n    public class HpChange_ShowUI: AEvent<int, int>\n    {\n        public override void Run(int a, int b)\n        {\n            throw new NotImplementedException();\n        }\n    }\n\n    // The model header blood bar module also subscribes to the hp change event\n    [Event(\"HpChange\")\n    public class HpChange_ModelHeadChange: AEvent<int, int>\n    {\n        public override void Run(int a, int b)\n        {\n            throw new NotImplementedException();\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n 9. There are many other events, such as message events. Message events are declared using MessageHandler and can take parameters to specify which server to subscribe to.\n\n\t[MessageHandler(AppType.Gate)]\n\tpublic class C2G_LoginGateHandler : AMRpcHandler<C2G_LoginGate, G2C_LoginGate>\n\t{\n\t\tprotected override void Run(Session session, C2G_LoginGate message, Action<G2C_LoginGate> reply)\n\t\t{\n\t\t\tG2C_LoginGate response = new G2C_LoginGate();\n\t\t\treply(reply);\n\t\t}\n\t}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nMore specific message events will be explained in detail when we talk about messages\n10. numeric events, numeric module and then explain\n...... , more events to be developed by yourself.\n\nThe logic of the ET framework is driven by the various events above.",normalizedContent:"# eventsystem\n\none of the most important features of ecs is the separation of data and logic, and the second is data-driven logic. what is data-driven logic? not very well understood, let's take an example a moba game, the heroes have blood bars, which are displayed on the character's head, and also on the top left avatar ui. this time the server sends a blood deduction message. how do we handle this message? in the first way, we modify the hero's blood value in the message handling function, modify the blood bar display on the avatar, and modify the blood bar on the avatar ui at the same time. this approach obviously causes coupling between modules. in the second method, the blood value is only changed in the blood deduction message processing function, and the change of blood value throws an hpchange event, and both the avatar module and the ui module subscribe to the blood value change event and handle their own logic in the subscribed method, so that each module is responsible for its own logic without coupling. et provides a variety of events, all of which can be subscribed multiple times:\n\n 1. awakesystem, which is thrown after the component factory creates a component, and is thrown only once, with parameters\n\n    player player = componentfactory.create<player>();\n\n    // subscribe to player's awake event\n    public class playerawakesystem: awakesystem<player>\n    {\n        public override void awake(player self)\n        {\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n 2. startsystem, component updatesystem call before throwing\n\n    // subscribe to player's start event\n    public class playerstartsystem: startsystem<player>\n    {\n        public override void start(player self)\n        {\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n\n 3. updatesystem, component thrown every frame\n\n    // subscribe to player's update event\n    public class playerupdatesystem: updatesystem<player>\n    {\n        public override void update(player self)\n        {\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n\n 4. destroysystem, thrown when the component is deleted\n\n    // subscribe to player's destroy event\n    public class playerdestroysystem: destroysystem<player>\n    {\n        public override void destroy(player self)\n        {\n        }\n    }\n\n    player player = componentfactory.create<player>();\n    // the destroy event will be fired here\n    player.dispose();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n 5. changesystem, thrown when the content of the component changes, needs to be triggered manually by the developer\n\n    // subscribe to player's destroy event\n    public class playerchangesystem: changesystem<player>\n    {\n        public override void change(player self)\n        {\n        }\n    }\n\n    player player = componentfactory.create<player>();\n    // need to trigger changesystem manually\n    game.eventsystem.change(player);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n 6. deserializesystem, thrown after component deserialization\n\n    // subscribe to player's deserialize event\n    public class playerdeserializesystem: deserializesystem<player>\n    {\n        public override void deserialize(player self)\n        {\n        }\n    }\n\n    // here player2 will trigger the deserialize event\n    player player2 = mongohelper.frombson<player>(player.tobson());\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n 7. loadsystem, eventsystem thrown when loading dll, used for server-side hot update, reload dll to do some processing, such as re-register handler\n\n    // subscribe to player's load event\n    public class playerloadsystem: loadsystem<player>\n    {\n        public override void load(player self)\n        {\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n\n 8. normal event, thrown by the developer himself, can take up to three parameters. also the client hot change layer can subscribe to the mono layer event events\n\n    int oldhp = 10;\n    int newhp = 5;\n    // throw hp change event\n    game.eventsystem.run(\"hpchange\", oldhp, newhp);\n\n    // ui subscribe to the hp change event\n    [event(\"hpchange\")]\n    public class hpchange_showui: aevent<int, int>\n    {\n        public override void run(int a, int b)\n        {\n            throw new notimplementedexception();\n        }\n    }\n\n    // the model header blood bar module also subscribes to the hp change event\n    [event(\"hpchange\")\n    public class hpchange_modelheadchange: aevent<int, int>\n    {\n        public override void run(int a, int b)\n        {\n            throw new notimplementedexception();\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n 9. there are many other events, such as message events. message events are declared using messagehandler and can take parameters to specify which server to subscribe to.\n\n\t[messagehandler(apptype.gate)]\n\tpublic class c2g_logingatehandler : amrpchandler<c2g_logingate, g2c_logingate>\n\t{\n\t\tprotected override void run(session session, c2g_logingate message, action<g2c_logingate> reply)\n\t\t{\n\t\t\tg2c_logingate response = new g2c_logingate();\n\t\t\treply(reply);\n\t\t}\n\t}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nmore specific message events will be explained in detail when we talk about messages\n10. numeric events, numeric module and then explain\n...... , more events to be developed by yourself.\n\nthe logic of the et framework is driven by the various events above.",charsets:{},lastUpdated:"2022/07/25, 23:10:19",lastUpdatedTimestamp:1658761819e3},{title:"Component-based design",frontmatter:{title:"Component-based design",date:"2022-05-31T19:10:27.000Z",permalink:"/pages/66fec6/"},regularPath:"/02.Guide/01.ETBook_English/41.4.1Component-based%20design.html",relativePath:"02.Guide/01.ETBook_English/41.4.1Component-based design.md",key:"v-fdfe0ef0",path:"/pages/66fec6/",headers:[{level:2,title:"1. data structure coupling is very strong",slug:"_1-data-structure-coupling-is-very-strong",normalizedTitle:"1. data structure coupling is very strong",charIndex:337},{level:2,title:"2. Difficult to hot-plug",slug:"_2-difficult-to-hot-plug",normalizedTitle:"2. difficult to hot-plug",charIndex:1635},{level:2,title:"3. method and data coupling",slug:"_3-method-and-data-coupling",normalizedTitle:"3. method and data coupling",charIndex:3232}],headersStr:"1. data structure coupling is very strong 2. Difficult to hot-plug 3. method and data coupling",content:"# Component-based design\n\nIn terms of code reuse and organization of data, object-oriented may be the first response. Object-oriented three features inheritance, encapsulation, polymorphism, to a certain extent can solve a lot of code reuse, data reuse problems. But object-oriented is not a panacea, it also has great flaws: # # 1.\n\n\n# 1. data structure coupling is very strong\n\nOnce a field is added or removed from a parent class, it may have to affect all subclasses and affect all subclass-related logic. This seems very inflexible, in a complex set of inheritance system, to change the fields in the parent class will become more and more troublesome, let's say ABC is a subclass of D, one day found the need to add a data that AB has, but C does not, then this data is certainly not good to put into the parent class, only AB abstracted out of a parent class E, E inherited from D, AB common fields added to E, once the inheritance structure Once the inheritance structure has changed, the interface may also need to change, let's say there is an interface incoming parameter type is E, when AB no longer needs the common field, then the inheritance relationship needs to be adjusted so that AB inherits D again, then the interface incoming parameter type needs to be changed to D, where the logic code is likely to be adjusted. What's worse is that the game logic changes very complicated and very often, maybe today a field is added, tomorrow it is deleted, if every time to adjust the inheritance structure, it is a nightmare. Inheritance structure feels very powerless in the face of frequent data structure adjustment.\n\n\n# 2. Difficult to hot-plug\n\nInheritance structure can't add or delete fields at runtime, for example, Player usually walks, and then rides after using mount. The problem is that the information about the mount would need to be hanging on top of the Player object all the time. This makes it inflexible. Why do I need to have the horse data in memory when I'm not riding? The interface has the same problem, a class implements an interface, then the interface will always stick to the class, you want to get rid of her can not, or horse riding for example, the player player can ride, then may inherit a riding interface, the problem is, when I the Player from the mount, the player player still has the riding interface, there is no way to There is no way to dynamically delete this interface! The example may not be quite right, but the reasoning should be clear.\n\nThe use of object-oriented may lead to disastrous consequences, game development in the new and old, there are good skills, there are poor skills. People like to be lazy, when you find the trouble to adjust the inheritance relationship, it is possible to add a field in AB to save trouble directly into the parent class D. The result is that C somehow has an extra field that is useless. The key can not be found, and finally lead to the parent class D is getting bigger and bigger, in the end, it may simply not ABC, directly let all the objects into D, convenient well! Yes, many games are doing this, the development of the end simply do not care about the inheritance relationship, because you want to manage can not manage.\n\n\n# 3. method and data coupling\n\nTraditional object-oriented are class with methods, and especially advocate virtual function polymorphism. Methods and data put together brings a lot of coupling problems. In order to solve these coupling, we came up with a large number of design patterns, such as dependency interfaces, dependency transposition. To be honest, this is pants down, in order to understand the coupling, make the class into an interface, and then inherit from the interface, is this not called dependency? These practices lead to code that is full of interfaces and extremely difficult to read. There is no standard for writing up code, and the code written by experts and rookies is completely different. Most coders are logic boys, who have time to think about how to design this class every day ah? As the logic becomes more and more complex class inside the method will become increasingly large, the terrible thing is that this is the method of the class, extremely difficult to refactor, many projects can see the class inside the existence of tens of thousands of lines of code of virtual functions. Gosh!\n\nObject-oriented in the face of complex game logic is very powerless, so many game developers have gone backwards, using process-oriented development game, process-oriented, simple and brutal, do not consider complex inheritance, do not consider abstraction, do not consider polymorphism, is the development of the session of freestyle, roll up your sleeves on the jerk, but at the same time, the reusability of the code logic, data reusability is also greatly reduced. Process-oriented is also not a good game development model.\n\nComponent pattern is a good solution to object-oriented and process-oriented defects, in the game client is very widely used, Unity3d, Unreal 4, and so on are using the component pattern. The characteristics of the component pattern.\n\n 1. Highly modular, a component is a piece of data plus a paragraph of logic\n 2. Components can be hot-pluggable, you need to add, do not need to remove\n 3. Very few dependencies between types, any type of adding or removing components will not affect other types.\n\nBut at present only a very small number of server-side design using components, Watchtower server-side should be the use of component design, Watchtower developers called ECS architecture, in fact, is a variant of the component model, E is Entity, C is Component, S is System, in fact, is the component Component logic and data stripped, the logic part called System, the topic is far away, or back to the ET framework to put.\n\nET framework uses the design of components. Everything is Entity and Component, any class inherited from Entity can be mounted components, such as the player class.\n\npublic sealed class Player : Entity\n{\n    public string Account { get; private set; }\n    public long UnitId { get; set; }\n\t\n    public void Awake(string account)\n    {\n        this.Account = account;\n    }\n\t\n    public override void Dispose()\n    {\n        if (this.Id == 0)\n        {\n            return;\n        }\n        base.Dispose();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\nMount a MoveComponent to the player object so that the player can move, a Backpack component to the player so that the player can manage items, a Skill component to the player so that the player can cast skills, and a Buff component to manage buffs.\n\nplayer.AddComponent<MoveComponent>();\nplayer.AddComponent<ItemsComponent>();\nplayer.AddComponent<SpellComponent>();\nAddComponent<BuffComponent>(); player.AddComponent<BuffComponent>();\n\n\n1\n2\n3\n4\n\n\nComponents are highly reusable, for example, an NPC, he can also move, just put MoveComponent on the NPC, some NPCs can also cast skills, then put SpellComponent on it, NPCs do not need a backpack, then there is no need to hang ItemsComponent\n\nET framework modules are all made into the form of components, a process is also made of different components stitched together. Let's say Loginserver needs to connect externally and also needs to connect with the server internally, then login server hooks up\n\n// intranet network component NetInnerComponent, which handles the connection to the intranet  \nGame.Scene.AddComponent<NetInnerComponent, string, int>(innerConfig.Host, innerConfig.Port);\n// NetOuterComponent, an extranet component, handles the connection to the client\nGame.Scene.AddComponent<NetOuterComponent, string, int>(outerConfig.Host, outerConfig.Port);\n\n\n1\n2\n3\n4\n\n\nFor example, battle server does not need to connect to the external network (external network messages are forwarded by gateserver), so it is natural to just mount an internal network component. Similar to Unity3d components, ET framework also provides component events, such as Awake, Start, Update, etc.. To add these events to a Component or Entity, you must write a helper class. For example, if the NetInnerComponent component needs Awake and Update methods, then add a class like this.\n\n[ObjectEvent]\npublic class NetInnerComponentEvent : ObjectEvent<NetInnerComponent>, IAwake, IUpdate\n{\n    public void Awake()\n    {\n        this.Get().Awake();\n    }\n\n    public void Update()\n    {\n        this.Get().Update();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nIn this way, NetInnerComponent calls its Awake method after AddComponent and calls the Update method every frame. ET does not use reflection like Unity to implement this kind of functionality, because reflection performance is poor, and the advantage of this implementation is that the class can be placed in the hot update dll, so that the component's Awake Start, Update method and other methods can be placed in the hot update layer. Entity and Component will be made into a class without methods, methods are put into the hot update layer to facilitate the hot update to fix logic bugs.\n\nThe biggest advantage of component-based development is that whether rookie or expert, the development of a function can quickly know how to organize data how to organize the logic. Object-oriented can be completely abandoned. Object-oriented development using the most headache is that I should inherit which class it? Before doing the most horrible is Unreal three, Unreal three inheritance structure is very multi-layer, completely do not know where they need to start inheritance. In the end, it could lead to a very small function that inherits a very large class, which is common in Unreal 3 development. So Unreal 4 switched to the component pattern. The module isolation of the component pattern is very good, the technical rookie a component written very poorly, will not affect the other modules, the big deal is to rewrite the component on the good.\n\nET's component design innovation, method and data separation, completely decoupled, no brainstorming how to uncouple, write static methods at will, there is no coupling, even the code written by rookies is easy to refactor.\n\nIt is because ET uses the detachable component model, ET can load all server components to the same process, then this one process can be used as a set of distributed servers. From then on it is possible to debug distributed servers with vs. Because of this, the usual development only use a process, when the release of the release into multiple processes on the line. Honestly, not to brag, this is a great invention, this invention solves a big problem in the development of distributed game servers, greatly improving the efficiency of development.",normalizedContent:"# component-based design\n\nin terms of code reuse and organization of data, object-oriented may be the first response. object-oriented three features inheritance, encapsulation, polymorphism, to a certain extent can solve a lot of code reuse, data reuse problems. but object-oriented is not a panacea, it also has great flaws: # # 1.\n\n\n# 1. data structure coupling is very strong\n\nonce a field is added or removed from a parent class, it may have to affect all subclasses and affect all subclass-related logic. this seems very inflexible, in a complex set of inheritance system, to change the fields in the parent class will become more and more troublesome, let's say abc is a subclass of d, one day found the need to add a data that ab has, but c does not, then this data is certainly not good to put into the parent class, only ab abstracted out of a parent class e, e inherited from d, ab common fields added to e, once the inheritance structure once the inheritance structure has changed, the interface may also need to change, let's say there is an interface incoming parameter type is e, when ab no longer needs the common field, then the inheritance relationship needs to be adjusted so that ab inherits d again, then the interface incoming parameter type needs to be changed to d, where the logic code is likely to be adjusted. what's worse is that the game logic changes very complicated and very often, maybe today a field is added, tomorrow it is deleted, if every time to adjust the inheritance structure, it is a nightmare. inheritance structure feels very powerless in the face of frequent data structure adjustment.\n\n\n# 2. difficult to hot-plug\n\ninheritance structure can't add or delete fields at runtime, for example, player usually walks, and then rides after using mount. the problem is that the information about the mount would need to be hanging on top of the player object all the time. this makes it inflexible. why do i need to have the horse data in memory when i'm not riding? the interface has the same problem, a class implements an interface, then the interface will always stick to the class, you want to get rid of her can not, or horse riding for example, the player player can ride, then may inherit a riding interface, the problem is, when i the player from the mount, the player player still has the riding interface, there is no way to there is no way to dynamically delete this interface! the example may not be quite right, but the reasoning should be clear.\n\nthe use of object-oriented may lead to disastrous consequences, game development in the new and old, there are good skills, there are poor skills. people like to be lazy, when you find the trouble to adjust the inheritance relationship, it is possible to add a field in ab to save trouble directly into the parent class d. the result is that c somehow has an extra field that is useless. the key can not be found, and finally lead to the parent class d is getting bigger and bigger, in the end, it may simply not abc, directly let all the objects into d, convenient well! yes, many games are doing this, the development of the end simply do not care about the inheritance relationship, because you want to manage can not manage.\n\n\n# 3. method and data coupling\n\ntraditional object-oriented are class with methods, and especially advocate virtual function polymorphism. methods and data put together brings a lot of coupling problems. in order to solve these coupling, we came up with a large number of design patterns, such as dependency interfaces, dependency transposition. to be honest, this is pants down, in order to understand the coupling, make the class into an interface, and then inherit from the interface, is this not called dependency? these practices lead to code that is full of interfaces and extremely difficult to read. there is no standard for writing up code, and the code written by experts and rookies is completely different. most coders are logic boys, who have time to think about how to design this class every day ah? as the logic becomes more and more complex class inside the method will become increasingly large, the terrible thing is that this is the method of the class, extremely difficult to refactor, many projects can see the class inside the existence of tens of thousands of lines of code of virtual functions. gosh!\n\nobject-oriented in the face of complex game logic is very powerless, so many game developers have gone backwards, using process-oriented development game, process-oriented, simple and brutal, do not consider complex inheritance, do not consider abstraction, do not consider polymorphism, is the development of the session of freestyle, roll up your sleeves on the jerk, but at the same time, the reusability of the code logic, data reusability is also greatly reduced. process-oriented is also not a good game development model.\n\ncomponent pattern is a good solution to object-oriented and process-oriented defects, in the game client is very widely used, unity3d, unreal 4, and so on are using the component pattern. the characteristics of the component pattern.\n\n 1. highly modular, a component is a piece of data plus a paragraph of logic\n 2. components can be hot-pluggable, you need to add, do not need to remove\n 3. very few dependencies between types, any type of adding or removing components will not affect other types.\n\nbut at present only a very small number of server-side design using components, watchtower server-side should be the use of component design, watchtower developers called ecs architecture, in fact, is a variant of the component model, e is entity, c is component, s is system, in fact, is the component component logic and data stripped, the logic part called system, the topic is far away, or back to the et framework to put.\n\net framework uses the design of components. everything is entity and component, any class inherited from entity can be mounted components, such as the player class.\n\npublic sealed class player : entity\n{\n    public string account { get; private set; }\n    public long unitid { get; set; }\n\t\n    public void awake(string account)\n    {\n        this.account = account;\n    }\n\t\n    public override void dispose()\n    {\n        if (this.id == 0)\n        {\n            return;\n        }\n        base.dispose();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\nmount a movecomponent to the player object so that the player can move, a backpack component to the player so that the player can manage items, a skill component to the player so that the player can cast skills, and a buff component to manage buffs.\n\nplayer.addcomponent<movecomponent>();\nplayer.addcomponent<itemscomponent>();\nplayer.addcomponent<spellcomponent>();\naddcomponent<buffcomponent>(); player.addcomponent<buffcomponent>();\n\n\n1\n2\n3\n4\n\n\ncomponents are highly reusable, for example, an npc, he can also move, just put movecomponent on the npc, some npcs can also cast skills, then put spellcomponent on it, npcs do not need a backpack, then there is no need to hang itemscomponent\n\net framework modules are all made into the form of components, a process is also made of different components stitched together. let's say loginserver needs to connect externally and also needs to connect with the server internally, then login server hooks up\n\n// intranet network component netinnercomponent, which handles the connection to the intranet  \ngame.scene.addcomponent<netinnercomponent, string, int>(innerconfig.host, innerconfig.port);\n// netoutercomponent, an extranet component, handles the connection to the client\ngame.scene.addcomponent<netoutercomponent, string, int>(outerconfig.host, outerconfig.port);\n\n\n1\n2\n3\n4\n\n\nfor example, battle server does not need to connect to the external network (external network messages are forwarded by gateserver), so it is natural to just mount an internal network component. similar to unity3d components, et framework also provides component events, such as awake, start, update, etc.. to add these events to a component or entity, you must write a helper class. for example, if the netinnercomponent component needs awake and update methods, then add a class like this.\n\n[objectevent]\npublic class netinnercomponentevent : objectevent<netinnercomponent>, iawake, iupdate\n{\n    public void awake()\n    {\n        this.get().awake();\n    }\n\n    public void update()\n    {\n        this.get().update();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nin this way, netinnercomponent calls its awake method after addcomponent and calls the update method every frame. et does not use reflection like unity to implement this kind of functionality, because reflection performance is poor, and the advantage of this implementation is that the class can be placed in the hot update dll, so that the component's awake start, update method and other methods can be placed in the hot update layer. entity and component will be made into a class without methods, methods are put into the hot update layer to facilitate the hot update to fix logic bugs.\n\nthe biggest advantage of component-based development is that whether rookie or expert, the development of a function can quickly know how to organize data how to organize the logic. object-oriented can be completely abandoned. object-oriented development using the most headache is that i should inherit which class it? before doing the most horrible is unreal three, unreal three inheritance structure is very multi-layer, completely do not know where they need to start inheritance. in the end, it could lead to a very small function that inherits a very large class, which is common in unreal 3 development. so unreal 4 switched to the component pattern. the module isolation of the component pattern is very good, the technical rookie a component written very poorly, will not affect the other modules, the big deal is to rewrite the component on the good.\n\net's component design innovation, method and data separation, completely decoupled, no brainstorming how to uncouple, write static methods at will, there is no coupling, even the code written by rookies is easy to refactor.\n\nit is because et uses the detachable component model, et can load all server components to the same process, then this one process can be used as a set of distributed servers. from then on it is possible to debug distributed servers with vs. because of this, the usual development only use a process, when the release of the release into multiple processes on the line. honestly, not to brag, this is a great invention, this invention solves a big problem in the development of distributed game servers, greatly improving the efficiency of development.",charsets:{},lastUpdated:"2022/07/25, 23:10:19",lastUpdatedTimestamp:1658761819e3},{title:"Actor Model",frontmatter:{title:"Actor Model",date:"2022-05-31T19:10:27.000Z",permalink:"/pages/a3279e/"},regularPath:"/02.Guide/01.ETBook_English/54.5.4Actor%20Model.html",relativePath:"02.Guide/01.ETBook_English/54.5.4Actor Model.md",key:"v-075f2a06",path:"/pages/a3279e/",headers:[{level:3,title:"Actor introduction",slug:"actor-introduction",normalizedTitle:"actor introduction",charIndex:18},{level:3,title:"ET's Actor",slug:"et-s-actor",normalizedTitle:"et's actor",charIndex:3884},{level:3,title:"Use of ET's Actor",slug:"use-of-et-s-actor",normalizedTitle:"use of et's actor",charIndex:4837},{level:3,title:"Handling of Actor messages",slug:"handling-of-actor-messages",normalizedTitle:"handling of actor messages",charIndex:6481}],headersStr:"Actor introduction ET's Actor Use of ET's Actor Handling of Actor messages",content:"# Actor model\n\n\n# Actor introduction\n\nBefore discussing the Actor model, we should discuss the architecture of ET. There are two architectures for game servers in order to use multi-core, single-threaded multi-process and single-process multi-threaded architecture. ET uses single-threaded multi-process architecture, while the traditional Actor model is generally single-process multi-threaded architecture, which is a major difference. The advantages and disadvantages are as follows.\n\n 1. the logic needs to be single-threaded this is the same, erlang process logic is single-threaded, skynet lua virtual machine is also single-threaded. et in a process is actually equivalent to an erlang process, a skynet lua virtual machine.\n 2. the use of single-threaded multi-process does not need to write their own set of profiler tools, you can use a lot of ready-made profiler tools, such as view memory, cpu occupation directly with top command, this point erlang and skynet need to get another set of tools.\n 3. multi-process single-threaded architecture also has a benefit, a single physical machine and multiple physical machines is no difference, single process multi-threaded also need to consider the processing of multiple physical machines.\n 4. multi-process single-threaded architecture is a bit of a drawback is that messages need to be serialized and deserialized across processes, taking up a bit of resources. In addition, sending network messages will have a few milliseconds delay. Generally these effects can be ignored.\n\nThe original Actor model is used for single-process multi-threaded architecture, there is a reason for this, because multi-threaded architecture developers can easily access shared variables at will, let's say a variable a, thread 1 can access, thread 2 can also access, so that both threads need to add locks when accessing the variable a, shared variables more locks everywhere, will become unmaintainable, the framework must not appear The framework must not have a situation where there are threads sharing variables everywhere. In order to ensure that the multi-threaded architecture does not go wrong, it is necessary to provide a development model that ensures easy and safe multi-threaded development. erlang's concurrency mechanism is the actor model. erlang virtual machine uses multiple threads to take advantage of multiple cores. erlang has designed a mechanism that designs its own processes on top of the virtual machine. At its simplest, each erlang process manages its own variables, and the logic of each erlang process runs on a single thread. The logic between the erlang process and the process is completely isolated, so that there are no two threads accessing the same variable and there is no multithreaded competition. The next question arises, since each erlang process has its own data and the logic is completely isolated, how should the two erlang processes communicate with each other? This is where the Actor model comes in. erlang has designed a messaging mechanism: one process can send messages to other processes, and erlang processes communicate with each other through messages. Isn't this the same message queue used by operating systems for inter-process communication? Yes, in fact, it is similar. erlang inside the process id to get the process can send messages to this process.\n\nIf the message is only sent to the process, it is still a bit inconvenient. For example, if you take an erlang process as a moba team process, and there are 10 players in the battle process, if you use erlang's actor message, the message can only be sent to the battle process, but often the message needs to be sent to a player, then erlang needs to distribute the message to the specific player again according to the player id in the message, so it actually goes around one more time. This is actually an extra detour.\n\n\n# ET's Actor\n\nAccording to the characteristics of its own architecture, ET does not completely copy the Actor model of erlang, but provides the Entity object-level Actor model. In ET, an Actor is an Entity object, and a MailboxComponent component attached to an Entity is an Actor. You only need to know the Entity's InstanceId to send messages to the Entity. In fact, erlang's Actor model is a special case of ET, such as giving the ET server Game.Scene as an Actor, so that it can become a process-level Actor. It only needs to know the InstanceId (ET) or the Pid (erlang) of the process to send it to the other party.\n\n| Language | ET | Erlang | Skynet | | | ET | Erlang | Skynet | -- | :--: | :--: | :--: | | Architecture | Single-Threaded Multi-Process | Single-Process Multi-Threaded | Single-Process Multi-Threaded | | Actor | Entity | erlang process | lua virtual machine | | ActorId | Entity.InstanceId | erlang processId | service address |\n\n\n# Use of ET's Actor\n\nFor a normal Actor, we can refer to the Gate Session. map has a Unit, and the Unit holds the gate session corresponding to the player. thus, if a message in map needs to be sent to the client, it only needs to send the message to the gate session, and the gate session forwards it to the client when it receives the message. The map process sending messages to the gate session is a typical actor model. It doesn't need to know the location of the gate session, it just needs to know its InstanceId. messageHelper.cs gets an ActorMessageSender from GateSessionActorId and sends it.\n\n// Get an ActorSenderComponent from Game.Scene, then get an ActorMessageSender by InstanceId\nActorSenderComponent actorSenderComponent = Game.Scene.GetComponent<ActorSenderComponent>();\nActorMessageSender actorMessageSender = actorSenderComponent.Get(unitGateComponent.GateSessionActorId);\n// send\nactorMessageSender.Send(message);\n\n// rpc\nvar response = actorMessageSender.Call(message);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nThe question is how do you know the InstanceId of the gate session in map? This is where you need to find a way to pass it on, for example in ET, when the player is logging in to gate, the gate session hooks up a mailbox MailBoxComponent, C2G_LoginGateHandler.cs\n\nsession.AddComponent<MailBoxComponent, string>(MailboxType.GateSession);\n\n\n1\n\n\nThe InstanceId of this gate session is brought into the map when the player logs into the map process, in C2G_EnterMapHandler.cs\n\nM2G_CreateUnit createUnit = (M2G_CreateUnit)await mapSession.Call(new G2M_CreateUnit() { PlayerId = player.Id, GateSessionId = session. InstanceId });\n\n\n1\n\n\n\n# Handling of Actor messages\n\nFirst, the message arrives at the MailboxComponent, which has a type, and different types of mailboxes can do different processing. Currently, there are two types of mailboxes, GateSession and MessageDispatcher; GateSession mailboxes will immediately forward messages to the client when they are received, and MessageDispatcher types will again distribute the Actor messages to the specific Handler for processing. The default MailboxComponent type is MessageDispatcher. customizing a mailbox type is also very simple, inherit the IMailboxHandler interface and add the MailboxHandler tag. So why do we need to add such a feature? This feature does not exist in other actor models, and messages are generally received and distributed. The reason is that GateSession is not designed for distribution, so I added the mailbox type here. messageDispatcher has two ways of handling messages, one is to handle the messages sent by the other party, and the other is rpc messages\n\n    // To handle Send messages, you need to inherit the AMActorHandler abstract class. The first generic parameter of the abstract class is the type of the Actor, and the second parameter is the type of the message\n\t[ActorMessageHandler(AppType.Map)]\n\tpublic class Actor_TestHandler : AMActorHandler<Unit, Actor_Test>\n\t{\n\t\tprotected override ETTask Run(Unit unit, Actor_Test message)\n\t\t{\n\t\t\tLog.Debug(message.Info);\n\t\t}\n\t}\n\n    // To handle Rpc messages, you need to inherit the AMActorRpcHandler abstract class, the first generic parameter of the abstract class is the type of the Actor, the second parameter is the type of the message, and the third parameter is the type of the returned message\n    [ActorMessageHandler(AppType.Map)]\n\tpublic class Actor_TransferHandler : AMActorRpcHandler<Unit, Actor_TransferRequest, Actor_TransferResponse>\n\t{\n\t\tprotected override async ETTask Run(Unit unit, Actor_TransferRequest message, Action<Actor_TransferResponse> reply)\n\t\t{\n\t\t\tActor_TransferResponse response = new Actor_TransferResponse();\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\treply(response);\n\t\t\t}\n\t\t\tcatch (Exception e)\n\t\t\t{\n\t\t\t\tReplyError(response, e, reply);\n\t\t\t}\n\t\t}\n\t}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\nWe should note that Actor messages have the potential to deadlock, such as A call to B, B call to C, and C call to A. Because MailboxComponent is essentially a message queue, it opens a concurrent process that will process one message at a time, returning ETTask to indicate that the message processing class will block MailboxComponent queue of other messages. So if there is a deadlock, we don't want a message processing to block the rest of the MailboxComponent messages, we can just open a new thread in the message processing class to handle it. For example:\n\n\t[ActorMessageHandler(AppType.Map)]\n\tpublic class Actor_TestHandler : AMActorHandler<Unit, Actor_Test>\n\t{\n\t\tprotected override ETTask Run(Unit unit, Actor_Test message)\n\t\t{\n\t\t\tRunAsync(unit, message).Coroutine();\n\t\t}\n\n        public ETVoid RunAsync(Unit unit, Actor_Test message)\n        {\n            Log.Debug(message.Info);\n        }\n\t}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nFor related information, you can Google the Actor deadlock problem.",normalizedContent:"# actor model\n\n\n# actor introduction\n\nbefore discussing the actor model, we should discuss the architecture of et. there are two architectures for game servers in order to use multi-core, single-threaded multi-process and single-process multi-threaded architecture. et uses single-threaded multi-process architecture, while the traditional actor model is generally single-process multi-threaded architecture, which is a major difference. the advantages and disadvantages are as follows.\n\n 1. the logic needs to be single-threaded this is the same, erlang process logic is single-threaded, skynet lua virtual machine is also single-threaded. et in a process is actually equivalent to an erlang process, a skynet lua virtual machine.\n 2. the use of single-threaded multi-process does not need to write their own set of profiler tools, you can use a lot of ready-made profiler tools, such as view memory, cpu occupation directly with top command, this point erlang and skynet need to get another set of tools.\n 3. multi-process single-threaded architecture also has a benefit, a single physical machine and multiple physical machines is no difference, single process multi-threaded also need to consider the processing of multiple physical machines.\n 4. multi-process single-threaded architecture is a bit of a drawback is that messages need to be serialized and deserialized across processes, taking up a bit of resources. in addition, sending network messages will have a few milliseconds delay. generally these effects can be ignored.\n\nthe original actor model is used for single-process multi-threaded architecture, there is a reason for this, because multi-threaded architecture developers can easily access shared variables at will, let's say a variable a, thread 1 can access, thread 2 can also access, so that both threads need to add locks when accessing the variable a, shared variables more locks everywhere, will become unmaintainable, the framework must not appear the framework must not have a situation where there are threads sharing variables everywhere. in order to ensure that the multi-threaded architecture does not go wrong, it is necessary to provide a development model that ensures easy and safe multi-threaded development. erlang's concurrency mechanism is the actor model. erlang virtual machine uses multiple threads to take advantage of multiple cores. erlang has designed a mechanism that designs its own processes on top of the virtual machine. at its simplest, each erlang process manages its own variables, and the logic of each erlang process runs on a single thread. the logic between the erlang process and the process is completely isolated, so that there are no two threads accessing the same variable and there is no multithreaded competition. the next question arises, since each erlang process has its own data and the logic is completely isolated, how should the two erlang processes communicate with each other? this is where the actor model comes in. erlang has designed a messaging mechanism: one process can send messages to other processes, and erlang processes communicate with each other through messages. isn't this the same message queue used by operating systems for inter-process communication? yes, in fact, it is similar. erlang inside the process id to get the process can send messages to this process.\n\nif the message is only sent to the process, it is still a bit inconvenient. for example, if you take an erlang process as a moba team process, and there are 10 players in the battle process, if you use erlang's actor message, the message can only be sent to the battle process, but often the message needs to be sent to a player, then erlang needs to distribute the message to the specific player again according to the player id in the message, so it actually goes around one more time. this is actually an extra detour.\n\n\n# et's actor\n\naccording to the characteristics of its own architecture, et does not completely copy the actor model of erlang, but provides the entity object-level actor model. in et, an actor is an entity object, and a mailboxcomponent component attached to an entity is an actor. you only need to know the entity's instanceid to send messages to the entity. in fact, erlang's actor model is a special case of et, such as giving the et server game.scene as an actor, so that it can become a process-level actor. it only needs to know the instanceid (et) or the pid (erlang) of the process to send it to the other party.\n\n| language | et | erlang | skynet | | | et | erlang | skynet | -- | :--: | :--: | :--: | | architecture | single-threaded multi-process | single-process multi-threaded | single-process multi-threaded | | actor | entity | erlang process | lua virtual machine | | actorid | entity.instanceid | erlang processid | service address |\n\n\n# use of et's actor\n\nfor a normal actor, we can refer to the gate session. map has a unit, and the unit holds the gate session corresponding to the player. thus, if a message in map needs to be sent to the client, it only needs to send the message to the gate session, and the gate session forwards it to the client when it receives the message. the map process sending messages to the gate session is a typical actor model. it doesn't need to know the location of the gate session, it just needs to know its instanceid. messagehelper.cs gets an actormessagesender from gatesessionactorid and sends it.\n\n// get an actorsendercomponent from game.scene, then get an actormessagesender by instanceid\nactorsendercomponent actorsendercomponent = game.scene.getcomponent<actorsendercomponent>();\nactormessagesender actormessagesender = actorsendercomponent.get(unitgatecomponent.gatesessionactorid);\n// send\nactormessagesender.send(message);\n\n// rpc\nvar response = actormessagesender.call(message);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nthe question is how do you know the instanceid of the gate session in map? this is where you need to find a way to pass it on, for example in et, when the player is logging in to gate, the gate session hooks up a mailbox mailboxcomponent, c2g_logingatehandler.cs\n\nsession.addcomponent<mailboxcomponent, string>(mailboxtype.gatesession);\n\n\n1\n\n\nthe instanceid of this gate session is brought into the map when the player logs into the map process, in c2g_entermaphandler.cs\n\nm2g_createunit createunit = (m2g_createunit)await mapsession.call(new g2m_createunit() { playerid = player.id, gatesessionid = session. instanceid });\n\n\n1\n\n\n\n# handling of actor messages\n\nfirst, the message arrives at the mailboxcomponent, which has a type, and different types of mailboxes can do different processing. currently, there are two types of mailboxes, gatesession and messagedispatcher; gatesession mailboxes will immediately forward messages to the client when they are received, and messagedispatcher types will again distribute the actor messages to the specific handler for processing. the default mailboxcomponent type is messagedispatcher. customizing a mailbox type is also very simple, inherit the imailboxhandler interface and add the mailboxhandler tag. so why do we need to add such a feature? this feature does not exist in other actor models, and messages are generally received and distributed. the reason is that gatesession is not designed for distribution, so i added the mailbox type here. messagedispatcher has two ways of handling messages, one is to handle the messages sent by the other party, and the other is rpc messages\n\n    // to handle send messages, you need to inherit the amactorhandler abstract class. the first generic parameter of the abstract class is the type of the actor, and the second parameter is the type of the message\n\t[actormessagehandler(apptype.map)]\n\tpublic class actor_testhandler : amactorhandler<unit, actor_test>\n\t{\n\t\tprotected override ettask run(unit unit, actor_test message)\n\t\t{\n\t\t\tlog.debug(message.info);\n\t\t}\n\t}\n\n    // to handle rpc messages, you need to inherit the amactorrpchandler abstract class, the first generic parameter of the abstract class is the type of the actor, the second parameter is the type of the message, and the third parameter is the type of the returned message\n    [actormessagehandler(apptype.map)]\n\tpublic class actor_transferhandler : amactorrpchandler<unit, actor_transferrequest, actor_transferresponse>\n\t{\n\t\tprotected override async ettask run(unit unit, actor_transferrequest message, action<actor_transferresponse> reply)\n\t\t{\n\t\t\tactor_transferresponse response = new actor_transferresponse();\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\treply(response);\n\t\t\t}\n\t\t\tcatch (exception e)\n\t\t\t{\n\t\t\t\treplyerror(response, e, reply);\n\t\t\t}\n\t\t}\n\t}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\nwe should note that actor messages have the potential to deadlock, such as a call to b, b call to c, and c call to a. because mailboxcomponent is essentially a message queue, it opens a concurrent process that will process one message at a time, returning ettask to indicate that the message processing class will block mailboxcomponent queue of other messages. so if there is a deadlock, we don't want a message processing to block the rest of the mailboxcomponent messages, we can just open a new thread in the message processing class to handle it. for example:\n\n\t[actormessagehandler(apptype.map)]\n\tpublic class actor_testhandler : amactorhandler<unit, actor_test>\n\t{\n\t\tprotected override ettask run(unit unit, actor_test message)\n\t\t{\n\t\t\trunasync(unit, message).coroutine();\n\t\t}\n\n        public etvoid runasync(unit unit, actor_test message)\n        {\n            log.debug(message.info);\n        }\n\t}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nfor related information, you can google the actor deadlock problem.",charsets:{cjk:!0},lastUpdated:"2022/07/25, 23:10:19",lastUpdatedTimestamp:1658761819e3},{title:"Actor Location-EN",frontmatter:{title:"Actor Location-EN",date:"2022-05-31T19:10:27.000Z",permalink:"/pages/d00821/"},regularPath:"/02.Guide/01.ETBook_English/55.5.5Actor%20Location-EN.html",relativePath:"02.Guide/01.ETBook_English/55.5.5Actor Location-EN.md",key:"v-0d66cacc",path:"/pages/d00821/",headers:[{level:3,title:"Actor Location",slug:"actor-location-2",normalizedTitle:"actor location",charIndex:2},{level:3,title:"Actor Location message processing",slug:"actor-location-message-processing",normalizedTitle:"actor location message processing",charIndex:4793},{level:3,title:"ET's actor and actor location analogy",slug:"et-s-actor-and-actor-location-analogy",normalizedTitle:"et's actor and actor location analogy",charIndex:6704}],headersStr:"Actor Location Actor Location message processing ET's actor and actor location analogy",content:"# Actor Location\n\n\n# Actor Location\n\nActor model only needs to know each other's InstanceId to send messages, which is very convenient, but sometimes we may not know each other's InstanceId, or an Actor's InstanceId will change. ET provides a mechanism to send messages to such objects, called Actor Location The mechanism is called Actor Location. The principle is relatively simple.\n\n 1.  because the InstanceId is changing, the object's Entity.Id is unchanged, so we can first think of using Entity.Id to send actor messages\n 2.  provide a location process (Location Server), the Actor object can store its Entity.Id and InstanceId as kv to the location process. Before sending the Actor message, go to the location process to look up the InstanceId of the Actor object before sending the actor message. 3.\n 3.  When an Actor object is created in a process or migrated to a new process, it needs to register its Id and InstanceId to the Location Server. 4.\n 4.  because the Actor object can be migrated, the message may be sent to the Actor has been migrated to other processes, so sending the Actor Location message needs to provide a reliable mechanism\n 5.  ActorLocationSender provides two methods, Send and Call, Send a message also requires the recipient to return a message, and only when the return message is received will the next message be sent. 6.\n 6.  If the Actor object is migrated away, it will return the error that the Actor does not exist, the sender will wait for 1 second after receiving this error, then go back to get the InstanceId of the Actor and resend it, currently it will try 5 times, after 5 times, it will throw an exception and report the error\n 7.  ActorLocationSender will not query the Location Server every time it sends a message, because object migration is relatively rare after all, only the first time to query, then cache the InstanceId, and re-query after the failure to send.\n 8.  actor object in the migration process, it is possible that other processes send over messages, when an error will occur, so the location server provides a Lock mechanism. Before the object is transmitted, the information in the process is deleted, and then a lock is added to the location server, and once the lock is on, other requests for the key will be queued.\n 9.  before transmission because the other party deleted the actor of the process, so other processes will fail to send, then they will retry. When retrying, they will re-request the location server, which will be found to be locked, so they will keep waiting.\n 10. When the transmission is completed, the lock on the location server is unlocked, and the new address is updated, and then other location requests are responded to. Other requests sent to this actor continue.\n\nNote that the Actor model is purely a server-side message communication mechanism, which has nothing to do with the client. We can use the server-side actor model for forwarding, so some client-side messages also inherit the actor interface. What happens if we don't use the actor interface on the client side? For example, the message Frame_ClickMap\n\nmessage Frame_ClickMap // IActorLocationMessage\n{\n\tint64 ActorId = 93;\n\tint64 Id = 94;\n\t\n\tfloat X = 1;\n\tfloat Y = 2;\n\tfloat Z = 3;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nWe may not need the field ActorId, the message is sent to Gate, gate sees that it is a Frame_ClickMap message, it needs to be forwarded to the Unit on the Map, forwarding is still good, gate can get the location of the unit corresponding to the map from the session, and then forward it, the problem comes, Frame_ ClickMap message to the map, how does the map know which object the message needs to be given to? There are several designs at this point.\n\n 1. bring the Id of the unit in the underlying protocol of forwarding, which requires more complex underlying protocol support.\n 2. use a message to Frame_ClickMap message wrapping, wrapping the message with the Id of the Unit, wrapping with the message means greater consumption, increasing GC. Personally, I feel that these two are very poor, not good, and even if distributed to the unit object processing, how to solve the problem of message re-entry it? unit object still needs to hang a message processing queue, and then receive the message thrown into the queue. Isn't this a duplication of the actor model? The current ET message sent to unit in the client did a design, the message into an actor message, gate received found to be an actor message, sent directly to the corresponding actor, the solution can be said to be beautiful. In fact, the client is still using session.send and call to send messages, send the message does not know that the message is an actor message, only to the gate, the gate judgment, refer to OuterMessageDispatcher.cs\n\n\n# Actor Location message processing\n\nActorLocation messages are sent\n\n// Get the ActorLocationSenderComponent from Game.Scene, then get the ActorLocationSender via Entity.Id\nActorLocationSender actorLocationSender = Game.Scene.GetComponent<ActorLocationSenderComponent>().Get(unitId);\n// Send the message through the ActorLocationSender\nactorLocationSender.Send(actorLocationMessage);\n// send the Rpc message\nIResponse response = await actorLocationSender.Call(actorLocationRequest);\n\n\n1\n2\n3\n4\n5\n6\n\n\nActorLocation message processing is almost the same as Actor messages, the difference is that the two abstract classes inherited are different, note that the abstract class of actorlocation has an additional Location\n\n\t// The first generic parameter of the abstract class is the type of the Actor, and the second parameter is the type of the message.\n\t[ActorMessageHandler(AppType.Map)]\n\tpublic class Frame_ClickMapHandler : AMActorLocationHandler<Unit, Frame_ClickMap>\n\t{\n\t\tprotected override ETTask Run(Unit unit, Frame_ClickMap message)\n\t\t{\n\t\t\tVector3 target = new Vector3(message.X, message.Y, message.Z);\n\t\t\tunit.GetComponent<UnitPathComponent>().MoveTo(target).Coroutine();\n\t\t\t\n\t\t}\n\t}\n\n\t// To handle Rpc messages, you need to inherit the AMActorRpcHandler abstract class. The first generic parameter of the abstract class is the type of the Actor, the second parameter is the type of the message, and the third parameter is the type of the returned message\n\t[ActorMessageHandler(AppType.Map)]\n\tpublic class C2M_TestActorRequestHandler : AMActorLocationRpcHandler<Unit, C2M_TestActorRequest, M2C_TestActorResponse>\n\t{\n\t\tprotected override async ETTask Run(Unit unit, C2M_TestActorRequest message, Action<M2C_TestActorResponse> reply)\n\t\t{\n\t\t\treply(new M2C_TestActorResponse(){Info = \"actor rpc response\"});\n\t\t\tawait ETTask.CompletedTask;\n\t\t}\n\t}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# ET's actor and actor location analogy\n\nThere are many cities (processes) in China, and many people (entity objects) living in the cities, each with an ID number (Entity.Id). A person needs to apply for a residence permit in each city and is assigned a unique residence permit number (InstanceId). The format of the residence permit number is 2 bytes city number + 4 bytes time + 2 bytes increment. The ID number never changes, but the residence permit number changes every time you go to a city. Now there is a China Post (actor). Suppose Xiaoming wants to send a letter to his girlfriend Xiaohong\n\n 1. Xiaohong must mount a mailbox (MailboxComponent) himself in order to receive the letter, and Xiaohong will process the message when he receives it. Note that processing is done here one by one. It is possible that Hong will receive letters from many people at the same time. But she must read one letter at a time. Let's say Xiaoming and Xiaobao both send letters to Xiaohong, and Xiaohong receives Xiaoming's letter first, and then Xiaobao's letter. Xiaohong reads Xiaoming's letter first, and Xiaoming's letter asks Xiaohong to make a phone call to her grandmother (to produce a concordance) and then write back to herself, noting that Xiaohong also cannot read the next letter during this period, and must finish the phone call before she can read Xiaobao's letter. Of course Xiao Hong himself can choose to start reading Xiao Bao's letter without finishing the process, by opening a new concatenation for Xiao Ming's letter.\n 2. Suppose Xiaoming knows Xiaohong's residence permit number, then the post (actor) can find the city (process) where Xiaohong lives according to the two docks of the residence permit number, and then find Xiaohong and deliver the message to Xiaohong's mailbox (MailboxComponent) according to Xiaohong's residence permit number. This is the simplest native actor model\n 3. ET also supports a set of actor location mechanism. Suppose Xiao Ming doesn't know Xiao Hong's residence permit number, but he knows Xiao Hong's ID number, what should he do? The postal service has developed a set of advanced post (actor location) to think of a way, if a person often moves, it still wants to receive letters, then he must report his residence permit and ID card to the central government (location server) when he goes to a new city, so that the advanced post can send mail through the ID card number. The method is to go to the central government to get Hong's residence permit number, and then use the actor mechanism to send. 4.\n 4. Suppose Xiao Hong was in Guangzhou city before, and Xiao Ming used Xiao Hong's ID card to send a letter to Xiao Hong. Advanced post obtains Xiao Hong's residence permit number and sends a letter to Xiao Hong. During this process of sending the letter, Xiaohong moved, from Guangzhou to Shenzhen, at which time Xiaohong reported her new residence permit on the central government. When the letter from the senior post arrives in Guangzhou, it is found that Xiao Hong is not in Guangzhou. Then the senior postal service will go to the central government again to get Xiao Hong's residence permit and resend it, which may succeed or fail again, this process will be repeated several times, if it is unsuccessful, it will tell Xiao Ming that the letter has failed to be sent.\n 5. senior postal mail is more expensive, and people do not move a lot, usually Xiao Ming will remember Xiao Hong's residence permit after sending letters with senior postal mail, and next time send letters directly with the residence permit, and then send letters with senior postal mail if it fails. There are two kinds of return receipts, one without content, just means Xiao Hong received the letter, and one with Xiao Hong's return letter. Xiaoming can choose which return receipt form to use when he sends the letter. Xiao Ming cannot send two letters to Xiao Hong at the same time, he must wait for Xiao Hong's acknowledgement to arrive before Xiao Ming can continue sending the letter.",normalizedContent:"# actor location\n\n\n# actor location\n\nactor model only needs to know each other's instanceid to send messages, which is very convenient, but sometimes we may not know each other's instanceid, or an actor's instanceid will change. et provides a mechanism to send messages to such objects, called actor location the mechanism is called actor location. the principle is relatively simple.\n\n 1.  because the instanceid is changing, the object's entity.id is unchanged, so we can first think of using entity.id to send actor messages\n 2.  provide a location process (location server), the actor object can store its entity.id and instanceid as kv to the location process. before sending the actor message, go to the location process to look up the instanceid of the actor object before sending the actor message. 3.\n 3.  when an actor object is created in a process or migrated to a new process, it needs to register its id and instanceid to the location server. 4.\n 4.  because the actor object can be migrated, the message may be sent to the actor has been migrated to other processes, so sending the actor location message needs to provide a reliable mechanism\n 5.  actorlocationsender provides two methods, send and call, send a message also requires the recipient to return a message, and only when the return message is received will the next message be sent. 6.\n 6.  if the actor object is migrated away, it will return the error that the actor does not exist, the sender will wait for 1 second after receiving this error, then go back to get the instanceid of the actor and resend it, currently it will try 5 times, after 5 times, it will throw an exception and report the error\n 7.  actorlocationsender will not query the location server every time it sends a message, because object migration is relatively rare after all, only the first time to query, then cache the instanceid, and re-query after the failure to send.\n 8.  actor object in the migration process, it is possible that other processes send over messages, when an error will occur, so the location server provides a lock mechanism. before the object is transmitted, the information in the process is deleted, and then a lock is added to the location server, and once the lock is on, other requests for the key will be queued.\n 9.  before transmission because the other party deleted the actor of the process, so other processes will fail to send, then they will retry. when retrying, they will re-request the location server, which will be found to be locked, so they will keep waiting.\n 10. when the transmission is completed, the lock on the location server is unlocked, and the new address is updated, and then other location requests are responded to. other requests sent to this actor continue.\n\nnote that the actor model is purely a server-side message communication mechanism, which has nothing to do with the client. we can use the server-side actor model for forwarding, so some client-side messages also inherit the actor interface. what happens if we don't use the actor interface on the client side? for example, the message frame_clickmap\n\nmessage frame_clickmap // iactorlocationmessage\n{\n\tint64 actorid = 93;\n\tint64 id = 94;\n\t\n\tfloat x = 1;\n\tfloat y = 2;\n\tfloat z = 3;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nwe may not need the field actorid, the message is sent to gate, gate sees that it is a frame_clickmap message, it needs to be forwarded to the unit on the map, forwarding is still good, gate can get the location of the unit corresponding to the map from the session, and then forward it, the problem comes, frame_ clickmap message to the map, how does the map know which object the message needs to be given to? there are several designs at this point.\n\n 1. bring the id of the unit in the underlying protocol of forwarding, which requires more complex underlying protocol support.\n 2. use a message to frame_clickmap message wrapping, wrapping the message with the id of the unit, wrapping with the message means greater consumption, increasing gc. personally, i feel that these two are very poor, not good, and even if distributed to the unit object processing, how to solve the problem of message re-entry it? unit object still needs to hang a message processing queue, and then receive the message thrown into the queue. isn't this a duplication of the actor model? the current et message sent to unit in the client did a design, the message into an actor message, gate received found to be an actor message, sent directly to the corresponding actor, the solution can be said to be beautiful. in fact, the client is still using session.send and call to send messages, send the message does not know that the message is an actor message, only to the gate, the gate judgment, refer to outermessagedispatcher.cs\n\n\n# actor location message processing\n\nactorlocation messages are sent\n\n// get the actorlocationsendercomponent from game.scene, then get the actorlocationsender via entity.id\nactorlocationsender actorlocationsender = game.scene.getcomponent<actorlocationsendercomponent>().get(unitid);\n// send the message through the actorlocationsender\nactorlocationsender.send(actorlocationmessage);\n// send the rpc message\niresponse response = await actorlocationsender.call(actorlocationrequest);\n\n\n1\n2\n3\n4\n5\n6\n\n\nactorlocation message processing is almost the same as actor messages, the difference is that the two abstract classes inherited are different, note that the abstract class of actorlocation has an additional location\n\n\t// the first generic parameter of the abstract class is the type of the actor, and the second parameter is the type of the message.\n\t[actormessagehandler(apptype.map)]\n\tpublic class frame_clickmaphandler : amactorlocationhandler<unit, frame_clickmap>\n\t{\n\t\tprotected override ettask run(unit unit, frame_clickmap message)\n\t\t{\n\t\t\tvector3 target = new vector3(message.x, message.y, message.z);\n\t\t\tunit.getcomponent<unitpathcomponent>().moveto(target).coroutine();\n\t\t\t\n\t\t}\n\t}\n\n\t// to handle rpc messages, you need to inherit the amactorrpchandler abstract class. the first generic parameter of the abstract class is the type of the actor, the second parameter is the type of the message, and the third parameter is the type of the returned message\n\t[actormessagehandler(apptype.map)]\n\tpublic class c2m_testactorrequesthandler : amactorlocationrpchandler<unit, c2m_testactorrequest, m2c_testactorresponse>\n\t{\n\t\tprotected override async ettask run(unit unit, c2m_testactorrequest message, action<m2c_testactorresponse> reply)\n\t\t{\n\t\t\treply(new m2c_testactorresponse(){info = \"actor rpc response\"});\n\t\t\tawait ettask.completedtask;\n\t\t}\n\t}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# et's actor and actor location analogy\n\nthere are many cities (processes) in china, and many people (entity objects) living in the cities, each with an id number (entity.id). a person needs to apply for a residence permit in each city and is assigned a unique residence permit number (instanceid). the format of the residence permit number is 2 bytes city number + 4 bytes time + 2 bytes increment. the id number never changes, but the residence permit number changes every time you go to a city. now there is a china post (actor). suppose xiaoming wants to send a letter to his girlfriend xiaohong\n\n 1. xiaohong must mount a mailbox (mailboxcomponent) himself in order to receive the letter, and xiaohong will process the message when he receives it. note that processing is done here one by one. it is possible that hong will receive letters from many people at the same time. but she must read one letter at a time. let's say xiaoming and xiaobao both send letters to xiaohong, and xiaohong receives xiaoming's letter first, and then xiaobao's letter. xiaohong reads xiaoming's letter first, and xiaoming's letter asks xiaohong to make a phone call to her grandmother (to produce a concordance) and then write back to herself, noting that xiaohong also cannot read the next letter during this period, and must finish the phone call before she can read xiaobao's letter. of course xiao hong himself can choose to start reading xiao bao's letter without finishing the process, by opening a new concatenation for xiao ming's letter.\n 2. suppose xiaoming knows xiaohong's residence permit number, then the post (actor) can find the city (process) where xiaohong lives according to the two docks of the residence permit number, and then find xiaohong and deliver the message to xiaohong's mailbox (mailboxcomponent) according to xiaohong's residence permit number. this is the simplest native actor model\n 3. et also supports a set of actor location mechanism. suppose xiao ming doesn't know xiao hong's residence permit number, but he knows xiao hong's id number, what should he do? the postal service has developed a set of advanced post (actor location) to think of a way, if a person often moves, it still wants to receive letters, then he must report his residence permit and id card to the central government (location server) when he goes to a new city, so that the advanced post can send mail through the id card number. the method is to go to the central government to get hong's residence permit number, and then use the actor mechanism to send. 4.\n 4. suppose xiao hong was in guangzhou city before, and xiao ming used xiao hong's id card to send a letter to xiao hong. advanced post obtains xiao hong's residence permit number and sends a letter to xiao hong. during this process of sending the letter, xiaohong moved, from guangzhou to shenzhen, at which time xiaohong reported her new residence permit on the central government. when the letter from the senior post arrives in guangzhou, it is found that xiao hong is not in guangzhou. then the senior postal service will go to the central government again to get xiao hong's residence permit and resend it, which may succeed or fail again, this process will be repeated several times, if it is unsuccessful, it will tell xiao ming that the letter has failed to be sent.\n 5. senior postal mail is more expensive, and people do not move a lot, usually xiao ming will remember xiao hong's residence permit after sending letters with senior postal mail, and next time send letters directly with the residence permit, and then send letters with senior postal mail if it fails. there are two kinds of return receipts, one without content, just means xiao hong received the letter, and one with xiao hong's return letter. xiaoming can choose which return receipt form to use when he sends the letter. xiao ming cannot send two letters to xiao hong at the same time, he must wait for xiao hong's acknowledgement to arrive before xiao ming can continue sending the letter.",charsets:{},lastUpdated:"2022/07/25, 23:10:19",lastUpdatedTimestamp:1658761819e3},{title:"Numerical component design",frontmatter:{title:"Numerical component design",date:"2022-05-31T19:10:27.000Z",permalink:"/pages/ae8fe0/"},regularPath:"/02.Guide/01.ETBook_English/56.5.6Numerical%20component%20design.html",relativePath:"02.Guide/01.ETBook_English/56.5.6Numerical component design.md",key:"v-0cd550e5",path:"/pages/ae8fe0/",headers:[{level:2,title:"Common practice:",slug:"common-practice",normalizedTitle:"common practice:",charIndex:804},{level:2,title:"ET framework uses the Key Value form to save the value of the property",slug:"et-framework-uses-the-key-value-form-to-save-the-value-of-the-property",normalizedTitle:"et framework uses the key value form to save the value of the property",charIndex:3650}],headersStr:"Common practice: ET framework uses the Key Value form to save the value of the property",content:"Similar to world of warcraft, moba such skills are extremely complex, flexibility requires a very high skill system, must need a set of its flexible numerical structure to match. Numerical structure is well designed, the realization of the skill system will be very simple, otherwise it is a disaster. For example, in World of Warcraft, a character has many numerical attributes, such as movement speed, strength, anger, energy, concentration value, magic value, blood, maximum blood, physical attack, physical defense, spell attack, spell defense, etc. There are dozens of attributes. Attributes and attributes affect each other, buffs will add absolute value to attributes, increase the percentage, or some kind of buff will come back to you after counting all the increased value and doubling it.\n\n\n# Common practice:\n\nThe general is to write a value class.\n\nclass Numeric\n{\n    public int Hp;\n    public int MaxHp;\n    public int Speed;\n    // Energy\n    public int Energy;\n    public int MaxEnergy;\n    // Magic\n    public int Mp;\n    public int MaxMp;\n    .....\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nOn second thought, I'm a thief using energy why should I have a value of Mp? I am a mage using magic why should there be a field for energy? I'm not sure what to do with this, just pretend you didn't see it? I can not, I come to an inheritance?\n\n// Mage values\ncalss MageNumeric: Numeric\n{\n    // magic\n    public int Mp;\n    public int MaxMp;\n}\n\n// Thief value\ncalss RougeNumeric: Numeric\n{\n    // Energy\n    public int Energy;\n    public int MaxEnergy;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n10 races, each race 7, 8 kinds of heroes, just these values class inheritance relationship, you have to be confused it. Object-oriented is difficult to adapt to the needs of this flexible and complex.\n\nAnd look at the Numeric class, each value can not just design a field, for example, I have a buff will increase 10 points Speed, and a kind of buff to increase 50% of the speed, then I must add at least three secondary attribute fields\n\nclass Numeric\n{\n    // speed final value\n    public int Speed;\n    // Speed initial value\n    public int SpeedInit;\n    // Speed increase value\n    public int SpeedAdd;\n    // Speed increase percentage value\n    public int SpeedPct;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nAfter SpeedAdd and SpeedPct are changed, a calculation is performed to calculate the final speed value. buff only needs to go to modify SpeedAdd and SpeedPct on the line.\n\nSpeed = (SpeedInit + SpeedAdd) * (100 + SpeedPct) / 100\n\n\n1\n\n\nEach property may have several indirect effects on the value, you can think about how large this class is, a rough estimate of more than 100 fields. The trouble is that the formula is basically the same, but just can not be unified into a function, such as MaxHp, also has a buff effect\n\nclass Numeric\n{\n    public int Speed;\n    public int SpeedInit;\n    public int SpeedAdd;\n    public int SpeedPct;\n    \n    public int MaxHp;\n    public int MaxHpInit;\n    public int MaxHpAdd;\n    public int MaxHpPct;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nAlso have to write a formula for calculating Hp\n\nMaxHp = (MaxHpInit + MaxHpAdd) * (100 + MaxHpPct) / 100\n\n\n1\n\n\nDozens of properties, you have to write dozens of times, and each secondary property changes to correctly call the corresponding formula calculation. Very troublesome! This design also has a big problem, buff configuration table to fill the corresponding attribute field is not very good to fill, for example, sprint buff (increase speed 50%), how to configure the buff table to make the program simple to find and operate the SpeedPct field? Not a good idea.\n\n\n# ET framework uses the Key Value form to save the value of the property\n\nUsing System.Collections.Generic;\n\nGeneric; namespace Model\nGeneric; namespace Model {\n    public enum NumericType\n    {\n\t\tMax = 10000,\n\n\t\tSpeed = 1000,\n\t\tSpeedBase = Speed * 10 + 1,\n\t    SpeedAdd = Speed * 10 + 2,\n\t    SpeedPct = Speed * 10 + 3,\n\t    SpeedFinalAdd = Speed * 10 + 4,\n\t    SpeedFinalPct = Speed * 10 + 5,\n\n\t    Hp = 1001,\n\t    HpBase = Hp * 10 + 1,\n\n\t    MaxHp = 1002,\n\t    MaxHpBase = MaxHp * 10 + 1,\n\t    MaxHpAdd = MaxHp * 10 + 2,\n\t    MaxHpPct = MaxHp * 10 + 3,\n\t    MaxHpFinalAdd = MaxHp * 10 + 4,\n\t\tMaxHpFinalPct = MaxHp * 10 + 5,\n\t}\n\n\tpublic class NumericComponent: Component\n\t{\n\t\tpublic readonly Dictionary<int, int> NumericDic = new Dictionary<int, int>();\n\n\t\tpublic void Awake()\n\t\t{\n\t\t\t// initialize base value here\n\t\t}\n\n\t\tpublic float GetAsFloat(NumericType numericType)\n\t\t{\n\t\t\treturn (float)GetByKey((int)numericType) / 10000;\n\t\t}\n\n\t\tpublic int GetAsInt(NumericType numericType)\n\t\t{\n\t\t\treturn GetByKey((int)numericType);\n\t\t}\n\n\t\tpublic void Set(NumericType nt, float value)\n\t\t{\n\t\t\tthis[nt] = (int) (value * 10000);\n\t\t}\n\n\t\tpublic void Set(NumericType nt, int value)\n\t\t{\n\t\t\tthis[nt] = value;\n\t\t}\n\n\t\tpublic int this[NumericType numericType]\n\t\t{\n\t\t\tget\n\t\t\t{\n\t\t\t\treturn this.GetByKey((int) numericType);\n\t\t\t}\n\t\t\tset\n\t\t\t{\n\t\t\t\tint v = this.GetByKey((int) numericType);\n\t\t\t\tif (v == value)\n\t\t\t\t{\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tNumericDic[(int)numericType] = value;\n\n\t\t\t\tUpdate(numericType);\n\t\t\t}\n\t\t}\n\n\t\tprivate int GetByKey(int key)\n\t\t{\n\t\t\tint value = 0;\n\t\t\tThis.NumericDic.TryGetValue(key, out value);\n\t\t\treturn value;\n\t\t}\n\n\t\tpublic void Update(NumericType numericType)\n\t\t{\n\t\t\tif (numericType > NumericType.Max)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint final = (int) numericType / 10;\n\t\t\tint bas = final * 10 + 1; \n\t\t\tint add = final * 10 + 2;\n\t\t\tint pct = final * 10 + 3;\n\t\t\tint finalAdd = final * 10 + 4;\n\t\t\tint finalPct = final * 10 + 5;\n\n\t\t\t// A value may be affected by a variety of circumstances, such as speed, adding a buff may increase the speed of the absolute value of 100, but also some buffs increase the speed of 10%, so a value can be controlled by 5 values of the final result\n\t\t\t// final = (((base + add) * (100 + pct) / 100) + finalAdd) * (100 + finalPct) / 100;\n\t\t\tthis.NumericDic[final] = ((this.GetByKey(base) + this.GetByKey(add)) * (100 + this.GetByKey(pct)) / 100 + this.GetByKey(finalAdd)) * (100 + this. GetByKey(finalPct)) / 100;\n\t\t\tGame.EventSystem.Run(EventIdType.NumbericChange, this.Entity.Id, numericType, final);\n\t\t}\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n\n\n 1. values are saved with key value, key is the type of value, defined by NumericType, value are integers, float type can also be converted to integers, for example, multiply by 1000; key value to save properties will become very flexible, for example, mage no energy properties, then initialize the mage object does not add energy key value It's fine. Thieves do not have mana, no spell damage, etc., the initialization will not need to add these.\n\n 2. world of warcraft, a value by 5 values to influence, you can unify the use of a formula.\n\nfinal = (((base + add) * (100 + pct) / 100) + finalAdd) * (100 + finalPct) / 100;\n\n\n1\n\n\nFor example, the speed value speed, there is an initial value speedbase, there is a buff1 to increase the absolute speed by 10 points, then buff1 will add 10 to speedadd when it is created, buff1 minus 10 to speedadd when it is deleted, buff2 increases the speed by 20%, then buff2 adds to speedpct when it is created The 5 values are changed and the corresponding properties can be recalculated by using the Update function in a unified way. buff configuration is quite simple. If the corresponding NumericType is filled in the buff configuration, the program can easily manipulate the corresponding value.\n\n 3. Changes in properties can be uniformly thrown to other modules to subscribe to the event, writing a property change monitor becomes very simple. For example, the achievement module needs to develop an achievement life value over 1000, will get the achievement of longevity master. Then the person developing the achievement module will subscribe to the HP changes as follows.\n\n\t/// Monitor hp value changes\n\t[NumericWatcher(NumericType.Hp)\n\tpublic class NumericWatcher_Hp : INumericWatcher\n\t{\n\t\tpublic void Run(long id, int value)\n\t\t{\n\t\t    if (value > 1000)\n\t\t    {\n\t\t        // get achievement longevity master achievement\n\t\t    }\n\t\t}\n\t}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nSimilarly, recording an exception log for a gold change greater than 10,000 at a time, etc. can be done this way.\n\nWith this numerical component, a moba skill system can be said to be half complete.",normalizedContent:"similar to world of warcraft, moba such skills are extremely complex, flexibility requires a very high skill system, must need a set of its flexible numerical structure to match. numerical structure is well designed, the realization of the skill system will be very simple, otherwise it is a disaster. for example, in world of warcraft, a character has many numerical attributes, such as movement speed, strength, anger, energy, concentration value, magic value, blood, maximum blood, physical attack, physical defense, spell attack, spell defense, etc. there are dozens of attributes. attributes and attributes affect each other, buffs will add absolute value to attributes, increase the percentage, or some kind of buff will come back to you after counting all the increased value and doubling it.\n\n\n# common practice:\n\nthe general is to write a value class.\n\nclass numeric\n{\n    public int hp;\n    public int maxhp;\n    public int speed;\n    // energy\n    public int energy;\n    public int maxenergy;\n    // magic\n    public int mp;\n    public int maxmp;\n    .....\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\non second thought, i'm a thief using energy why should i have a value of mp? i am a mage using magic why should there be a field for energy? i'm not sure what to do with this, just pretend you didn't see it? i can not, i come to an inheritance?\n\n// mage values\ncalss magenumeric: numeric\n{\n    // magic\n    public int mp;\n    public int maxmp;\n}\n\n// thief value\ncalss rougenumeric: numeric\n{\n    // energy\n    public int energy;\n    public int maxenergy;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n10 races, each race 7, 8 kinds of heroes, just these values class inheritance relationship, you have to be confused it. object-oriented is difficult to adapt to the needs of this flexible and complex.\n\nand look at the numeric class, each value can not just design a field, for example, i have a buff will increase 10 points speed, and a kind of buff to increase 50% of the speed, then i must add at least three secondary attribute fields\n\nclass numeric\n{\n    // speed final value\n    public int speed;\n    // speed initial value\n    public int speedinit;\n    // speed increase value\n    public int speedadd;\n    // speed increase percentage value\n    public int speedpct;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nafter speedadd and speedpct are changed, a calculation is performed to calculate the final speed value. buff only needs to go to modify speedadd and speedpct on the line.\n\nspeed = (speedinit + speedadd) * (100 + speedpct) / 100\n\n\n1\n\n\neach property may have several indirect effects on the value, you can think about how large this class is, a rough estimate of more than 100 fields. the trouble is that the formula is basically the same, but just can not be unified into a function, such as maxhp, also has a buff effect\n\nclass numeric\n{\n    public int speed;\n    public int speedinit;\n    public int speedadd;\n    public int speedpct;\n    \n    public int maxhp;\n    public int maxhpinit;\n    public int maxhpadd;\n    public int maxhppct;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nalso have to write a formula for calculating hp\n\nmaxhp = (maxhpinit + maxhpadd) * (100 + maxhppct) / 100\n\n\n1\n\n\ndozens of properties, you have to write dozens of times, and each secondary property changes to correctly call the corresponding formula calculation. very troublesome! this design also has a big problem, buff configuration table to fill the corresponding attribute field is not very good to fill, for example, sprint buff (increase speed 50%), how to configure the buff table to make the program simple to find and operate the speedpct field? not a good idea.\n\n\n# et framework uses the key value form to save the value of the property\n\nusing system.collections.generic;\n\ngeneric; namespace model\ngeneric; namespace model {\n    public enum numerictype\n    {\n\t\tmax = 10000,\n\n\t\tspeed = 1000,\n\t\tspeedbase = speed * 10 + 1,\n\t    speedadd = speed * 10 + 2,\n\t    speedpct = speed * 10 + 3,\n\t    speedfinaladd = speed * 10 + 4,\n\t    speedfinalpct = speed * 10 + 5,\n\n\t    hp = 1001,\n\t    hpbase = hp * 10 + 1,\n\n\t    maxhp = 1002,\n\t    maxhpbase = maxhp * 10 + 1,\n\t    maxhpadd = maxhp * 10 + 2,\n\t    maxhppct = maxhp * 10 + 3,\n\t    maxhpfinaladd = maxhp * 10 + 4,\n\t\tmaxhpfinalpct = maxhp * 10 + 5,\n\t}\n\n\tpublic class numericcomponent: component\n\t{\n\t\tpublic readonly dictionary<int, int> numericdic = new dictionary<int, int>();\n\n\t\tpublic void awake()\n\t\t{\n\t\t\t// initialize base value here\n\t\t}\n\n\t\tpublic float getasfloat(numerictype numerictype)\n\t\t{\n\t\t\treturn (float)getbykey((int)numerictype) / 10000;\n\t\t}\n\n\t\tpublic int getasint(numerictype numerictype)\n\t\t{\n\t\t\treturn getbykey((int)numerictype);\n\t\t}\n\n\t\tpublic void set(numerictype nt, float value)\n\t\t{\n\t\t\tthis[nt] = (int) (value * 10000);\n\t\t}\n\n\t\tpublic void set(numerictype nt, int value)\n\t\t{\n\t\t\tthis[nt] = value;\n\t\t}\n\n\t\tpublic int this[numerictype numerictype]\n\t\t{\n\t\t\tget\n\t\t\t{\n\t\t\t\treturn this.getbykey((int) numerictype);\n\t\t\t}\n\t\t\tset\n\t\t\t{\n\t\t\t\tint v = this.getbykey((int) numerictype);\n\t\t\t\tif (v == value)\n\t\t\t\t{\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tnumericdic[(int)numerictype] = value;\n\n\t\t\t\tupdate(numerictype);\n\t\t\t}\n\t\t}\n\n\t\tprivate int getbykey(int key)\n\t\t{\n\t\t\tint value = 0;\n\t\t\tthis.numericdic.trygetvalue(key, out value);\n\t\t\treturn value;\n\t\t}\n\n\t\tpublic void update(numerictype numerictype)\n\t\t{\n\t\t\tif (numerictype > numerictype.max)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint final = (int) numerictype / 10;\n\t\t\tint bas = final * 10 + 1; \n\t\t\tint add = final * 10 + 2;\n\t\t\tint pct = final * 10 + 3;\n\t\t\tint finaladd = final * 10 + 4;\n\t\t\tint finalpct = final * 10 + 5;\n\n\t\t\t// a value may be affected by a variety of circumstances, such as speed, adding a buff may increase the speed of the absolute value of 100, but also some buffs increase the speed of 10%, so a value can be controlled by 5 values of the final result\n\t\t\t// final = (((base + add) * (100 + pct) / 100) + finaladd) * (100 + finalpct) / 100;\n\t\t\tthis.numericdic[final] = ((this.getbykey(base) + this.getbykey(add)) * (100 + this.getbykey(pct)) / 100 + this.getbykey(finaladd)) * (100 + this. getbykey(finalpct)) / 100;\n\t\t\tgame.eventsystem.run(eventidtype.numbericchange, this.entity.id, numerictype, final);\n\t\t}\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n\n\n 1. values are saved with key value, key is the type of value, defined by numerictype, value are integers, float type can also be converted to integers, for example, multiply by 1000; key value to save properties will become very flexible, for example, mage no energy properties, then initialize the mage object does not add energy key value it's fine. thieves do not have mana, no spell damage, etc., the initialization will not need to add these.\n\n 2. world of warcraft, a value by 5 values to influence, you can unify the use of a formula.\n\nfinal = (((base + add) * (100 + pct) / 100) + finaladd) * (100 + finalpct) / 100;\n\n\n1\n\n\nfor example, the speed value speed, there is an initial value speedbase, there is a buff1 to increase the absolute speed by 10 points, then buff1 will add 10 to speedadd when it is created, buff1 minus 10 to speedadd when it is deleted, buff2 increases the speed by 20%, then buff2 adds to speedpct when it is created the 5 values are changed and the corresponding properties can be recalculated by using the update function in a unified way. buff configuration is quite simple. if the corresponding numerictype is filled in the buff configuration, the program can easily manipulate the corresponding value.\n\n 3. changes in properties can be uniformly thrown to other modules to subscribe to the event, writing a property change monitor becomes very simple. for example, the achievement module needs to develop an achievement life value over 1000, will get the achievement of longevity master. then the person developing the achievement module will subscribe to the hp changes as follows.\n\n\t/// monitor hp value changes\n\t[numericwatcher(numerictype.hp)\n\tpublic class numericwatcher_hp : inumericwatcher\n\t{\n\t\tpublic void run(long id, int value)\n\t\t{\n\t\t    if (value > 1000)\n\t\t    {\n\t\t        // get achievement longevity master achievement\n\t\t    }\n\t\t}\n\t}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nsimilarly, recording an exception log for a gold change greater than 10,000 at a time, etc. can be done this way.\n\nwith this numerical component, a moba skill system can be said to be half complete.",charsets:{},lastUpdated:"2022/07/25, 23:10:19",lastUpdatedTimestamp:1658761819e3},{title:"AI Framwork",frontmatter:{title:"AI Framwork",date:"2022-05-31T19:10:27.000Z",permalink:"/pages/58cf5c/"},regularPath:"/02.Guide/01.ETBook_English/61.6.1.AI%20Framwork.html",relativePath:"02.Guide/01.ETBook_English/61.6.1.AI Framwork.md",key:"v-4d16eb48",path:"/pages/58cf5c/",headers:[{level:2,title:"1. Several AI designs",slug:"_1-several-ai-designs",normalizedTitle:"1. several ai designs",charIndex:19},{level:3,title:"a. State machine",slug:"a-state-machine",normalizedTitle:"a. state machine",charIndex:254},{level:3,title:"b. Behavior tree",slug:"b-behavior-tree",normalizedTitle:"b. behavior tree",charIndex:1690},{level:2,title:"2. my approach",slug:"_2-my-approach",normalizedTitle:"2. my approach",charIndex:2855}],headersStr:"1. Several AI designs a. State machine b. Behavior tree 2. my approach",content:"# AI framework\n\n\n# 1. Several AI designs\n\nAI in the game a lot, but why do people always feel ai writing up very difficult, I later thought about it, the main reason is the use of improper methods. Before people write ai mainly have several options.\n\n\n# a. State machine\n\nI do not know who came up with this approach, really powerless to complain. Originally any data on the object is the state, this method and to define some state into a new kind of node, the object on the state change will cause the conversion between nodes, the implementation of the corresponding method, such as OnEnter OnExit and so on. Here is an example of a monster, monsters can be divided into a variety of states, patrol, attack, chase, return. The state changes of the monster are:\n\nPatrol->Chase Patrol state found a distant enemy to chase state\nPatrol->Attack Patrol find enemy can be attacked to attack state\nAttack->Chase The attack state finds an enemy in the distance and goes after it.\nAttack->Return Attack state find the enemy is too far to return state\nchase->return chase state found too far from the enemy to return to the state\n\nThere are so many state transitions that it's hard to find out if I've missed them here. Once there are more nodes, any two nodes may need to be connected, and it will become a super complex mesh structure, the complexity is the square of N, and it is very difficult to maintain. In order to solve the problem of complex mesh structure and then upgraded to a hierarchical state machine and so on. Of course, various patching methods still do not solve the essential problem. It is not your problem to use bad state machines, it is the problem of state machines.\n\n\n# b. Behavior tree\n\nThe ai of the behavior tree is responsive ai, the tree from top to bottom (or from left to right execution, here from top to bottom for example) is actually the action node ranked a priority, the action above the first to determine whether to meet the conditions, meet the implementation. We won't go into details here. The complexity of the behavior tree is N, greatly simplified than the state machine, but there are still many defects, ai too complex when the tree will become very large, and difficult to reconfigure. For example, in our own project, we want to make a robot ai similar to a human, automatically do tasks, fight monsters, play the system in the game, chat with people, and even attack others. Imagine how complex this tree will become! Another drawback of the behavior tree is that some action nodes are a persistent process, that is to say, a concurrent process, behavior tree management up concurrent process is not very good, such as the above example, need to move to the target side, this move is made into a concurrent process it, or every frame move it? This is a difficult problem, how to do it is not comfortable.\n\n\n# 2. my approach\n\nWhat is ai? Very simple, ai is constantly based on the current state, perform the appropriate behavior. Remember these two sentences, it is important, this is the essence of ai! These two sentences are divided into two parts, one is the state judgment, the second is the execution of behavior. State judgment is well understood, what is the behavior? Take the above example of the monster state machine, the behavior of the monster is Patrol, attack the enemy, return to the patrol point. For example.\n\nPatrol (when the monster is within the patrol range, there is no enemy around, choose the next patrol point, move)\nattack the enemy (when the monster found within the guard range of the enemy, if the attack distance enough to attack, not enough to move over to attack)\nReturn (when the monster found more than a certain distance from the birth point, plus the invincibility buff, move to the birth point, to the birth point, remove the invincibility buff)\n\nUnlike the state machine, these three state changes do not care about what the last state is, only about whether the current conditions are met, meet the implementation of the behavior. Behavior may be able to perform instantly, but also may be a continuous process, such as patrol, choose the next patrol point to move over, go to a point and then choose a point, and so on and so forth. For example, attacking the enemy, may need to move to the target to attack.\n\nHow to design this ai framework? Here it is very simple, abstract ai nodes, each node contains a conditional judgment, with the implementation of behavior. The behavior method should be a concurrent process\n\npublic class AINode\n{\n\tpublic virtual bool Check(Unit unit) // test whether the condition is met\n\t{\t\t\n\t}\n\n\tpublic virtual ETTask Run(Unit unit)\n\t{\t\t\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nThinking further, if the monster is on patrol and finds an enemy, then the monster should interrupt the current patrol and go on to perform the act of attacking the enemy instead. So our behavior should need to support being interrupted, which means that the behavior concurrent should support cancellation, and this is especially important to note that any concurrent in the behavior Run method should support the cancellation operation!\n\npublic class AINode\n{\n\tpublic virtual bool Check(Unit unit)\n\t{\t\t\n\t}\n\n\tpublic virtual ETVoid Run(Unit unit, ETCancelToken cancelToken)\n\t{\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nImplement three ai nodes XunLuoNode(patrol) GongjiNode(attack) FanHuiNode(return)\n\npublic class XunLuoNode: AINode\n{\n\tpublic virtual bool Check(Unit unit)\n\t{\n\t\tif (not in patrol range)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (there are enemies around)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic virtual ETVoid Run(Unit unit, ETCancelToken cancelToken)\n\t{\n\t\twhile (true)\n\t\t{\n\t\t\tVector3 nextPoint = FindNextPoint();\n\t\t\tbool ret = await MoveToAsync(nextPoint, cancelToken); // move to the target point, return false means the process is canceled\n\t\t\tif (!ret)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// stay for two seconds, note that any concurrent process must be able to be cancelled here\n\t\t\tWait(2000, cancelToken). bool ret = await TimeComponent;\n\t\t\tif (!ret)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\nThe same can be achieved for the other two nodes. It's not enough to design the nodes, you also need to string the nodes together so that the ai can rotate\n\nAINode[] aiNodes = {xunLuoNode, gongjiNode, fanHuiNode};\nAINode current;\nETCancelToken cancelToken;\nwhile(true)\n{\n\t// Every second you need to re-determine if the new behavior is satisfied, this time can be set by yourself\n\tawait TimeComponent.Instance.Wait(1000);\n\n\tAINode next;\n\tforeach(var node in aiNodes)\n\t{\n\t\tif (node.Check())\n\t\t{\n\t\t\tnext = node;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (next == null)\n\t{\n\t\tcontinue;\n\t}\n\n\t// If the next node is the same as the current one, then it is not executed\n\tif (next == current)\n\t{\n\t\tcontinue;\n\t}\n\n\t// Stop the current concurrent process\n\tcancelToken.Cancel();\n\n\t// Execute the next concurrent process\n\tcancelToken = new ETCancelToken();\n\tnext.Run(unit, cancelToken).Coroutine();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\nThis code is very simple, meaning that it iterates through the nodes every second until it finds a node that satisfies the conditions and then executes it, waiting for the next second to determine, before executing the next node, interrupting the currently executing concurrent process. A few misconceptions about the use:\n\n 1. behavior if there is a concurrent process must be able to cancel, and pass in cancelToken, otherwise something will go wrong, because once the monster meets the execution of the next node, you need to cancel the current concurrent process.\n 2. different from the behavior tree and state machine, the role of the node is only a piece of logic, the node does not need to share. Shared is the concurrent methods, such as MoveToAsync, monster patrol node can be used, the monster attack enemy node in pursuit of the enemy can also be used.\n 3. nodes can do very large, such as automatically do the task node, move to the npc, pick up the task, according to the task of subtasks to do subtasks, such as moving to the monster point to fight monsters, move to the collection of things to collect, etc., after doing all the subtasks, move to the task npc to turn in the task. All of this is written in a while loop, using a concurrent string.\n\nThinking about a big question, how do you design a piezo bot? What does a piezo bot need to do? Automatically do tasks, automatically play various systems, automatically attack enemies, will counterattack, will find people to chat, etc.. Just make an ai node for each of the above mentioned. Brothers, AI simple or not?",normalizedContent:"# ai framework\n\n\n# 1. several ai designs\n\nai in the game a lot, but why do people always feel ai writing up very difficult, i later thought about it, the main reason is the use of improper methods. before people write ai mainly have several options.\n\n\n# a. state machine\n\ni do not know who came up with this approach, really powerless to complain. originally any data on the object is the state, this method and to define some state into a new kind of node, the object on the state change will cause the conversion between nodes, the implementation of the corresponding method, such as onenter onexit and so on. here is an example of a monster, monsters can be divided into a variety of states, patrol, attack, chase, return. the state changes of the monster are:\n\npatrol->chase patrol state found a distant enemy to chase state\npatrol->attack patrol find enemy can be attacked to attack state\nattack->chase the attack state finds an enemy in the distance and goes after it.\nattack->return attack state find the enemy is too far to return state\nchase->return chase state found too far from the enemy to return to the state\n\nthere are so many state transitions that it's hard to find out if i've missed them here. once there are more nodes, any two nodes may need to be connected, and it will become a super complex mesh structure, the complexity is the square of n, and it is very difficult to maintain. in order to solve the problem of complex mesh structure and then upgraded to a hierarchical state machine and so on. of course, various patching methods still do not solve the essential problem. it is not your problem to use bad state machines, it is the problem of state machines.\n\n\n# b. behavior tree\n\nthe ai of the behavior tree is responsive ai, the tree from top to bottom (or from left to right execution, here from top to bottom for example) is actually the action node ranked a priority, the action above the first to determine whether to meet the conditions, meet the implementation. we won't go into details here. the complexity of the behavior tree is n, greatly simplified than the state machine, but there are still many defects, ai too complex when the tree will become very large, and difficult to reconfigure. for example, in our own project, we want to make a robot ai similar to a human, automatically do tasks, fight monsters, play the system in the game, chat with people, and even attack others. imagine how complex this tree will become! another drawback of the behavior tree is that some action nodes are a persistent process, that is to say, a concurrent process, behavior tree management up concurrent process is not very good, such as the above example, need to move to the target side, this move is made into a concurrent process it, or every frame move it? this is a difficult problem, how to do it is not comfortable.\n\n\n# 2. my approach\n\nwhat is ai? very simple, ai is constantly based on the current state, perform the appropriate behavior. remember these two sentences, it is important, this is the essence of ai! these two sentences are divided into two parts, one is the state judgment, the second is the execution of behavior. state judgment is well understood, what is the behavior? take the above example of the monster state machine, the behavior of the monster is patrol, attack the enemy, return to the patrol point. for example.\n\npatrol (when the monster is within the patrol range, there is no enemy around, choose the next patrol point, move)\nattack the enemy (when the monster found within the guard range of the enemy, if the attack distance enough to attack, not enough to move over to attack)\nreturn (when the monster found more than a certain distance from the birth point, plus the invincibility buff, move to the birth point, to the birth point, remove the invincibility buff)\n\nunlike the state machine, these three state changes do not care about what the last state is, only about whether the current conditions are met, meet the implementation of the behavior. behavior may be able to perform instantly, but also may be a continuous process, such as patrol, choose the next patrol point to move over, go to a point and then choose a point, and so on and so forth. for example, attacking the enemy, may need to move to the target to attack.\n\nhow to design this ai framework? here it is very simple, abstract ai nodes, each node contains a conditional judgment, with the implementation of behavior. the behavior method should be a concurrent process\n\npublic class ainode\n{\n\tpublic virtual bool check(unit unit) // test whether the condition is met\n\t{\t\t\n\t}\n\n\tpublic virtual ettask run(unit unit)\n\t{\t\t\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nthinking further, if the monster is on patrol and finds an enemy, then the monster should interrupt the current patrol and go on to perform the act of attacking the enemy instead. so our behavior should need to support being interrupted, which means that the behavior concurrent should support cancellation, and this is especially important to note that any concurrent in the behavior run method should support the cancellation operation!\n\npublic class ainode\n{\n\tpublic virtual bool check(unit unit)\n\t{\t\t\n\t}\n\n\tpublic virtual etvoid run(unit unit, etcanceltoken canceltoken)\n\t{\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nimplement three ai nodes xunluonode(patrol) gongjinode(attack) fanhuinode(return)\n\npublic class xunluonode: ainode\n{\n\tpublic virtual bool check(unit unit)\n\t{\n\t\tif (not in patrol range)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (there are enemies around)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic virtual etvoid run(unit unit, etcanceltoken canceltoken)\n\t{\n\t\twhile (true)\n\t\t{\n\t\t\tvector3 nextpoint = findnextpoint();\n\t\t\tbool ret = await movetoasync(nextpoint, canceltoken); // move to the target point, return false means the process is canceled\n\t\t\tif (!ret)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// stay for two seconds, note that any concurrent process must be able to be cancelled here\n\t\t\twait(2000, canceltoken). bool ret = await timecomponent;\n\t\t\tif (!ret)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\nthe same can be achieved for the other two nodes. it's not enough to design the nodes, you also need to string the nodes together so that the ai can rotate\n\nainode[] ainodes = {xunluonode, gongjinode, fanhuinode};\nainode current;\netcanceltoken canceltoken;\nwhile(true)\n{\n\t// every second you need to re-determine if the new behavior is satisfied, this time can be set by yourself\n\tawait timecomponent.instance.wait(1000);\n\n\tainode next;\n\tforeach(var node in ainodes)\n\t{\n\t\tif (node.check())\n\t\t{\n\t\t\tnext = node;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (next == null)\n\t{\n\t\tcontinue;\n\t}\n\n\t// if the next node is the same as the current one, then it is not executed\n\tif (next == current)\n\t{\n\t\tcontinue;\n\t}\n\n\t// stop the current concurrent process\n\tcanceltoken.cancel();\n\n\t// execute the next concurrent process\n\tcanceltoken = new etcanceltoken();\n\tnext.run(unit, canceltoken).coroutine();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\nthis code is very simple, meaning that it iterates through the nodes every second until it finds a node that satisfies the conditions and then executes it, waiting for the next second to determine, before executing the next node, interrupting the currently executing concurrent process. a few misconceptions about the use:\n\n 1. behavior if there is a concurrent process must be able to cancel, and pass in canceltoken, otherwise something will go wrong, because once the monster meets the execution of the next node, you need to cancel the current concurrent process.\n 2. different from the behavior tree and state machine, the role of the node is only a piece of logic, the node does not need to share. shared is the concurrent methods, such as movetoasync, monster patrol node can be used, the monster attack enemy node in pursuit of the enemy can also be used.\n 3. nodes can do very large, such as automatically do the task node, move to the npc, pick up the task, according to the task of subtasks to do subtasks, such as moving to the monster point to fight monsters, move to the collection of things to collect, etc., after doing all the subtasks, move to the task npc to turn in the task. all of this is written in a while loop, using a concurrent string.\n\nthinking about a big question, how do you design a piezo bot? what does a piezo bot need to do? automatically do tasks, automatically play various systems, automatically attack enemies, will counterattack, will find people to chat, etc.. just make an ai node for each of the above mentioned. brothers, ai simple or not?",charsets:{},lastUpdated:"2022/07/25, 23:10:19",lastUpdatedTimestamp:1658761819e3},{title:"test2",frontmatter:{title:"test2",date:"2022-07-26T09:52:17.000Z",permalink:"/pages/b70448/"},regularPath:"/02.Guide/01.ETBook_English/98.test2.html",relativePath:"02.Guide/01.ETBook_English/98.test2.md",key:"v-708b622a",path:"/pages/b70448/",headersStr:null,content:"zzzz http://etgame.cn/pages/8643c5/",normalizedContent:"zzzz http://etgame.cn/pages/8643c5/",charsets:{},lastUpdated:"2022/07/26, 00:34:47",lastUpdatedTimestamp:1658766887e3},{title:"test",frontmatter:{title:"test",author:{name:"小弟",href:"https://www.yuque.com/et-xd/docs"},date:"2022-07-26T00:42:02.000Z",permalink:"/pages/578b97/"},regularPath:"/02.Guide/01.ETBook_English/99.test.html",relativePath:"02.Guide/01.ETBook_English/99.test.md",key:"v-8d136732",path:"/pages/578b97/",headersStr:null,content:"Test!~\n\nTest!~Test!~Test!~Test!~Test!~",normalizedContent:"test!~\n\ntest!~test!~test!~test!~test!~",charsets:{},lastUpdated:"2022/07/26, 00:34:47",lastUpdatedTimestamp:1658766887e3},{title:"Todo",frontmatter:{permalink:"/doc/todo",date:"2022-07-26T11:30:11.000Z",title:"Todo"},regularPath:"/30.%E6%96%87%E6%A1%A3/01.Todo.html",relativePath:"30.文档/01.Todo.md",key:"v-96f85bb2",path:"/doc/todo/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/07/26, 13:09:23",lastUpdatedTimestamp:1658812163e3},{title:"Todo",frontmatter:{permalink:"/doc/todo_en",title:"Todo",date:"2022-07-26T11:30:55.000Z"},regularPath:"/31.Doc/01.Todo.html",relativePath:"31.Doc/01.Todo.md",key:"v-5b320bc2",path:"/doc/todo_en/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/07/26, 13:09:23",lastUpdatedTimestamp:1658812163e3},{title:"文档仓库提交说明",frontmatter:{title:"文档仓库提交说明",author:{name:"小弟",href:"https://www.yuque.com/et-xd/docs"},date:"2022-07-26T01:03:04.000Z",permalink:"/doc/notes/"},regularPath:"/99.%E6%96%87%E6%A1%A3%E7%BC%96%E5%86%99/01.%E6%96%87%E6%A1%A3%E4%BB%93%E5%BA%93%E6%8F%90%E4%BA%A4%E8%AF%B4%E6%98%8E.html",relativePath:"99.文档编写/01.文档仓库提交说明.md",key:"v-4ec77c26",path:"/doc/notes/",headers:[{level:2,title:"写作流程",slug:"写作流程",normalizedTitle:"写作流程",charIndex:2},{level:2,title:"文档存放目录",slug:"文档存放目录",normalizedTitle:"文档存放目录",charIndex:424},{level:2,title:"目录级别说明",slug:"目录级别说明",normalizedTitle:"目录级别说明",charIndex:649},{level:3,title:"一级目录",slug:"一级目录",normalizedTitle:"一级目录",charIndex:778},{level:3,title:"二级/三级目录",slug:"二级-三级目录",normalizedTitle:"二级/三级目录",charIndex:1650},{level:3,title:"四级目录",slug:"四级目录",normalizedTitle:"四级目录",charIndex:1011},{level:2,title:"文件的front matter (重要)",slug:"文件的front-matter-重要",normalizedTitle:"文件的front matter (重要)",charIndex:1741},{level:2,title:"工具",slug:"工具",normalizedTitle:"工具",charIndex:2101},{level:2,title:"Markdown相关",slug:"markdown相关",normalizedTitle:"markdown相关",charIndex:2166},{level:3,title:"目录标题",slug:"目录标题",normalizedTitle:"目录标题",charIndex:2181},{level:3,title:"代码片段",slug:"代码片段",normalizedTitle:"代码片段",charIndex:2330},{level:3,title:"图片",slug:"图片",normalizedTitle:"图片",charIndex:2453},{level:3,title:"文本高亮",slug:"文本高亮",normalizedTitle:"文本高亮",charIndex:2539},{level:3,title:"内置标记",slug:"内置标记",normalizedTitle:"内置标记",charIndex:2580},{level:3,title:"外部标记",slug:"外部标记",normalizedTitle:"外部标记",charIndex:2652},{level:3,title:"折叠列表",slug:"折叠列表",normalizedTitle:"折叠列表",charIndex:2727},{level:3,title:"思维导图 & 流程图",slug:"思维导图-流程图",normalizedTitle:"思维导图 &amp; 流程图",charIndex:null},{level:2,title:"更多格式技巧",slug:"更多格式技巧",normalizedTitle:"更多格式技巧",charIndex:3057}],headersStr:"写作流程 文档存放目录 目录级别说明 一级目录 二级/三级目录 四级目录 文件的front matter (重要) 工具 Markdown相关 目录标题 代码片段 图片 文本高亮 内置标记 外部标记 折叠列表 思维导图 & 流程图 更多格式技巧",content:'# 写作流程\n\n 1. 首先是创建.md文件，如果在结构化目录下则需要添加相应的序号\n 2. 如果你想手动指定文章的分类、标签，则需要在头部front matter填写相应的字段。\n 3. 文章内部标题以二级标题(## 二级标题) 开始\n 4. 最后，就可以正式开始写作啦。\n    * 在github博客源码仓库相应的文章目录下，新建.md文件，编辑好文章并提交后会触发GitHub Actions自动部署。\n\nfront matter模板\n\n---\ntitle: 标题\ndate: 2022-7-26 11:24:31\npermalink: /xxx/xxxx/\ncategories:\n  - 分类1\n  - 分类2\ntags:\n  - 标签1\ntitleTag: 原创\nauthor:\n name: 作者\n link: https://xxx.com\n---\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 文档存放目录\n\n存于ET-homepage/tree/main/docs对应文件夹下\n\n无论是文件还是文件夹，请为其名称添加上正确的正整数序号和.，从00或01开始累计，如01.文件夹、02.文件.md\n\n> 序号只是用于决定先后顺序，并不一定需要连着，如01、02、03...，实际工作中可能会在两个文章中间插入一篇新的文章，因此为了方便可以采用间隔序号10、20、30...，后面如果需要在10和20中间插入一篇新文章，可以给定序号15\n\n\n# 目录级别说明\n\n.\n├── docs\n│   │  (不参与数据生成)\n│   ├── .vuepress\n│   ├── @pages\n│   ├── index.md\n│   │\n│   │ (以下部分参与数据生成)\n│   ├── 《xx教程》专栏 (一级目录)\n│   │   ├── 01.章节1 (二级目录)\n│   │   |   ├── 01.js1.md (三级目录-文件)\n│   │   |   ├── 02.js2.md\n│   │   |   └── 03.js3.md\n│   │   └── 02.章节2 (二级目录)\n│   │   |   ├── 01.jsa.md\n│   │   |   ├── 02.小节 (三级目录)\n│   │   |   |   └── 01.jsxx.md (四级目录-文件)\n│   ├── 01.前端\n│   │   ├── 01.JavaScript\n│   │   |   ├── 01.js1.md\n│   │   |   ├── 02.js2.md\n│   │   |   └── 03.js3.md\n│   │   └── 02.vue\n│   │   |   ├── 01.vue1.md\n│   │   |   └── 02.vue2.md\n│   ├── 02.其他\n│   │   ├── 01.学习\n│   │   |   ├── 01.xxa.md\n│   │   |   └── 02.xxb.md\n│   │   ├── 02.学习笔记\n│   │   |   ├── 01.xxa.md\n│   │   |   └── 02.xxb.md\n│   │   ├── 03.文件x.md\n│   │   └── 04.文件xx.md\n│   └── 03.关于我\n│   │   └── 01.关于我.md\n.   .\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n\n# 一级目录\n\n * .vuepress、@pages、_posts、index.md 或 README.md 这些文件(文件夹)不参与数据生成。\n * 序号非必须。\n\n\n# 二级/三级目录\n\n * 该级别下可以同时放文件夹和.md文件，但是两者序号要连贯。\n * 必须有序号\n\n\n# 四级目录\n\n * 该级别下只能放.md文件。\n * 必须有序号\n\n\n# 文件的front matter (重要)\n\n添加在md文件的开头\n\n * [必要] permalink 永久链接，如果不标注永久链接，下次生成文档地址就会变化\n\n---\npermalink: /xxx/xxxx/\n---\n\n\n1\n2\n3\n\n\n标准模板\n\n---\ntitle: 标题\ndate: 2022-7-26 11:24:31\npermalink: /A/a1/\ncategories:\n  - 分类1\n  - 分类2\ntags:\n  - 标签1\ntitleTag: 原创\nsidebar: auto \narticle: false\nauthor:\n name: 作者\n link: https://xxx.com\n---\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 工具\n\nlocal_deploy.sh 本地测试, 运行后访问 http://localhost:8080/ 可预览效果\n\n\n# Markdown相关\n\n\n# 目录标题\n\n * Markdown 文件的一级标题(# 一级标题) 实际显示的文章标题是取自front matter中的title，然后把.md中的一级标题隐藏了。\n * Markdown 文件的 二级至六级 标题会被提取到侧边目录栏\n * 文章内部标题以二级标题(## 二级标题) 开始\n\n\n# 代码片段\n\n    ```csharp\n    Console.WriteLine("Hello, World!");\n    ```\n\n\n1\n2\n3\n\n\nConsole.WriteLine("Hello, World!");\n\n\n1\n\n\n\n# 图片\n\n图片目录放于docs/.vuepress/public/img\n\n![图片](../.vuepress/public/img/bg.jpg)\n\n\n1\n\n\n\n\n\n# 文本高亮\n\n<mark>高亮</mark> 文本\n\n\n1\n\n\n高亮 文本\n\n\n# 内置标记\n\n<Badge text="beta" type="warning"/>\n<Badge text="标记"/>\n\n\n1\n2\n\n\n\n# 外部标记\n\n\n\n![star](https://img.shields.io/github/stars/egametang/ET)\n\n\n1\n\n\n\n# 折叠列表\n\n点击查看\n\n折叠内容\n\n::: details\n折叠内容\n:::\n\n\n1\n2\n3\n\n\n\n# 思维导图 & 流程图\n\n 1. 使用Markmap (opens new window)生成思维导图html文件\n 2. 将html文件放在docs/.vuepress/public/markmap/\n 3. 通过<iframe>插入到Markdown\n\n<iframe :src="$withBase(\'/markmap/01.html\')" width="100%" height="400" frameborder="0" scrolling="No" leftmargin="0" topmargin="0"></iframe>\n\n\n1\n\n\n\n# 更多格式技巧\n\nMarkdown 拓展\n\nMarkdown 容器\n\n如何让你的笔记更有表现力',normalizedContent:'# 写作流程\n\n 1. 首先是创建.md文件，如果在结构化目录下则需要添加相应的序号\n 2. 如果你想手动指定文章的分类、标签，则需要在头部front matter填写相应的字段。\n 3. 文章内部标题以二级标题(## 二级标题) 开始\n 4. 最后，就可以正式开始写作啦。\n    * 在github博客源码仓库相应的文章目录下，新建.md文件，编辑好文章并提交后会触发github actions自动部署。\n\nfront matter模板\n\n---\ntitle: 标题\ndate: 2022-7-26 11:24:31\npermalink: /xxx/xxxx/\ncategories:\n  - 分类1\n  - 分类2\ntags:\n  - 标签1\ntitletag: 原创\nauthor:\n name: 作者\n link: https://xxx.com\n---\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 文档存放目录\n\n存于et-homepage/tree/main/docs对应文件夹下\n\n无论是文件还是文件夹，请为其名称添加上正确的正整数序号和.，从00或01开始累计，如01.文件夹、02.文件.md\n\n> 序号只是用于决定先后顺序，并不一定需要连着，如01、02、03...，实际工作中可能会在两个文章中间插入一篇新的文章，因此为了方便可以采用间隔序号10、20、30...，后面如果需要在10和20中间插入一篇新文章，可以给定序号15\n\n\n# 目录级别说明\n\n.\n├── docs\n│   │  (不参与数据生成)\n│   ├── .vuepress\n│   ├── @pages\n│   ├── index.md\n│   │\n│   │ (以下部分参与数据生成)\n│   ├── 《xx教程》专栏 (一级目录)\n│   │   ├── 01.章节1 (二级目录)\n│   │   |   ├── 01.js1.md (三级目录-文件)\n│   │   |   ├── 02.js2.md\n│   │   |   └── 03.js3.md\n│   │   └── 02.章节2 (二级目录)\n│   │   |   ├── 01.jsa.md\n│   │   |   ├── 02.小节 (三级目录)\n│   │   |   |   └── 01.jsxx.md (四级目录-文件)\n│   ├── 01.前端\n│   │   ├── 01.javascript\n│   │   |   ├── 01.js1.md\n│   │   |   ├── 02.js2.md\n│   │   |   └── 03.js3.md\n│   │   └── 02.vue\n│   │   |   ├── 01.vue1.md\n│   │   |   └── 02.vue2.md\n│   ├── 02.其他\n│   │   ├── 01.学习\n│   │   |   ├── 01.xxa.md\n│   │   |   └── 02.xxb.md\n│   │   ├── 02.学习笔记\n│   │   |   ├── 01.xxa.md\n│   │   |   └── 02.xxb.md\n│   │   ├── 03.文件x.md\n│   │   └── 04.文件xx.md\n│   └── 03.关于我\n│   │   └── 01.关于我.md\n.   .\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n\n# 一级目录\n\n * .vuepress、@pages、_posts、index.md 或 readme.md 这些文件(文件夹)不参与数据生成。\n * 序号非必须。\n\n\n# 二级/三级目录\n\n * 该级别下可以同时放文件夹和.md文件，但是两者序号要连贯。\n * 必须有序号\n\n\n# 四级目录\n\n * 该级别下只能放.md文件。\n * 必须有序号\n\n\n# 文件的front matter (重要)\n\n添加在md文件的开头\n\n * [必要] permalink 永久链接，如果不标注永久链接，下次生成文档地址就会变化\n\n---\npermalink: /xxx/xxxx/\n---\n\n\n1\n2\n3\n\n\n标准模板\n\n---\ntitle: 标题\ndate: 2022-7-26 11:24:31\npermalink: /a/a1/\ncategories:\n  - 分类1\n  - 分类2\ntags:\n  - 标签1\ntitletag: 原创\nsidebar: auto \narticle: false\nauthor:\n name: 作者\n link: https://xxx.com\n---\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 工具\n\nlocal_deploy.sh 本地测试, 运行后访问 http://localhost:8080/ 可预览效果\n\n\n# markdown相关\n\n\n# 目录标题\n\n * markdown 文件的一级标题(# 一级标题) 实际显示的文章标题是取自front matter中的title，然后把.md中的一级标题隐藏了。\n * markdown 文件的 二级至六级 标题会被提取到侧边目录栏\n * 文章内部标题以二级标题(## 二级标题) 开始\n\n\n# 代码片段\n\n    ```csharp\n    console.writeline("hello, world!");\n    ```\n\n\n1\n2\n3\n\n\nconsole.writeline("hello, world!");\n\n\n1\n\n\n\n# 图片\n\n图片目录放于docs/.vuepress/public/img\n\n![图片](../.vuepress/public/img/bg.jpg)\n\n\n1\n\n\n\n\n\n# 文本高亮\n\n<mark>高亮</mark> 文本\n\n\n1\n\n\n高亮 文本\n\n\n# 内置标记\n\n<badge text="beta" type="warning"/>\n<badge text="标记"/>\n\n\n1\n2\n\n\n\n# 外部标记\n\n\n\n![star](https://img.shields.io/github/stars/egametang/et)\n\n\n1\n\n\n\n# 折叠列表\n\n点击查看\n\n折叠内容\n\n::: details\n折叠内容\n:::\n\n\n1\n2\n3\n\n\n\n# 思维导图 & 流程图\n\n 1. 使用markmap (opens new window)生成思维导图html文件\n 2. 将html文件放在docs/.vuepress/public/markmap/\n 3. 通过<iframe>插入到markdown\n\n<iframe :src="$withbase(\'/markmap/01.html\')" width="100%" height="400" frameborder="0" scrolling="no" leftmargin="0" topmargin="0"></iframe>\n\n\n1\n\n\n\n# 更多格式技巧\n\nmarkdown 拓展\n\nmarkdown 容器\n\n如何让你的笔记更有表现力',charsets:{cjk:!0},lastUpdated:"2022/07/26, 13:09:23",lastUpdatedTimestamp:1658812163e3},{title:"博客文章",frontmatter:{archivesPage:!0,title:"博客文章",permalink:"/blog/",article:!1},regularPath:"/@pages/archivesPage.html",relativePath:"@pages/archivesPage.md",key:"v-36c869aa",path:"/blog/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/07/25, 23:10:19",lastUpdatedTimestamp:1658761819e3},{title:"Home",frontmatter:{home:!0,heroImage:"/img/logo1.png",heroText:"ET",tagline:"ET是一个开源的游戏客户端(基于Unity)服务端双端框架",actionText:"开始使用 👉",actionLink:"/pages/a2f161/",bannerBg:"none",features:[{title:"ETTask",details:"“ETTask就是ET的灵魂！整个ET架构在ETTask跟协程锁上。”"},{title:"协程锁",details:"“ETTask 、协程锁和ETtask.WaitAll这三个是一套组合拳，威力无穷，完全解决了所有服务端分布式开发中的回调难题。写逻辑再也不用callback了”"},{title:"EventSystem",details:"“ET框架的逻辑就是由各种事件来驱动的。”"},{title:"MongoBson",details:"“MongoBson做消息跟配置序列化，搭配数据库简直完美。内存，消息，配置，数据库，ET6是完全统一的序列化，非常方便。”"},{title:"热重载",details:"客户端服务端均可热重载，开发不用重启客户端服务端即可修改逻辑代码，开发极其方便"},{title:"机器人框架",details:"“什么叫前后端共享代码的生产力，直接使用客户端代码创建机器人。逻辑跟表现分离，机器人程序直接共享利用客户端的逻辑层代码做压测，只需要极少代码即可做出机器人，方便压测服务端”"},{title:"内外网kcp网络",details:"性能强劲，搭配软路由模块，可以防各种网络攻击"},{title:"AI框架-行为机",details:"行为机是我发明的一个词，对应状态机，看了之后保证，写ai比写ui还简单"},{title:"数值组件",details:"一套极其灵活的数值结构"}],postList:"none"},regularPath:"/",relativePath:"index.md",key:"v-7d4c8dc4",path:"/",headers:[{level:2,title:"🎉上新推荐",slug:"🎉上新推荐",normalizedTitle:"🎉上新推荐",charIndex:15},{level:2,title:"⚡️未来...",slug:"⚡️未来",normalizedTitle:"⚡️未来...",charIndex:59},{level:2,title:"⚡ 反馈与交流",slug:"⚡-反馈与交流",normalizedTitle:"⚡ 反馈与交流",charIndex:84}],headersStr:"🎉上新推荐 ⚡️未来... ⚡ 反馈与交流",content:"给项目点个⭐\n\n\n\n\n\n\n# 🎉上新推荐\n\n * v6.0：更新记录 ...\n\n更多上新请查阅：更新日志\n\n\n\n# ⚡️未来...\n\n提示\n\n持续关注吧~\n\n\n\n# ⚡ 反馈与交流\n\n在使用过程中有任何问题和想法，请提 Issue。 你也可以在Issue查看别人提的问题和给出解决方案。\n\n或者加入我们的交流群：474643097",normalizedContent:"给项目点个⭐\n\n\n\n\n\n\n# 🎉上新推荐\n\n * v6.0：更新记录 ...\n\n更多上新请查阅：更新日志\n\n\n\n# ⚡️未来...\n\n提示\n\n持续关注吧~\n\n\n\n# ⚡ 反馈与交流\n\n在使用过程中有任何问题和想法，请提 issue。 你也可以在issue查看别人提的问题和给出解决方案。\n\n或者加入我们的交流群：474643097",charsets:{cjk:!0},lastUpdated:"2022/07/25, 23:10:19",lastUpdatedTimestamp:1658761819e3}],themeConfig:{nav:[{text:"首页",link:"/"},{text:"指南",link:"",items:[{text:"指南",link:"/pages/a2f161/"},{text:"Guide",link:"/pages/1e1b9a/"},{text:"提交文档",link:"/doc/notes/"}]},{text:"论坛",link:"https://et-framework.cn"},{text:"💖ET-Github",link:"https://github.com/egametang/ET"}],sidebarDepth:2,logo:"/img/logo1.png",searchMaxSuggestions:10,lastUpdated:"上次更新",repo:"zxt385189207/ET-homepage",docsBranch:"main",docsDir:"docs",editLinks:!0,editLinkText:"在Github上编辑此页面!",sidebar:{"/01.指南/":[{title:"ETBbook_中文",collapsable:!1,children:[["01.ETBbook_中文/01.介绍.md","介绍","/pages/a2f161"],["01.ETBbook_中文/02.1.1运行指南.md","运行指南","/pages/52d5c3"],["01.ETBbook_中文/03.目录结构.md","目录结构","/pages/ff62ec/"],["01.ETBbook_中文/12.1.2为什么使用.net core.md","1.2为什么使用.net core","/pages/f62a4d/"],["01.ETBbook_中文/21.2.1CSharp的协程.md","2.1CSharp的协程","/pages/500d39/"],["01.ETBbook_中文/22.2.2更好的协程.md","2.2更好的协程","/pages/0f0a88/"],["01.ETBbook_中文/23.2.3单线程异步.md","2.3单线程异步","/pages/d3ef38/"],["01.ETBbook_中文/32.3.2强大的MongoBson库.md","3.2强大的MongoBson库","/pages/037ea6/"],["01.ETBbook_中文/33.3.3一切皆组件.md","3.3一切皆组件","/pages/81bdb3/"],["01.ETBbook_中文/34.3.3一切皆实体.md","3.3一切皆实体","/pages/c77b6a/"],["01.ETBbook_中文/35.3.4事件机制EventSystem.md","3.4事件机制EventSystem","/pages/e49330/"],["01.ETBbook_中文/41.4.1组件式设计.md","4.1组件式设计","/pages/002c9b/"],["01.ETBbook_中文/54.5.4Actor模型.md","5.4Actor模型","/pages/96869e/"],["01.ETBbook_中文/55.5.5Actor Location-ZH.md","5.5Actor Location-ZH","/pages/9f7296/"],["01.ETBbook_中文/56.5.6数值组件设计.md","5.6数值组件设计","/pages/1dc51a/"],["01.ETBbook_中文/61.6.1AI框架.md","6.1AI框架","/pages/d9bb29/"]]}],catalogue:{},"/02.Guide/":[{title:"ETBook_English",collapsable:!1,children:[["01.ETBook_English/02.1.1RunGuide.md","RunGuide","/pages/1e1b9a/"],["01.ETBook_English/12.1.2Why use .net core.md","Why use .net core","/pages/f9f601/"],["01.ETBook_English/21.2.1CSharp Coroutine.md","CSharp Coroutine","/pages/97d2cf/"],["01.ETBook_English/22.2.2Better Coroutine.md","Better Coroutine","/pages/e03bce/"],["01.ETBook_English/23.2.3Single-threaded asynchronous.md","Single-threaded asynchronous","/pages/735741/"],["01.ETBook_English/32.3.2The powerful MongoBson library.md","The powerful MongoBson library","/pages/947d76/"],["01.ETBook_English/33.3.3Everything is Entity.md","Everything is Entity","/pages/b631b2/"],["01.ETBook_English/35.3.4EventSystem.md","EventSystem","/pages/53296b/"],["01.ETBook_English/41.4.1Component-based design.md","Component-based design","/pages/66fec6/"],["01.ETBook_English/54.5.4Actor Model.md","Actor Model","/pages/a3279e/"],["01.ETBook_English/55.5.5Actor Location-EN.md","Actor Location-EN","/pages/d00821/"],["01.ETBook_English/56.5.6Numerical component design.md","Numerical component design","/pages/ae8fe0/"],["01.ETBook_English/61.6.1.AI Framwork.md","AI Framwork","/pages/58cf5c/"],["01.ETBook_English/98.test2.md","test2","/pages/b70448/"],["01.ETBook_English/99.test.md","test","/pages/578b97/"]]}],"/30.文档/":[["01.Todo.md","Todo","/doc/todo"]],"/31.Doc/":[["01.Todo.md","Todo","/doc/todo_en"]],"/99.文档编写/":[["01.文档仓库提交说明.md","文档仓库提交说明","/doc/notes/"]]},updateBar:{showToArticle:!1},category:!1,tag:!1,author:{name:"熊猫",href:"https://github.com/egametang/ET"},social:{icons:[{iconClass:"icon-youjian",title:"发邮件",link:"mailto:385189207@qq.com"},{iconClass:"icon-github",title:"GitHub",link:"https://github.com/egametang/ET"}]},footer:{createYear:2022,copyrightInfo:"d | MIT License"},htmlModules:{}}};var wc=t(92),kc=t(93),xc=t(11);var Tc={computed:{$filterPosts(){return this.$site.pages.filter(n=>{const{frontmatter:{pageComponent:e,article:t,home:o}}=n;return!(e||!1===t||!0===o)})},$sortPosts(){return(n=this.$filterPosts).sort((n,e)=>{const t=n.frontmatter.sticky,o=e.frontmatter.sticky;return t&&o?t==o?Object(xc.a)(n,e):t-o:t&&!o?-1:!t&&o?1:Object(xc.a)(n,e)}),n;var n},$sortPostsByDate(){return(n=this.$filterPosts).sort((n,e)=>Object(xc.a)(n,e)),n;var n},$groupPosts(){return function(n){const e={},t={};for(let o=0,a=n.length;o<a;o++){const{frontmatter:{categories:a,tags:i}}=n[o];"array"===Object(xc.n)(a)&&a.forEach(t=>{t&&(e[t]||(e[t]=[]),e[t].push(n[o]))}),"array"===Object(xc.n)(i)&&i.forEach(e=>{e&&(t[e]||(t[e]=[]),t[e].push(n[o]))})}return{categories:e,tags:t}}(this.$sortPosts)},$categoriesAndTags(){return function(n){const e=[],t=[];for(let t in n.categories)e.push({key:t,length:n.categories[t].length});for(let e in n.tags)t.push({key:e,length:n.tags[e].length});return{categories:e,tags:t}}(this.$groupPosts)}}};Ft.component(wc.default),Ft.component(kc.default);function _c(n){return n.toString().padStart(2,"0")}t(235);Ft.component("Badge",()=>Promise.all([t.e(0),t.e(3)]).then(t.bind(null,350))),Ft.component("CodeBlock",()=>Promise.resolve().then(t.bind(null,92))),Ft.component("CodeGroup",()=>Promise.resolve().then(t.bind(null,93)));t(236);var Cc=[({Vue:n,options:e,router:t,siteData:o,isServer:a})=>{a||t.afterEach(()=>{var n;n=function(){setTimeout((function(){void 0===window._AdBlockInit&&function(){const n=document.getElementsByClassName("wwads-cn"),e=document.querySelector(".wwads-content");n[0]&&!e&&(n[0].innerHTML="<style>.wwads-horizontal,.wwads-vertical{background-color:#f4f8fa;padding:5px;min-height:120px;margin-top:20px;box-sizing:border-box;border-radius:3px;font-family:sans-serif;display:flex;min-width:150px;position:relative;overflow:hidden;}.wwads-horizontal{flex-wrap:wrap;justify-content:center}.wwads-vertical{flex-direction:column;align-items:center;padding-bottom:32px}.wwads-horizontal a,.wwads-vertical a{text-decoration:none}.wwads-horizontal .wwads-img,.wwads-vertical .wwads-img{margin:5px}.wwads-horizontal .wwads-content,.wwads-vertical .wwads-content{margin:5px}.wwads-horizontal .wwads-content{flex:130px}.wwads-vertical .wwads-content{margin-top:10px}.wwads-horizontal .wwads-text,.wwads-content .wwads-text{font-size:14px;line-height:1.4;color:#0e1011;-webkit-font-smoothing:antialiased}.wwads-horizontal .wwads-poweredby,.wwads-vertical .wwads-poweredby{display:block;font-size:11px;color:#a6b7bf;margin-top:1em}.wwads-vertical .wwads-poweredby{position:absolute;left:10px;bottom:10px}.wwads-horizontal .wwads-poweredby span,.wwads-vertical .wwads-poweredby span{transition:all 0.2s ease-in-out;margin-left:-1em}.wwads-horizontal .wwads-poweredby span:first-child,.wwads-vertical .wwads-poweredby span:first-child{opacity:0}.wwads-horizontal:hover .wwads-poweredby span,.wwads-vertical:hover .wwads-poweredby span{opacity:1;margin-left:0}.wwads-horizontal .wwads-hide,.wwads-vertical .wwads-hide{position:absolute;right:-23px;bottom:-23px;width:46px;height:46px;border-radius:23px;transition:all 0.3s ease-in-out;cursor:pointer;}.wwads-horizontal .wwads-hide:hover,.wwads-vertical .wwads-hide:hover{background:rgb(0 0 0 /0.05)}.wwads-horizontal .wwads-hide svg,.wwads-vertical .wwads-hide svg{position:absolute;left:10px;top:10px;fill:#a6b7bf}.wwads-horizontal .wwads-hide:hover svg,.wwads-vertical .wwads-hide:hover svg{fill:#3E4546}</style><a href='https://wwads.cn/page/whitelist-wwads' class='wwads-img' target='_blank' rel='nofollow'><img src='https://cdn.jsdelivr.net/gh/xugaoyi/image_store@master/blog/wwads.2a3pidhlh4ys.webp' width='130'></a><div class='wwads-content'><a href='https://wwads.cn/page/whitelist-wwads' class='wwads-text' target='_blank' rel='nofollow'>为了本站的长期运营，请将我们的网站加入广告拦截器的白名单，感谢您的支持！<span style='color: #11a8cd'>如何添加白名单?</span></a><a href='https://wwads.cn/page/end-user-privacy' class='wwads-poweredby' title='万维广告 ～ 让广告更优雅，且有用' target='_blank'><span>万维</span><span>广告</span></a></div><a class='wwads-hide' onclick='parentNode.remove()' title='隐藏广告'><svg xmlns='http://www.w3.org/2000/svg' width='6' height='7'><path d='M.879.672L3 2.793 5.121.672a.5.5 0 11.707.707L3.708 3.5l2.12 2.121a.5.5 0 11-.707.707l-2.12-2.12-2.122 2.12a.5.5 0 11-.707-.707l2.121-2.12L.172 1.378A.5.5 0 01.879.672z'></path></svg></a>")}()}),3e3)},"complete"===document.readyState||"interactive"===document.readyState?setTimeout(n,1):document.addEventListener("DOMContentLoaded",n),setTimeout(()=>{const n=document.querySelector(".page-ad");if(!n)return;const e=n.querySelector(".wwads-hide");e&&(e.onclick=()=>{n.style.display="none"}),"none"===n.style.display&&(n.style.display="flex")},900)})},({Vue:n,options:e,router:t,siteData:o})=>{o.pages.map(n=>{const{frontmatter:{date:e,author:t}}=n;"string"==typeof e&&"Z"===e.charAt(e.length-1)&&(n.frontmatter.date=function(n){n instanceof Date||(n=new Date(n));return`${n.getUTCFullYear()}-${_c(n.getUTCMonth()+1)}-${_c(n.getUTCDate())} ${_c(n.getUTCHours())}:${_c(n.getUTCMinutes())}:${_c(n.getUTCSeconds())}`}(e)),t?n.author=t:o.themeConfig.author&&(n.author=o.themeConfig.author)}),n.mixin(Tc)},{},({Vue:n})=>{n.mixin({computed:{$dataBlock(){return this.$options.__data__block__}}})},{},{},({router:n})=>{"undefined"!=typeof window&&(window._hmt=window._hmt||[],function(){var n=document.createElement("script");n.src="https://hm.baidu.com/hm.js?01293bffa6c3962016c08ba685c79d78";var e=document.getElementsByTagName("script")[0];e.parentNode.insertBefore(n,e)}(),n.afterEach((function(n){_hmt.push(["_trackPageview",n.fullPath])})))}],Ec=[];class Sc extends class{constructor(){this.store=new Ft({data:{state:{}}})}$get(n){return this.store.state[n]}$set(n,e){Ft.set(this.store.state,n,e)}$emit(...n){this.store.$emit(...n)}$on(...n){this.store.$on(...n)}}{}Object.assign(Sc.prototype,{getPageAsyncComponent:is,getLayoutAsyncComponent:rs,getAsyncComponent:ss,getVueComponent:cs});var Ac={install(n){const e=new Sc;n.$vuepress=e,n.prototype.$vuepress=e}};function Ic(n,e){const t=e.toLowerCase();return n.options.routes.some(n=>n.path.toLowerCase()===t)}var jc={props:{pageKey:String,slotKey:{type:String,default:"default"}},render(n){const e=this.pageKey||this.$parent.$page.key;return ds("pageKey",e),Ft.component(e)||Ft.component(e,is(e)),Ft.component(e)?n(e):n("")}},Pc={functional:!0,props:{slotKey:String,required:!0},render:(n,{props:e,slots:t})=>n("div",{class:["content__"+e.slotKey]},t()[e.slotKey])},zc={computed:{openInNewWindowTitle(){return this.$themeLocaleConfig.openNewWindowText||"(opens new window)"}}},Mc=(t(237),t(238),Object(gc.a)(zc,(function(){var n=this._self._c;return n("span",[n("svg",{staticClass:"icon outbound",attrs:{xmlns:"http://www.w3.org/2000/svg","aria-hidden":"true",focusable:"false",x:"0px",y:"0px",viewBox:"0 0 100 100",width:"15",height:"15"}},[n("path",{attrs:{fill:"currentColor",d:"M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"}}),this._v(" "),n("polygon",{attrs:{fill:"currentColor",points:"45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"}})]),this._v(" "),n("span",{staticClass:"sr-only"},[this._v(this._s(this.openInNewWindowTitle))])])}),[],!1,null,null,null).exports),Oc={functional:!0,render(n,{parent:e,children:t}){if(e._isMounted)return t;e.$once("hook:mounted",()=>{e.$forceUpdate()})}};Ft.config.productionTip=!1,Ft.use(Hr),Ft.use(Ac),Ft.mixin(function(n,e,t=Ft){!function(n){n.locales&&Object.keys(n.locales).forEach(e=>{n.locales[e].path=e});Object.freeze(n)}(e),t.$vuepress.$set("siteData",e);const o=new(n(t.$vuepress.$get("siteData"))),a=Object.getOwnPropertyDescriptors(Object.getPrototypeOf(o)),i={};return Object.keys(a).reduce((n,e)=>(e.startsWith("$")&&(n[e]=a[e].get),n),i),{computed:i}}(n=>class{setPage(n){this.__page=n}get $site(){return n}get $themeConfig(){return this.$site.themeConfig}get $frontmatter(){return this.$page.frontmatter}get $localeConfig(){const{locales:n={}}=this.$site;let e,t;for(const o in n)"/"===o?t=n[o]:0===this.$page.path.indexOf(o)&&(e=n[o]);return e||t||{}}get $siteTitle(){return this.$localeConfig.title||this.$site.title||""}get $canonicalUrl(){const{canonicalUrl:n}=this.$page.frontmatter;return"string"==typeof n&&n}get $title(){const n=this.$page,{metaTitle:e}=this.$page.frontmatter;if("string"==typeof e)return e;const t=this.$siteTitle,o=n.frontmatter.home?null:n.frontmatter.title||n.title;return t?o?o+" | "+t:t:o||"VuePress"}get $description(){const n=function(n){if(n){const e=n.filter(n=>"description"===n.name)[0];if(e)return e.content}}(this.$page.frontmatter.meta);return n||(this.$page.frontmatter.description||this.$localeConfig.description||this.$site.description||"")}get $lang(){return this.$page.frontmatter.lang||this.$localeConfig.lang||"en-US"}get $localePath(){return this.$localeConfig.path||"/"}get $themeLocaleConfig(){return(this.$site.themeConfig.locales||{})[this.$localePath]||{}}get $page(){return this.__page?this.__page:function(n,e){for(let t=0;t<n.length;t++){const o=n[t];if(o.path.toLowerCase()===e.toLowerCase())return o}return{path:"",frontmatter:{}}}(this.$site.pages,this.$route.path)}},bc)),Ft.component("Content",jc),Ft.component("ContentSlotsDistributor",Pc),Ft.component("OutboundLink",Mc),Ft.component("ClientOnly",Oc),Ft.component("Layout",rs("Layout")),Ft.component("NotFound",rs("NotFound")),Ft.prototype.$withBase=function(n){const e=this.$site.base;return"/"===n.charAt(0)?e+n.slice(1):n},window.__VUEPRESS__={version:"1.9.5",hash:"15f3255"},async function(n){const e="undefined"!=typeof window&&window.__VUEPRESS_ROUTER_BASE__?window.__VUEPRESS_ROUTER_BASE__:bc.routerBase||bc.base,t=new Hr({base:e,mode:"history",fallback:!1,routes:vc,scrollBehavior:(n,e,t)=>t||(n.hash?!Ft.$vuepress.$get("disableScrollBehavior")&&{selector:decodeURIComponent(n.hash)}:{x:0,y:0})});!function(n){n.beforeEach((e,t,o)=>{if(Ic(n,e.path))o();else if(/(\/|\.html)$/.test(e.path))if(/\/$/.test(e.path)){const t=e.path.replace(/\/$/,"")+".html";Ic(n,t)?o(t):o()}else o();else{const t=e.path+"/",a=e.path+".html";Ic(n,a)?o(a):Ic(n,t)?o(t):o()}})}(t);const o={};try{await Promise.all(Cc.filter(n=>"function"==typeof n).map(e=>e({Vue:Ft,options:o,router:t,siteData:bc,isServer:n})))}catch(n){console.error(n)}return{app:new Ft(Object.assign(o,{router:t,render:n=>n("div",{attrs:{id:"app"}},[n("RouterView",{ref:"layout"}),n("div",{class:"global-ui"},Ec.map(e=>n(e)))])})),router:t}}(!1).then(({app:n,router:e})=>{e.onReady(()=>{n.$mount("#app")})})}]);